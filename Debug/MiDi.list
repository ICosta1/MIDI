
MiDi.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00003860  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000c4  08003a00  08003a00  00013a00  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08003ac4  08003ac4  00013ac4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08003ac8  08003ac8  00013ac8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000110  20000000  08003acc  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .ccmram       00000000  10000000  10000000  00020110  2**0
                  CONTENTS
  7 .bss          0000314c  20000110  20000110  00020110  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  2000325c  2000325c  00020110  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00020110  2**0
                  CONTENTS, READONLY
 10 .debug_info   0002508c  00000000  00000000  00020140  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 00004d18  00000000  00000000  000451cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000b774  00000000  00000000  00049ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00000ff0  00000000  00000000  00055658  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000015c8  00000000  00000000  00056648  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0000980c  00000000  00000000  00057c10  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    00005fe3  00000000  00000000  0006141c  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  000673ff  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00002bd0  00000000  00000000  0006747c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000110 	.word	0x20000110
 80001bc:	00000000 	.word	0x00000000
 80001c0:	080039e8 	.word	0x080039e8

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	20000114 	.word	0x20000114
 80001dc:	080039e8 	.word	0x080039e8

080001e0 <HAL_Init>:
  */
HAL_StatusTypeDef HAL_Init(void)
{
  /* Configure Flash prefetch */
#if (PREFETCH_ENABLE != 0U)
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80001e0:	4a07      	ldr	r2, [pc, #28]	; (8000200 <HAL_Init+0x20>)
{
 80001e2:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 80001e4:	6813      	ldr	r3, [r2, #0]
 80001e6:	f043 0310 	orr.w	r3, r3, #16
 80001ea:	6013      	str	r3, [r2, #0]
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80001ec:	2003      	movs	r0, #3
 80001ee:	f000 f81b 	bl	8000228 <HAL_NVIC_SetPriorityGrouping>

  /* Enable systick and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 80001f2:	2000      	movs	r0, #0
 80001f4:	f003 f982 	bl	80034fc <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 80001f8:	f003 f93a 	bl	8003470 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
}
 80001fc:	2000      	movs	r0, #0
 80001fe:	bd08      	pop	{r3, pc}
 8000200:	40022000 	.word	0x40022000

08000204 <HAL_IncTick>:
  *         implementations  in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 8000204:	4a03      	ldr	r2, [pc, #12]	; (8000214 <HAL_IncTick+0x10>)
 8000206:	4b04      	ldr	r3, [pc, #16]	; (8000218 <HAL_IncTick+0x14>)
 8000208:	6811      	ldr	r1, [r2, #0]
 800020a:	781b      	ldrb	r3, [r3, #0]
 800020c:	440b      	add	r3, r1
 800020e:	6013      	str	r3, [r2, #0]
 8000210:	4770      	bx	lr
 8000212:	bf00      	nop
 8000214:	20002a48 	.word	0x20002a48
 8000218:	20000000 	.word	0x20000000

0800021c <HAL_GetTick>:
  *         implementations  in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;  
 800021c:	4b01      	ldr	r3, [pc, #4]	; (8000224 <HAL_GetTick+0x8>)
 800021e:	6818      	ldr	r0, [r3, #0]
}
 8000220:	4770      	bx	lr
 8000222:	bf00      	nop
 8000224:	20002a48 	.word	0x20002a48

08000228 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000228:	4a07      	ldr	r2, [pc, #28]	; (8000248 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800022a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800022c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8000230:	041b      	lsls	r3, r3, #16
 8000232:	0c1b      	lsrs	r3, r3, #16
 8000234:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8000238:	0200      	lsls	r0, r0, #8
 800023a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800023e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8000242:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8000244:	60d3      	str	r3, [r2, #12]
 8000246:	4770      	bx	lr
 8000248:	e000ed00 	.word	0xe000ed00

0800024c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800024c:	4b17      	ldr	r3, [pc, #92]	; (80002ac <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15 as described in the table CORTEX_NVIC_Priority_Table
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800024e:	b530      	push	{r4, r5, lr}
 8000250:	68dc      	ldr	r4, [r3, #12]
 8000252:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000256:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800025a:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800025c:	2b04      	cmp	r3, #4
 800025e:	bf28      	it	cs
 8000260:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000262:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000264:	f04f 0501 	mov.w	r5, #1
 8000268:	fa05 f303 	lsl.w	r3, r5, r3
 800026c:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000270:	bf8c      	ite	hi
 8000272:	3c03      	subhi	r4, #3
 8000274:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000276:	4019      	ands	r1, r3
 8000278:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800027a:	fa05 f404 	lsl.w	r4, r5, r4
 800027e:	3c01      	subs	r4, #1
 8000280:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 8000282:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000284:	ea42 0201 	orr.w	r2, r2, r1
 8000288:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800028c:	bfaf      	iteee	ge
 800028e:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000292:	f000 000f 	andlt.w	r0, r0, #15
 8000296:	4b06      	ldrlt	r3, [pc, #24]	; (80002b0 <HAL_NVIC_SetPriority+0x64>)
 8000298:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800029a:	bfa5      	ittet	ge
 800029c:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 80002a0:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002a2:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002a4:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 80002a8:	bd30      	pop	{r4, r5, pc}
 80002aa:	bf00      	nop
 80002ac:	e000ed00 	.word	0xe000ed00
 80002b0:	e000ed14 	.word	0xe000ed14

080002b4 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80002b4:	0942      	lsrs	r2, r0, #5
 80002b6:	2301      	movs	r3, #1
 80002b8:	f000 001f 	and.w	r0, r0, #31
 80002bc:	fa03 f000 	lsl.w	r0, r3, r0
 80002c0:	4b01      	ldr	r3, [pc, #4]	; (80002c8 <HAL_NVIC_EnableIRQ+0x14>)
 80002c2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80002c6:	4770      	bx	lr
 80002c8:	e000e100 	.word	0xe000e100

080002cc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80002cc:	3801      	subs	r0, #1
 80002ce:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80002d2:	d20a      	bcs.n	80002ea <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80002d4:	4b06      	ldr	r3, [pc, #24]	; (80002f0 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002d6:	4a07      	ldr	r2, [pc, #28]	; (80002f4 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80002d8:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80002da:	21f0      	movs	r1, #240	; 0xf0
 80002dc:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80002e0:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80002e2:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80002e4:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80002e6:	601a      	str	r2, [r3, #0]
 80002e8:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80002ea:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80002ec:	4770      	bx	lr
 80002ee:	bf00      	nop
 80002f0:	e000e010 	.word	0xe000e010
 80002f4:	e000ed00 	.word	0xe000ed00

080002f8 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 80002f8:	4b04      	ldr	r3, [pc, #16]	; (800030c <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80002fa:	681a      	ldr	r2, [r3, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 80002fc:	2804      	cmp	r0, #4
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 80002fe:	bf0c      	ite	eq
 8000300:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8000304:	f022 0204 	bicne.w	r2, r2, #4
 8000308:	601a      	str	r2, [r3, #0]
 800030a:	4770      	bx	lr
 800030c:	e000e010 	.word	0xe000e010

08000310 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000310:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000314:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000318:	f8df 9190 	ldr.w	r9, [pc, #400]	; 80004ac <HAL_GPIO_Init+0x19c>
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR;
 800031c:	4a61      	ldr	r2, [pc, #388]	; (80004a4 <HAL_GPIO_Init+0x194>)
  uint32_t position = 0x00U;
 800031e:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != RESET)
 8000320:	fa38 f403 	lsrs.w	r4, r8, r3
 8000324:	d102      	bne.n	800032c <HAL_GPIO_Init+0x1c>
      }
    }
    
    position++;
  }
}
 8000326:	b003      	add	sp, #12
 8000328:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 800032c:	f04f 0e01 	mov.w	lr, #1
 8000330:	fa0e fe03 	lsl.w	lr, lr, r3
    if(iocurrent)
 8000334:	ea18 060e 	ands.w	r6, r8, lr
 8000338:	f000 80a6 	beq.w	8000488 <HAL_GPIO_Init+0x178>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 800033c:	684c      	ldr	r4, [r1, #4]
 800033e:	f024 0710 	bic.w	r7, r4, #16
 8000342:	2f02      	cmp	r7, #2
 8000344:	d116      	bne.n	8000374 <HAL_GPIO_Init+0x64>
        temp = GPIOx->AFR[position >> 3];
 8000346:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 800034a:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 800034e:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3];
 8000352:	f8da 5020 	ldr.w	r5, [sl, #32]
        temp &= ~(0xFU << ((uint32_t)(position & 0x07U) * 4U)) ;
 8000356:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800035a:	f04f 0c0f 	mov.w	ip, #15
 800035e:	fa0c fc0b 	lsl.w	ip, ip, fp
 8000362:	ea25 0c0c 	bic.w	ip, r5, ip
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & 0x07U) * 4U));
 8000366:	690d      	ldr	r5, [r1, #16]
 8000368:	fa05 f50b 	lsl.w	r5, r5, fp
 800036c:	ea45 050c 	orr.w	r5, r5, ip
        GPIOx->AFR[position >> 3] = temp;
 8000370:	f8ca 5020 	str.w	r5, [sl, #32]
 8000374:	ea4f 0a43 	mov.w	sl, r3, lsl #1
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000378:	2503      	movs	r5, #3
      temp = GPIOx->MODER;
 800037a:	f8d0 b000 	ldr.w	fp, [r0]
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 800037e:	fa05 f50a 	lsl.w	r5, r5, sl
 8000382:	43ed      	mvns	r5, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000384:	f004 0c03 	and.w	ip, r4, #3
      temp &= ~(GPIO_MODER_MODER0 << (position * 2U));
 8000388:	ea0b 0b05 	and.w	fp, fp, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 800038c:	fa0c fc0a 	lsl.w	ip, ip, sl
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000390:	3f01      	subs	r7, #1
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000392:	ea4c 0c0b 	orr.w	ip, ip, fp
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8000396:	2f01      	cmp	r7, #1
      GPIOx->MODER = temp;
 8000398:	f8c0 c000 	str.w	ip, [r0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800039c:	d811      	bhi.n	80003c2 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
 800039e:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDER_OSPEEDR0 << (position * 2U));
 80003a0:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2U));
 80003a4:	68cf      	ldr	r7, [r1, #12]
 80003a6:	fa07 fc0a 	lsl.w	ip, r7, sl
 80003aa:	ea4c 070b 	orr.w	r7, ip, fp
        GPIOx->OSPEEDR = temp;
 80003ae:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 80003b0:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT_0 << position) ;
 80003b2:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 80003b6:	f3c4 1700 	ubfx	r7, r4, #4, #1
 80003ba:	409f      	lsls	r7, r3
 80003bc:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 80003c0:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 80003c2:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPDR0 << (position * 2U));
 80003c4:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 80003c6:	688f      	ldr	r7, [r1, #8]
 80003c8:	fa07 f70a 	lsl.w	r7, r7, sl
 80003cc:	433d      	orrs	r5, r7
      GPIOx->PUPDR = temp;
 80003ce:	60c5      	str	r5, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80003d0:	00e5      	lsls	r5, r4, #3
 80003d2:	d559      	bpl.n	8000488 <HAL_GPIO_Init+0x178>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003d4:	f8d9 5018 	ldr.w	r5, [r9, #24]
 80003d8:	f045 0501 	orr.w	r5, r5, #1
 80003dc:	f8c9 5018 	str.w	r5, [r9, #24]
 80003e0:	f8d9 5018 	ldr.w	r5, [r9, #24]
 80003e4:	f023 0703 	bic.w	r7, r3, #3
 80003e8:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80003ec:	f005 0501 	and.w	r5, r5, #1
 80003f0:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 80003f4:	9501      	str	r5, [sp, #4]
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 80003f6:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80003fa:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 80003fc:	68bd      	ldr	r5, [r7, #8]
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 80003fe:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8000402:	f04f 0e0f 	mov.w	lr, #15
 8000406:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800040a:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~((0x0FU) << (4U * (position & 0x03U)));
 800040e:	ea25 0e0e 	bic.w	lr, r5, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8000412:	d03b      	beq.n	800048c <HAL_GPIO_Init+0x17c>
 8000414:	4d24      	ldr	r5, [pc, #144]	; (80004a8 <HAL_GPIO_Init+0x198>)
 8000416:	42a8      	cmp	r0, r5
 8000418:	d03a      	beq.n	8000490 <HAL_GPIO_Init+0x180>
 800041a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800041e:	42a8      	cmp	r0, r5
 8000420:	d038      	beq.n	8000494 <HAL_GPIO_Init+0x184>
 8000422:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000426:	42a8      	cmp	r0, r5
 8000428:	d036      	beq.n	8000498 <HAL_GPIO_Init+0x188>
 800042a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800042e:	42a8      	cmp	r0, r5
 8000430:	d034      	beq.n	800049c <HAL_GPIO_Init+0x18c>
 8000432:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000436:	42a8      	cmp	r0, r5
 8000438:	d032      	beq.n	80004a0 <HAL_GPIO_Init+0x190>
 800043a:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 800043e:	42a8      	cmp	r0, r5
 8000440:	bf14      	ite	ne
 8000442:	2507      	movne	r5, #7
 8000444:	2506      	moveq	r5, #6
 8000446:	fa05 f50c 	lsl.w	r5, r5, ip
 800044a:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 800044e:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR;
 8000450:	6815      	ldr	r5, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 8000452:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8000454:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8000458:	bf0c      	ite	eq
 800045a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800045c:	4335      	orrne	r5, r6
        EXTI->IMR = temp;
 800045e:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR;
 8000460:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8000462:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8000466:	bf0c      	ite	eq
 8000468:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800046a:	4335      	orrne	r5, r6
        EXTI->EMR = temp;
 800046c:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR;
 800046e:	6895      	ldr	r5, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8000470:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 8000474:	bf0c      	ite	eq
 8000476:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8000478:	4335      	orrne	r5, r6
        EXTI->RTSR = temp;
 800047a:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR;
 800047c:	68d5      	ldr	r5, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 800047e:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 8000480:	bf54      	ite	pl
 8000482:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8000484:	4335      	orrmi	r5, r6
        EXTI->FTSR = temp;
 8000486:	60d5      	str	r5, [r2, #12]
    position++;
 8000488:	3301      	adds	r3, #1
 800048a:	e749      	b.n	8000320 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 800048c:	2500      	movs	r5, #0
 800048e:	e7da      	b.n	8000446 <HAL_GPIO_Init+0x136>
 8000490:	2501      	movs	r5, #1
 8000492:	e7d8      	b.n	8000446 <HAL_GPIO_Init+0x136>
 8000494:	2502      	movs	r5, #2
 8000496:	e7d6      	b.n	8000446 <HAL_GPIO_Init+0x136>
 8000498:	2503      	movs	r5, #3
 800049a:	e7d4      	b.n	8000446 <HAL_GPIO_Init+0x136>
 800049c:	2504      	movs	r5, #4
 800049e:	e7d2      	b.n	8000446 <HAL_GPIO_Init+0x136>
 80004a0:	2505      	movs	r5, #5
 80004a2:	e7d0      	b.n	8000446 <HAL_GPIO_Init+0x136>
 80004a4:	40010400 	.word	0x40010400
 80004a8:	48000400 	.word	0x48000400
 80004ac:	40021000 	.word	0x40021000

080004b0 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80004b0:	b10a      	cbz	r2, 80004b6 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80004b2:	6181      	str	r1, [r0, #24]
 80004b4:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80004b6:	6281      	str	r1, [r0, #40]	; 0x28
 80004b8:	4770      	bx	lr

080004ba <HAL_PCD_Init>:
  *         parameters in the PCD_InitTypeDef and create the associated handle.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Init(PCD_HandleTypeDef *hpcd)
{ 
 80004ba:	b538      	push	{r3, r4, r5, lr}
  uint32_t i = 0U;

  uint32_t wInterrupt_Mask = 0U;
  
  /* Check the PCD handle allocation */
  if(hpcd == NULL)
 80004bc:	4604      	mov	r4, r0
 80004be:	2800      	cmp	r0, #0
 80004c0:	d04d      	beq.n	800055e <HAL_PCD_Init+0xa4>
  }
  
  /* Check the parameters */
  assert_param(IS_PCD_ALL_INSTANCE(hpcd->Instance));

  if(hpcd->State == HAL_PCD_STATE_RESET)
 80004c2:	f890 3371 	ldrb.w	r3, [r0, #881]	; 0x371
 80004c6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80004ca:	b91b      	cbnz	r3, 80004d4 <HAL_PCD_Init+0x1a>
  {  
    /* Allocate lock resource and initialize it */
    hpcd->Lock = HAL_UNLOCKED;
 80004cc:	f880 2370 	strb.w	r2, [r0, #880]	; 0x370
  
    /* Init the low level hardware : GPIO, CLOCK, NVIC... */
    HAL_PCD_MspInit(hpcd);
 80004d0:	f003 f8ca 	bl	8003668 <HAL_PCD_MspInit>
  }

  hpcd->State = HAL_PCD_STATE_BUSY;
 80004d4:	2303      	movs	r3, #3
 
 /* Init endpoints structures */
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 80004d6:	2100      	movs	r1, #0
 80004d8:	6860      	ldr	r0, [r4, #4]
  hpcd->State = HAL_PCD_STATE_BUSY;
 80004da:	f884 3371 	strb.w	r3, [r4, #881]	; 0x371
 80004de:	460a      	mov	r2, r1
 80004e0:	f104 0328 	add.w	r3, r4, #40	; 0x28
 {
   /* Init ep structure */
   hpcd->IN_ep[i].is_in = 1U;
 80004e4:	2501      	movs	r5, #1
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 80004e6:	4281      	cmp	r1, r0
 80004e8:	f103 031c 	add.w	r3, r3, #28
 80004ec:	d11b      	bne.n	8000526 <HAL_PCD_Init+0x6c>
 80004ee:	2000      	movs	r0, #0
 80004f0:	f504 72e6 	add.w	r2, r4, #460	; 0x1cc
 80004f4:	4603      	mov	r3, r0
   hpcd->IN_ep[i].maxpacket =  0U;
   hpcd->IN_ep[i].xfer_buff = 0U;
   hpcd->IN_ep[i].xfer_len = 0U;
 }
 
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 80004f6:	4281      	cmp	r1, r0
 80004f8:	f102 021c 	add.w	r2, r2, #28
 80004fc:	d121      	bne.n	8000542 <HAL_PCD_Init+0x88>
   hpcd->OUT_ep[i].xfer_len = 0U;
 }
  
 /* Init Device */
 /*CNTR_FRES = 1U*/
 hpcd->Instance->CNTR = USB_CNTR_FRES;
 80004fe:	6822      	ldr	r2, [r4, #0]
 8000500:	2101      	movs	r1, #1
  /*set wInterrupt_Mask global variable*/
  wInterrupt_Mask = USB_CNTR_CTRM  | USB_CNTR_WKUPM | USB_CNTR_SUSPM | USB_CNTR_ERRM \
  | USB_CNTR_SOFM | USB_CNTR_ESOFM | USB_CNTR_RESETM;
  
  /*Set interrupt mask*/
  hpcd->Instance->CNTR = wInterrupt_Mask;
 8000502:	f44f 403f 	mov.w	r0, #48896	; 0xbf00
 hpcd->Instance->CNTR = USB_CNTR_FRES;
 8000506:	f8a2 1040 	strh.w	r1, [r2, #64]	; 0x40
 hpcd->Instance->CNTR = 0U;
 800050a:	f8a2 3040 	strh.w	r3, [r2, #64]	; 0x40
 hpcd->Instance->ISTR = 0U;
 800050e:	f8a2 3044 	strh.w	r3, [r2, #68]	; 0x44
 hpcd->Instance->BTABLE = BTABLE_ADDRESS;
 8000512:	f8a2 3050 	strh.w	r3, [r2, #80]	; 0x50
  hpcd->Instance->CNTR = wInterrupt_Mask;
 8000516:	f8a2 0040 	strh.w	r0, [r2, #64]	; 0x40
  
  hpcd->USB_Address = 0U;
 800051a:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
  hpcd->State= HAL_PCD_STATE_READY;

 return HAL_OK;
 800051e:	2000      	movs	r0, #0
  hpcd->State= HAL_PCD_STATE_READY;
 8000520:	f884 1371 	strb.w	r1, [r4, #881]	; 0x371
 return HAL_OK;
 8000524:	bd38      	pop	{r3, r4, r5, pc}
   hpcd->IN_ep[i].num = i;
 8000526:	f803 1c1c 	strb.w	r1, [r3, #-28]
   hpcd->IN_ep[i].is_in = 1U;
 800052a:	f803 5c1b 	strb.w	r5, [r3, #-27]
   hpcd->IN_ep[i].type = PCD_EP_TYPE_CTRL;
 800052e:	f803 2c19 	strb.w	r2, [r3, #-25]
   hpcd->IN_ep[i].maxpacket =  0U;
 8000532:	f843 2c10 	str.w	r2, [r3, #-16]
   hpcd->IN_ep[i].xfer_buff = 0U;
 8000536:	f843 2c0c 	str.w	r2, [r3, #-12]
   hpcd->IN_ep[i].xfer_len = 0U;
 800053a:	f843 2c08 	str.w	r2, [r3, #-8]
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 800053e:	3101      	adds	r1, #1
 8000540:	e7d1      	b.n	80004e6 <HAL_PCD_Init+0x2c>
   hpcd->OUT_ep[i].num = i;
 8000542:	f802 0c1c 	strb.w	r0, [r2, #-28]
   hpcd->OUT_ep[i].is_in = 0U;
 8000546:	f802 3c1b 	strb.w	r3, [r2, #-27]
   hpcd->OUT_ep[i].type = PCD_EP_TYPE_CTRL;
 800054a:	f802 3c19 	strb.w	r3, [r2, #-25]
   hpcd->OUT_ep[i].maxpacket = 0U;
 800054e:	f842 3c10 	str.w	r3, [r2, #-16]
   hpcd->OUT_ep[i].xfer_buff = 0U;
 8000552:	f842 3c0c 	str.w	r3, [r2, #-12]
   hpcd->OUT_ep[i].xfer_len = 0U;
 8000556:	f842 3c08 	str.w	r3, [r2, #-8]
 for (i = 0U; i < hpcd->Init.dev_endpoints ; i++)
 800055a:	3001      	adds	r0, #1
 800055c:	e7cb      	b.n	80004f6 <HAL_PCD_Init+0x3c>
    return HAL_ERROR;
 800055e:	2001      	movs	r0, #1
}
 8000560:	bd38      	pop	{r3, r4, r5, pc}

08000562 <HAL_PCD_Start>:
  * @brief  Start the USB device.
  * @param  hpcd PCD handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_Start(PCD_HandleTypeDef *hpcd)
{ 
 8000562:	b508      	push	{r3, lr}
  /*  DP Pull-Down is external */
  HAL_PCDEx_SetConnectionState (hpcd, 1U);
 8000564:	2101      	movs	r1, #1
 8000566:	f003 f996 	bl	8003896 <HAL_PCDEx_SetConnectionState>
  
  return HAL_OK;
}
 800056a:	2000      	movs	r0, #0
 800056c:	bd08      	pop	{r3, pc}

0800056e <HAL_PCD_SetAddress>:
  * @param  address new device address
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_SetAddress(PCD_HandleTypeDef *hpcd, uint8_t address)
{
   __HAL_LOCK(hpcd); 
 800056e:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 8000572:	2b01      	cmp	r3, #1
 8000574:	d00f      	beq.n	8000596 <HAL_PCD_SetAddress+0x28>
 8000576:	2301      	movs	r3, #1
 8000578:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370

   if(address == 0U) 
 800057c:	b941      	cbnz	r1, 8000590 <HAL_PCD_SetAddress+0x22>
   {
     /* set device address and enable function */
     hpcd->Instance->DADDR = USB_DADDR_EF;
 800057e:	6803      	ldr	r3, [r0, #0]
 8000580:	2280      	movs	r2, #128	; 0x80
 8000582:	f8a3 204c 	strh.w	r2, [r3, #76]	; 0x4c
   else /* USB Address will be applied later */
   {
     hpcd->USB_Address = address;
   }

  __HAL_UNLOCK(hpcd);   
 8000586:	2300      	movs	r3, #0
 8000588:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 800058c:	4618      	mov	r0, r3
 800058e:	4770      	bx	lr
     hpcd->USB_Address = address;
 8000590:	f880 1024 	strb.w	r1, [r0, #36]	; 0x24
 8000594:	e7f7      	b.n	8000586 <HAL_PCD_SetAddress+0x18>
   __HAL_LOCK(hpcd); 
 8000596:	2002      	movs	r0, #2
  return HAL_OK;
}
 8000598:	4770      	bx	lr
	...

0800059c <HAL_PCD_EP_Open>:
  * @param  ep_mps endpoint max packet size
  * @param  ep_type endpoint type   
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Open(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint16_t ep_mps, uint8_t ep_type)
{
 800059c:	b5f0      	push	{r4, r5, r6, r7, lr}
  HAL_StatusTypeDef  ret = HAL_OK;
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 800059e:	b24c      	sxtb	r4, r1
 80005a0:	2c00      	cmp	r4, #0
 80005a2:	f001 067f 	and.w	r6, r1, #127	; 0x7f
 80005a6:	f04f 051c 	mov.w	r5, #28
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80005aa:	bfb5      	itete	lt
 80005ac:	fb05 0106 	mlalt	r1, r5, r6, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80005b0:	fb05 0101 	mlage	r1, r5, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 80005b4:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr & 0x7FU];
 80005b6:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 80005ba:	0fe4      	lsrs	r4, r4, #31
  ep->num   = ep_addr & 0x7FU;
 80005bc:	700e      	strb	r6, [r1, #0]
  ep->is_in = (0x80U & ep_addr) != 0U;
 80005be:	704c      	strb	r4, [r1, #1]
  ep->maxpacket = ep_mps;
  ep->type = ep_type;
 80005c0:	70cb      	strb	r3, [r1, #3]
  
  __HAL_LOCK(hpcd); 
 80005c2:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
  ep->maxpacket = ep_mps;
 80005c6:	60ca      	str	r2, [r1, #12]
  __HAL_LOCK(hpcd); 
 80005c8:	2b01      	cmp	r3, #1
 80005ca:	f000 8177 	beq.w	80008bc <HAL_PCD_EP_Open+0x320>
 80005ce:	2301      	movs	r3, #1
 80005d0:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370

  /* initialize Endpoint */
  switch (ep->type)
 80005d4:	78cd      	ldrb	r5, [r1, #3]
 80005d6:	780c      	ldrb	r4, [r1, #0]
 80005d8:	6803      	ldr	r3, [r0, #0]
 80005da:	2d03      	cmp	r5, #3
 80005dc:	d810      	bhi.n	8000600 <HAL_PCD_EP_Open+0x64>
 80005de:	e8df f005 	tbb	[pc, r5]
 80005e2:	6d02      	.short	0x6d02
 80005e4:	6157      	.short	0x6157
  {
  case PCD_EP_TYPE_CTRL:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_CONTROL);
 80005e6:	b224      	sxth	r4, r4
 80005e8:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 80005ec:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 80005f0:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 80005f4:	042d      	lsls	r5, r5, #16
 80005f6:	0c2d      	lsrs	r5, r5, #16
 80005f8:	f445 7500 	orr.w	r5, r5, #512	; 0x200
    break;
  case PCD_EP_TYPE_INTR:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
    break;
  case PCD_EP_TYPE_ISOC:
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
 80005fc:	f823 5024 	strh.w	r5, [r3, r4, lsl #2]
    break;
  default:
    break;
  } 
  
  PCD_SET_EP_ADDRESS(hpcd->Instance, ep->num, ep->num);
 8000600:	780c      	ldrb	r4, [r1, #0]
 8000602:	b227      	sxth	r7, r4
 8000604:	f640 750f 	movw	r5, #3855	; 0xf0f
 8000608:	f833 6027 	ldrh.w	r6, [r3, r7, lsl #2]
 800060c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 8000610:	402e      	ands	r6, r5
 8000612:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8000616:	4334      	orrs	r4, r6
 8000618:	f823 4027 	strh.w	r4, [r3, r7, lsl #2]
  
  if (ep->doublebuffer == 0U) 
 800061c:	7a8e      	ldrb	r6, [r1, #10]
 800061e:	780c      	ldrb	r4, [r1, #0]
 8000620:	2e00      	cmp	r6, #0
 8000622:	f040 8099 	bne.w	8000758 <HAL_PCD_EP_Open+0x1bc>
  {
    if (ep->is_in)
 8000626:	f891 e001 	ldrb.w	lr, [r1, #1]
 800062a:	888f      	ldrh	r7, [r1, #4]
 800062c:	2608      	movs	r6, #8
 800062e:	f1be 0f00 	cmp.w	lr, #0
 8000632:	d04f      	beq.n	80006d4 <HAL_PCD_EP_Open+0x138>
    {
      /*Set the endpoint Transmit buffer address */
      PCD_SET_EP_TX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 8000634:	f8b3 2050 	ldrh.w	r2, [r3, #80]	; 0x50
 8000638:	b292      	uxth	r2, r2
 800063a:	fb16 2404 	smlabb	r4, r6, r4, r2
 800063e:	441c      	add	r4, r3
 8000640:	f027 0701 	bic.w	r7, r7, #1
 8000644:	f8a4 7400 	strh.w	r7, [r4, #1024]	; 0x400
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8000648:	780c      	ldrb	r4, [r1, #0]
 800064a:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800064e:	0652      	lsls	r2, r2, #25
 8000650:	d508      	bpl.n	8000664 <HAL_PCD_EP_Open+0xc8>
 8000652:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000656:	4015      	ands	r5, r2
 8000658:	f445 4500 	orr.w	r5, r5, #32768	; 0x8000
 800065c:	f045 05c0 	orr.w	r5, r5, #192	; 0xc0
 8000660:	f823 5024 	strh.w	r5, [r3, r4, lsl #2]
      /* Configure NAK status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_NAK) 
 8000664:	7809      	ldrb	r1, [r1, #0]
 8000666:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 800066a:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 800066e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8000672:	0412      	lsls	r2, r2, #16
 8000674:	0c12      	lsrs	r2, r2, #16
 8000676:	f082 0220 	eor.w	r2, r2, #32
      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
      /*Set the endpoint Receive buffer counter*/
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      /* Configure VALID status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 800067a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800067e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
      PCD_RX_DTOG(hpcd->Instance, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000682:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8000686:	2300      	movs	r3, #0
 8000688:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  return ret;
 800068c:	4618      	mov	r0, r3
 800068e:	bdf0      	pop	{r4, r5, r6, r7, pc}
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_BULK);
 8000690:	b224      	sxth	r4, r4
 8000692:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 8000696:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 800069a:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 800069e:	042d      	lsls	r5, r5, #16
 80006a0:	0c2d      	lsrs	r5, r5, #16
 80006a2:	e7ab      	b.n	80005fc <HAL_PCD_EP_Open+0x60>
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_INTERRUPT);
 80006a4:	b224      	sxth	r4, r4
 80006a6:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 80006aa:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 80006ae:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 80006b2:	042d      	lsls	r5, r5, #16
 80006b4:	0c2d      	lsrs	r5, r5, #16
 80006b6:	f445 65c0 	orr.w	r5, r5, #1536	; 0x600
 80006ba:	e79f      	b.n	80005fc <HAL_PCD_EP_Open+0x60>
    PCD_SET_EPTYPE(hpcd->Instance, ep->num, USB_EP_ISOCHRONOUS);
 80006bc:	b224      	sxth	r4, r4
 80006be:	f833 5024 	ldrh.w	r5, [r3, r4, lsl #2]
 80006c2:	f425 45ec 	bic.w	r5, r5, #30208	; 0x7600
 80006c6:	f025 0570 	bic.w	r5, r5, #112	; 0x70
 80006ca:	042d      	lsls	r5, r5, #16
 80006cc:	0c2d      	lsrs	r5, r5, #16
 80006ce:	f445 6580 	orr.w	r5, r5, #1024	; 0x400
 80006d2:	e793      	b.n	80005fc <HAL_PCD_EP_Open+0x60>
      PCD_SET_EP_RX_ADDRESS(hpcd->Instance, ep->num, ep->pmaadress);
 80006d4:	f8b3 5050 	ldrh.w	r5, [r3, #80]	; 0x50
 80006d8:	b2ad      	uxth	r5, r5
 80006da:	fb16 5404 	smlabb	r4, r6, r4, r5
 80006de:	441c      	add	r4, r3
 80006e0:	f027 0701 	bic.w	r7, r7, #1
 80006e4:	f8a4 7404 	strh.w	r7, [r4, #1028]	; 0x404
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
 80006e8:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
 80006ec:	780d      	ldrb	r5, [r1, #0]
 80006ee:	b2a4      	uxth	r4, r4
 80006f0:	2a3e      	cmp	r2, #62	; 0x3e
 80006f2:	fb16 4405 	smlabb	r4, r6, r5, r4
 80006f6:	f203 4606 	addw	r6, r3, #1030	; 0x406
 80006fa:	d927      	bls.n	800074c <HAL_PCD_EP_Open+0x1b0>
 80006fc:	0955      	lsrs	r5, r2, #5
 80006fe:	06d7      	lsls	r7, r2, #27
 8000700:	bf08      	it	eq
 8000702:	f105 35ff 	addeq.w	r5, r5, #4294967295
 8000706:	4a6e      	ldr	r2, [pc, #440]	; (80008c0 <HAL_PCD_EP_Open+0x324>)
 8000708:	bf08      	it	eq
 800070a:	b2ad      	uxtheq	r5, r5
 800070c:	ea42 2585 	orr.w	r5, r2, r5, lsl #10
 8000710:	53a5      	strh	r5, [r4, r6]
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8000712:	780c      	ldrb	r4, [r1, #0]
 8000714:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000718:	0457      	lsls	r7, r2, #17
 800071a:	d50b      	bpl.n	8000734 <HAL_PCD_EP_Open+0x198>
 800071c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000720:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000724:	0512      	lsls	r2, r2, #20
 8000726:	0d12      	lsrs	r2, r2, #20
 8000728:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 800072c:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000730:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8000734:	7809      	ldrb	r1, [r1, #0]
 8000736:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 800073a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800073e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8000742:	0412      	lsls	r2, r2, #16
 8000744:	0c12      	lsrs	r2, r2, #16
 8000746:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 800074a:	e796      	b.n	800067a <HAL_PCD_EP_Open+0xde>
      PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, ep->maxpacket)
 800074c:	0855      	lsrs	r5, r2, #1
 800074e:	07d2      	lsls	r2, r2, #31
 8000750:	bf48      	it	mi
 8000752:	3501      	addmi	r5, #1
 8000754:	02ad      	lsls	r5, r5, #10
 8000756:	e7db      	b.n	8000710 <HAL_PCD_EP_Open+0x174>
    PCD_SET_EP_DBUF(hpcd->Instance, ep->num);
 8000758:	b224      	sxth	r4, r4
 800075a:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800075e:	f422 72f8 	bic.w	r2, r2, #496	; 0x1f0
 8000762:	0512      	lsls	r2, r2, #20
 8000764:	0d12      	lsrs	r2, r2, #20
 8000766:	f442 4201 	orr.w	r2, r2, #33024	; 0x8100
 800076a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800076e:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
    PCD_SET_EP_DBUF_ADDR(hpcd->Instance, ep->num,ep->pmaaddr0, ep->pmaaddr1)
 8000772:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
 8000776:	b2a6      	uxth	r6, r4
 8000778:	780c      	ldrb	r4, [r1, #0]
 800077a:	2208      	movs	r2, #8
 800077c:	fb12 6404 	smlabb	r4, r2, r4, r6
 8000780:	88ce      	ldrh	r6, [r1, #6]
 8000782:	441c      	add	r4, r3
 8000784:	f026 0601 	bic.w	r6, r6, #1
 8000788:	f8a4 6400 	strh.w	r6, [r4, #1024]	; 0x400
 800078c:	f8b3 4050 	ldrh.w	r4, [r3, #80]	; 0x50
 8000790:	780e      	ldrb	r6, [r1, #0]
 8000792:	b2a4      	uxth	r4, r4
 8000794:	fb12 4206 	smlabb	r2, r2, r6, r4
 8000798:	890c      	ldrh	r4, [r1, #8]
 800079a:	441a      	add	r2, r3
 800079c:	f024 0401 	bic.w	r4, r4, #1
 80007a0:	f8a2 4404 	strh.w	r4, [r2, #1028]	; 0x404
 80007a4:	780a      	ldrb	r2, [r1, #0]
    if (ep->is_in==0U)
 80007a6:	784c      	ldrb	r4, [r1, #1]
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 80007a8:	b212      	sxth	r2, r2
    if (ep->is_in==0U)
 80007aa:	2c00      	cmp	r4, #0
 80007ac:	d145      	bne.n	800083a <HAL_PCD_EP_Open+0x29e>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 80007ae:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 80007b2:	0466      	lsls	r6, r4, #17
 80007b4:	d508      	bpl.n	80007c8 <HAL_PCD_EP_Open+0x22c>
 80007b6:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 80007ba:	4025      	ands	r5, r4
 80007bc:	f445 4540 	orr.w	r5, r5, #49152	; 0xc000
 80007c0:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 80007c4:	f823 5022 	strh.w	r5, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80007c8:	780c      	ldrb	r4, [r1, #0]
 80007ca:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80007ce:	0655      	lsls	r5, r2, #25
 80007d0:	d50b      	bpl.n	80007ea <HAL_PCD_EP_Open+0x24e>
 80007d2:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80007d6:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80007da:	0512      	lsls	r2, r2, #20
 80007dc:	0d12      	lsrs	r2, r2, #20
 80007de:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80007e2:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 80007e6:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 80007ea:	780c      	ldrb	r4, [r1, #0]
 80007ec:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80007f0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80007f4:	0512      	lsls	r2, r2, #20
 80007f6:	0d12      	lsrs	r2, r2, #20
 80007f8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80007fc:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8000800:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8000804:	780d      	ldrb	r5, [r1, #0]
 8000806:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 800080a:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800080e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8000812:	0412      	lsls	r2, r2, #16
 8000814:	0c12      	lsrs	r2, r2, #16
 8000816:	f482 5240 	eor.w	r2, r2, #12288	; 0x3000
 800081a:	f248 0480 	movw	r4, #32896	; 0x8080
 800081e:	4322      	orrs	r2, r4
 8000820:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8000824:	7809      	ldrb	r1, [r1, #0]
 8000826:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 800082a:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 800082e:	f022 0240 	bic.w	r2, r2, #64	; 0x40
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000832:	0412      	lsls	r2, r2, #16
 8000834:	0c12      	lsrs	r2, r2, #16
 8000836:	4322      	orrs	r2, r4
 8000838:	e723      	b.n	8000682 <HAL_PCD_EP_Open+0xe6>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 800083a:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 800083e:	0464      	lsls	r4, r4, #17
 8000840:	d508      	bpl.n	8000854 <HAL_PCD_EP_Open+0x2b8>
 8000842:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000846:	4025      	ands	r5, r4
 8000848:	f445 4540 	orr.w	r5, r5, #49152	; 0xc000
 800084c:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 8000850:	f823 5022 	strh.w	r5, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8000854:	780c      	ldrb	r4, [r1, #0]
 8000856:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800085a:	0652      	lsls	r2, r2, #25
 800085c:	d50b      	bpl.n	8000876 <HAL_PCD_EP_Open+0x2da>
 800085e:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000862:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000866:	0512      	lsls	r2, r2, #20
 8000868:	0d12      	lsrs	r2, r2, #20
 800086a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800086e:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8000872:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8000876:	780c      	ldrb	r4, [r1, #0]
 8000878:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 800087c:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000880:	0512      	lsls	r2, r2, #20
 8000882:	0d12      	lsrs	r2, r2, #20
 8000884:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8000888:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800088c:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8000890:	780d      	ldrb	r5, [r1, #0]
 8000892:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8000896:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 800089a:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800089e:	0412      	lsls	r2, r2, #16
 80008a0:	0c12      	lsrs	r2, r2, #16
 80008a2:	f248 0480 	movw	r4, #32896	; 0x8080
 80008a6:	4322      	orrs	r2, r4
 80008a8:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 80008ac:	7809      	ldrb	r1, [r1, #0]
 80008ae:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 80008b2:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80008b6:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 80008ba:	e7ba      	b.n	8000832 <HAL_PCD_EP_Open+0x296>
  __HAL_LOCK(hpcd); 
 80008bc:	2002      	movs	r0, #2
}
 80008be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80008c0:	ffff8000 	.word	0xffff8000

080008c4 <HAL_PCD_EP_Close>:
  */
HAL_StatusTypeDef HAL_PCD_EP_Close(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{  
  PCD_EPTypeDef *ep;
  
  if ((ep_addr & 0x80U) == 0x80U)
 80008c4:	b24b      	sxtb	r3, r1
 80008c6:	2b00      	cmp	r3, #0
{  
 80008c8:	b530      	push	{r4, r5, lr}
 80008ca:	f04f 021c 	mov.w	r2, #28
 80008ce:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80008d2:	bfb5      	itete	lt
 80008d4:	fb02 0104 	mlalt	r1, r2, r4, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80008d8:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80008dc:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr & 0x7F];
 80008de:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  ep->num   = ep_addr & 0x7FU;
  
  ep->is_in = (0x80U & ep_addr) != 0U;
 80008e2:	0fdb      	lsrs	r3, r3, #31
  ep->num   = ep_addr & 0x7FU;
 80008e4:	700c      	strb	r4, [r1, #0]
  ep->is_in = (0x80U & ep_addr) != 0U;
 80008e6:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 80008e8:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 80008ec:	2b01      	cmp	r3, #1
 80008ee:	f000 80d4 	beq.w	8000a9a <HAL_PCD_EP_Close+0x1d6>
 80008f2:	2301      	movs	r3, #1
 80008f4:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 80008f8:	780a      	ldrb	r2, [r1, #0]

  if (ep->doublebuffer == 0U) 
 80008fa:	7a8d      	ldrb	r5, [r1, #10]
 80008fc:	784c      	ldrb	r4, [r1, #1]
 80008fe:	6803      	ldr	r3, [r0, #0]
  {
    if (ep->is_in)
    {
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8000900:	b212      	sxth	r2, r2
  if (ep->doublebuffer == 0U) 
 8000902:	2d00      	cmp	r5, #0
 8000904:	d13c      	bne.n	8000980 <HAL_PCD_EP_Close+0xbc>
    if (ep->is_in)
 8000906:	b31c      	cbz	r4, 8000950 <HAL_PCD_EP_Close+0x8c>
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8000908:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 800090c:	0664      	lsls	r4, r4, #25
 800090e:	d50b      	bpl.n	8000928 <HAL_PCD_EP_Close+0x64>
 8000910:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000914:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8000918:	0524      	lsls	r4, r4, #20
 800091a:	0d24      	lsrs	r4, r4, #20
 800091c:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 8000920:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 8000924:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS) 
 8000928:	7809      	ldrb	r1, [r1, #0]
 800092a:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 800092e:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8000932:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    }
    else
    {
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000936:	0412      	lsls	r2, r2, #16
 8000938:	0c12      	lsrs	r2, r2, #16
 800093a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800093e:	f042 0280 	orr.w	r2, r2, #128	; 0x80
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
      PCD_RX_DTOG(hpcd->Instance, ep->num);
      /* Configure DISABLE status for the Endpoint*/
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000942:	f823 2021 	strh.w	r2, [r3, r1, lsl #2]
    }
  } 
  
  __HAL_UNLOCK(hpcd);   
 8000946:	2300      	movs	r3, #0
 8000948:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  return HAL_OK;
 800094c:	4618      	mov	r0, r3
 800094e:	bd30      	pop	{r4, r5, pc}
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8000950:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000954:	0465      	lsls	r5, r4, #17
 8000956:	d50b      	bpl.n	8000970 <HAL_PCD_EP_Close+0xac>
 8000958:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 800095c:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8000960:	0524      	lsls	r4, r4, #20
 8000962:	0d24      	lsrs	r4, r4, #20
 8000964:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8000968:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 800096c:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000970:	7809      	ldrb	r1, [r1, #0]
 8000972:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8000976:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800097a:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 800097e:	e7da      	b.n	8000936 <HAL_PCD_EP_Close+0x72>
    if (ep->is_in==0U)
 8000980:	2c00      	cmp	r4, #0
 8000982:	d146      	bne.n	8000a12 <HAL_PCD_EP_Close+0x14e>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8000984:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000988:	0464      	lsls	r4, r4, #17
 800098a:	d50b      	bpl.n	80009a4 <HAL_PCD_EP_Close+0xe0>
 800098c:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000990:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8000994:	0524      	lsls	r4, r4, #20
 8000996:	0d24      	lsrs	r4, r4, #20
 8000998:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 800099c:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 80009a0:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80009a4:	780c      	ldrb	r4, [r1, #0]
 80009a6:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80009aa:	0655      	lsls	r5, r2, #25
 80009ac:	d50b      	bpl.n	80009c6 <HAL_PCD_EP_Close+0x102>
 80009ae:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80009b2:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80009b6:	0512      	lsls	r2, r2, #20
 80009b8:	0d12      	lsrs	r2, r2, #20
 80009ba:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80009be:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 80009c2:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_TX_DTOG(hpcd->Instance, ep->num);
 80009c6:	780c      	ldrb	r4, [r1, #0]
 80009c8:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 80009cc:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 80009d0:	0512      	lsls	r2, r2, #20
 80009d2:	0d12      	lsrs	r2, r2, #20
 80009d4:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 80009d8:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 80009dc:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 80009e0:	780d      	ldrb	r5, [r1, #0]
 80009e2:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 80009e6:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 80009ea:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 80009ee:	0412      	lsls	r2, r2, #16
 80009f0:	0c12      	lsrs	r2, r2, #16
 80009f2:	f248 0480 	movw	r4, #32896	; 0x8080
 80009f6:	4322      	orrs	r2, r4
 80009f8:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 80009fc:	7809      	ldrb	r1, [r1, #0]
 80009fe:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8000a02:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8000a06:	f022 0240 	bic.w	r2, r2, #64	; 0x40
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000a0a:	0412      	lsls	r2, r2, #16
 8000a0c:	0c12      	lsrs	r2, r2, #16
 8000a0e:	4322      	orrs	r2, r4
 8000a10:	e797      	b.n	8000942 <HAL_PCD_EP_Close+0x7e>
      PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 8000a12:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000a16:	0464      	lsls	r4, r4, #17
 8000a18:	d50b      	bpl.n	8000a32 <HAL_PCD_EP_Close+0x16e>
 8000a1a:	f833 4022 	ldrh.w	r4, [r3, r2, lsl #2]
 8000a1e:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 8000a22:	0524      	lsls	r4, r4, #20
 8000a24:	0d24      	lsrs	r4, r4, #20
 8000a26:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8000a2a:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 8000a2e:	f823 4022 	strh.w	r4, [r3, r2, lsl #2]
      PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 8000a32:	780c      	ldrb	r4, [r1, #0]
 8000a34:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000a38:	0652      	lsls	r2, r2, #25
 8000a3a:	d50b      	bpl.n	8000a54 <HAL_PCD_EP_Close+0x190>
 8000a3c:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000a40:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000a44:	0512      	lsls	r2, r2, #20
 8000a46:	0d12      	lsrs	r2, r2, #20
 8000a48:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000a4c:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
 8000a50:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_RX_DTOG(hpcd->Instance, ep->num);
 8000a54:	780c      	ldrb	r4, [r1, #0]
 8000a56:	f833 2024 	ldrh.w	r2, [r3, r4, lsl #2]
 8000a5a:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
 8000a5e:	0512      	lsls	r2, r2, #20
 8000a60:	0d12      	lsrs	r2, r2, #20
 8000a62:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 8000a66:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000a6a:	f823 2024 	strh.w	r2, [r3, r4, lsl #2]
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_DIS)
 8000a6e:	780d      	ldrb	r5, [r1, #0]
 8000a70:	f833 2025 	ldrh.w	r2, [r3, r5, lsl #2]
 8000a74:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
 8000a78:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8000a7c:	0412      	lsls	r2, r2, #16
 8000a7e:	0c12      	lsrs	r2, r2, #16
 8000a80:	f248 0480 	movw	r4, #32896	; 0x8080
 8000a84:	4322      	orrs	r2, r4
 8000a86:	f823 2025 	strh.w	r2, [r3, r5, lsl #2]
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_DIS)
 8000a8a:	7809      	ldrb	r1, [r1, #0]
 8000a8c:	f833 2021 	ldrh.w	r2, [r3, r1, lsl #2]
 8000a90:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8000a94:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8000a98:	e7b7      	b.n	8000a0a <HAL_PCD_EP_Close+0x146>
  __HAL_LOCK(hpcd); 
 8000a9a:	2002      	movs	r0, #2
}
 8000a9c:	bd30      	pop	{r4, r5, pc}
	...

08000aa0 <HAL_PCD_EP_Receive>:
  * @param  pBuf pointer to the reception buffer   
  * @param  len amount of data to be received
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Receive(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000aa0:	b570      	push	{r4, r5, r6, lr}
 8000aa2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
 PCD_EPTypeDef *ep;
  
  ep = &hpcd->OUT_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000aa6:	241c      	movs	r4, #28
 8000aa8:	fb04 0501 	mla	r5, r4, r1, r0
  ep->xfer_len = len;
  ep->xfer_count = 0U;
 8000aac:	2600      	movs	r6, #0
  ep->xfer_buff = pBuf;  
 8000aae:	f8c5 21dc 	str.w	r2, [r5, #476]	; 0x1dc
  ep->is_in = 0U;
  ep->num = ep_addr & 0x7FU;

  /* Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 8000ab2:	f8d5 21d8 	ldr.w	r2, [r5, #472]	; 0x1d8
  ep->xfer_len = len;
 8000ab6:	f8c5 31e0 	str.w	r3, [r5, #480]	; 0x1e0
  if (ep->xfer_len > ep->maxpacket)
 8000aba:	4293      	cmp	r3, r2
  {
    len=ep->maxpacket;
    ep->xfer_len-=len; 
 8000abc:	bf86      	itte	hi
 8000abe:	1a9b      	subhi	r3, r3, r2
 8000ac0:	f8c5 31e0 	strhi.w	r3, [r5, #480]	; 0x1e0
  }
  else
  {
    len=ep->xfer_len;
    ep->xfer_len =0U;
 8000ac4:	461a      	movls	r2, r3
  }
  
  /* configure and validate Rx endpoint */
  if (ep->doublebuffer == 0U) 
 8000ac6:	fb04 0301 	mla	r3, r4, r1, r0
  ep->xfer_count = 0U;
 8000aca:	f8c5 61e4 	str.w	r6, [r5, #484]	; 0x1e4
  ep->is_in = 0U;
 8000ace:	f885 61cd 	strb.w	r6, [r5, #461]	; 0x1cd
  ep->num = ep_addr & 0x7FU;
 8000ad2:	f885 11cc 	strb.w	r1, [r5, #460]	; 0x1cc
    ep->xfer_len =0U;
 8000ad6:	bf98      	it	ls
 8000ad8:	f8c5 61e0 	strls.w	r6, [r5, #480]	; 0x1e0
  if (ep->doublebuffer == 0U) 
 8000adc:	f893 51d6 	ldrb.w	r5, [r3, #470]	; 0x1d6
 8000ae0:	6804      	ldr	r4, [r0, #0]
 8000ae2:	bb6d      	cbnz	r5, 8000b40 <HAL_PCD_EP_Receive+0xa0>
    PCD_SET_EP_RX_CNT(hpcd->Instance, ep->num, len)
  }
  else
  {
    /*Set the Double buffer counter*/
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len)
 8000ae4:	f8b4 5050 	ldrh.w	r5, [r4, #80]	; 0x50
 8000ae8:	f893 31cc 	ldrb.w	r3, [r3, #460]	; 0x1cc
 8000aec:	b2ad      	uxth	r5, r5
 8000aee:	2a3e      	cmp	r2, #62	; 0x3e
 8000af0:	eb05 05c3 	add.w	r5, r5, r3, lsl #3
 8000af4:	f204 4606 	addw	r6, r4, #1030	; 0x406
 8000af8:	d933      	bls.n	8000b62 <HAL_PCD_EP_Receive+0xc2>
 8000afa:	f3c2 134f 	ubfx	r3, r2, #5, #16
 8000afe:	06d2      	lsls	r2, r2, #27
 8000b00:	bf08      	it	eq
 8000b02:	f103 33ff 	addeq.w	r3, r3, #4294967295
 8000b06:	4a1b      	ldr	r2, [pc, #108]	; (8000b74 <HAL_PCD_EP_Receive+0xd4>)
 8000b08:	bf08      	it	eq
 8000b0a:	b29b      	uxtheq	r3, r3
 8000b0c:	ea42 2383 	orr.w	r3, r2, r3, lsl #10
 8000b10:	53ab      	strh	r3, [r5, r6]
  } 
  
  PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8000b12:	231c      	movs	r3, #28
 8000b14:	fb03 0001 	mla	r0, r3, r1, r0
 8000b18:	f890 21cc 	ldrb.w	r2, [r0, #460]	; 0x1cc
 8000b1c:	f834 3022 	ldrh.w	r3, [r4, r2, lsl #2]
 8000b20:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8000b24:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000b28:	041b      	lsls	r3, r3, #16
 8000b2a:	0c1b      	lsrs	r3, r3, #16
 8000b2c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8000b30:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000b34:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000b38:	f824 3022 	strh.w	r3, [r4, r2, lsl #2]

  return HAL_OK;
}
 8000b3c:	2000      	movs	r0, #0
 8000b3e:	bd70      	pop	{r4, r5, r6, pc}
    PCD_SET_EP_DBUF1_CNT(hpcd->Instance, ep->num, ep->is_in, len)
 8000b40:	f893 51cd 	ldrb.w	r5, [r3, #461]	; 0x1cd
 8000b44:	2d00      	cmp	r5, #0
 8000b46:	d0cd      	beq.n	8000ae4 <HAL_PCD_EP_Receive+0x44>
 8000b48:	2d01      	cmp	r5, #1
 8000b4a:	d1e2      	bne.n	8000b12 <HAL_PCD_EP_Receive+0x72>
 8000b4c:	f8b4 5050 	ldrh.w	r5, [r4, #80]	; 0x50
 8000b50:	f893 31cc 	ldrb.w	r3, [r3, #460]	; 0x1cc
 8000b54:	b2ad      	uxth	r5, r5
 8000b56:	eb05 03c3 	add.w	r3, r5, r3, lsl #3
 8000b5a:	4423      	add	r3, r4
 8000b5c:	f8a3 2406 	strh.w	r2, [r3, #1030]	; 0x406
 8000b60:	e7d7      	b.n	8000b12 <HAL_PCD_EP_Receive+0x72>
 8000b62:	f3c2 034f 	ubfx	r3, r2, #1, #16
 8000b66:	07d2      	lsls	r2, r2, #31
 8000b68:	bf44      	itt	mi
 8000b6a:	3301      	addmi	r3, #1
 8000b6c:	b29b      	uxthmi	r3, r3
 8000b6e:	029b      	lsls	r3, r3, #10
 8000b70:	e7ce      	b.n	8000b10 <HAL_PCD_EP_Receive+0x70>
 8000b72:	bf00      	nop
 8000b74:	ffff8000 	.word	0xffff8000

08000b78 <HAL_PCD_EP_Transmit>:
  * @param  pBuf pointer to the transmission buffer   
  * @param  len amount of data to be sent
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_PCD_EP_Transmit(PCD_HandleTypeDef *hpcd, uint8_t ep_addr, uint8_t *pBuf, uint32_t len)
{
 8000b78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000b7a:	f001 077f 	and.w	r7, r1, #127	; 0x7f
  uint16_t pmabuffer = 0U;
    
  ep = &hpcd->IN_ep[ep_addr & 0x7F];
  
  /*setup and start the Xfer */
  ep->xfer_buff = pBuf;  
 8000b7e:	241c      	movs	r4, #28
 8000b80:	fb04 0107 	mla	r1, r4, r7, r0
{
 8000b84:	4605      	mov	r5, r0
  ep->xfer_count = 0U;
  ep->is_in = 1U;
  ep->num = ep_addr & 0x7FU;

  /*Multi packet transfer*/
  if (ep->xfer_len > ep->maxpacket)
 8000b86:	6b4e      	ldr	r6, [r1, #52]	; 0x34
  ep->xfer_len = len;
 8000b88:	63cb      	str	r3, [r1, #60]	; 0x3c
  if (ep->xfer_len > ep->maxpacket)
 8000b8a:	42b3      	cmp	r3, r6
  {
    len=ep->maxpacket;
    ep->xfer_len-=len; 
 8000b8c:	bf88      	it	hi
 8000b8e:	1b9b      	subhi	r3, r3, r6
  ep->xfer_buff = pBuf;  
 8000b90:	638a      	str	r2, [r1, #56]	; 0x38
  ep->is_in = 1U;
 8000b92:	f04f 0001 	mov.w	r0, #1
  ep->xfer_count = 0U;
 8000b96:	f04f 0200 	mov.w	r2, #0
    len=ep->xfer_len;
    ep->xfer_len =0U;
  }
  
  /* configure and validate Tx endpoint */
  if (ep->doublebuffer == 0U) 
 8000b9a:	fb04 5407 	mla	r4, r4, r7, r5
  ep->xfer_count = 0U;
 8000b9e:	640a      	str	r2, [r1, #64]	; 0x40
  ep->is_in = 1U;
 8000ba0:	f881 0029 	strb.w	r0, [r1, #41]	; 0x29
  ep->num = ep_addr & 0x7FU;
 8000ba4:	f881 7028 	strb.w	r7, [r1, #40]	; 0x28
    ep->xfer_len-=len; 
 8000ba8:	bf8e      	itee	hi
 8000baa:	63cb      	strhi	r3, [r1, #60]	; 0x3c
    ep->xfer_len =0U;
 8000bac:	63ca      	strls	r2, [r1, #60]	; 0x3c
 8000bae:	461e      	movls	r6, r3
  if (ep->doublebuffer == 0U) 
 8000bb0:	f894 3032 	ldrb.w	r3, [r4, #50]	; 0x32
 8000bb4:	b2b6      	uxth	r6, r6
 8000bb6:	bb43      	cbnz	r3, 8000c0a <HAL_PCD_EP_Transmit+0x92>
  {
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, len);
 8000bb8:	4633      	mov	r3, r6
 8000bba:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
 8000bbc:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000bbe:	6828      	ldr	r0, [r5, #0]
 8000bc0:	f000 fb66 	bl	8001290 <PCD_WritePMA>
    PCD_SET_EP_TX_CNT(hpcd->Instance, ep->num, len);
 8000bc4:	682a      	ldr	r2, [r5, #0]
 8000bc6:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8000bca:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8000bce:	b29b      	uxth	r3, r3
 8000bd0:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8000bd4:	4413      	add	r3, r2
 8000bd6:	f8a3 6402 	strh.w	r6, [r3, #1026]	; 0x402
    }
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in)
  }

  PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID)
 8000bda:	231c      	movs	r3, #28
 8000bdc:	fb03 5707 	mla	r7, r3, r7, r5
 8000be0:	682a      	ldr	r2, [r5, #0]
 8000be2:	f897 1028 	ldrb.w	r1, [r7, #40]	; 0x28
 8000be6:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8000bea:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8000bee:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8000bf2:	041b      	lsls	r3, r3, #16
 8000bf4:	0c1b      	lsrs	r3, r3, #16
 8000bf6:	f083 0330 	eor.w	r3, r3, #48	; 0x30
 8000bfa:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000bfe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c02:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]

  return HAL_OK;
}
 8000c06:	2000      	movs	r0, #0
 8000c08:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 8000c0a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
 8000c0e:	6828      	ldr	r0, [r5, #0]
 8000c10:	f830 3023 	ldrh.w	r3, [r0, r3, lsl #2]
 8000c14:	065b      	lsls	r3, r3, #25
      pmabuffer = ep->pmaaddr1;
 8000c16:	bf4c      	ite	mi
 8000c18:	8e22      	ldrhmi	r2, [r4, #48]	; 0x30
      pmabuffer = ep->pmaaddr0;
 8000c1a:	8de2      	ldrhpl	r2, [r4, #46]	; 0x2e
    PCD_WritePMA(hpcd->Instance, ep->xfer_buff, pmabuffer, len);
 8000c1c:	241c      	movs	r4, #28
 8000c1e:	fb04 5407 	mla	r4, r4, r7, r5
 8000c22:	4633      	mov	r3, r6
 8000c24:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8000c26:	f000 fb33 	bl	8001290 <PCD_WritePMA>
    PCD_FreeUserBuffer(hpcd->Instance, ep->num, ep->is_in)
 8000c2a:	f894 3029 	ldrb.w	r3, [r4, #41]	; 0x29
 8000c2e:	682a      	ldr	r2, [r5, #0]
 8000c30:	b973      	cbnz	r3, 8000c50 <HAL_PCD_EP_Transmit+0xd8>
 8000c32:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8000c36:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8000c3a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000c3e:	051b      	lsls	r3, r3, #20
 8000c40:	0d1b      	lsrs	r3, r3, #20
 8000c42:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000c46:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000c4a:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 8000c4e:	e7c4      	b.n	8000bda <HAL_PCD_EP_Transmit+0x62>
 8000c50:	2b01      	cmp	r3, #1
 8000c52:	d1c2      	bne.n	8000bda <HAL_PCD_EP_Transmit+0x62>
 8000c54:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
 8000c58:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8000c5c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000c60:	051b      	lsls	r3, r3, #20
 8000c62:	0d1b      	lsrs	r3, r3, #20
 8000c64:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 8000c68:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000c6c:	e7ed      	b.n	8000c4a <HAL_PCD_EP_Transmit+0xd2>
	...

08000c70 <HAL_PCD_IRQHandler>:
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 8000c70:	6803      	ldr	r3, [r0, #0]
 8000c72:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8000c76:	041b      	lsls	r3, r3, #16
{
 8000c78:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 8000c7c:	4604      	mov	r4, r0
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_CTR))
 8000c7e:	d472      	bmi.n	8000d66 <HAL_PCD_IRQHandler+0xf6>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_RESET))
 8000c80:	6823      	ldr	r3, [r4, #0]
 8000c82:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000c86:	0557      	lsls	r7, r2, #21
 8000c88:	d50a      	bpl.n	8000ca0 <HAL_PCD_IRQHandler+0x30>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8000c8a:	f64f 32ff 	movw	r2, #64511	; 0xfbff
    HAL_PCD_ResetCallback(hpcd);
 8000c8e:	4620      	mov	r0, r4
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_RESET);
 8000c90:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_ResetCallback(hpcd);
 8000c94:	f002 fd21 	bl	80036da <HAL_PCD_ResetCallback>
    HAL_PCD_SetAddress(hpcd, 0U);
 8000c98:	2100      	movs	r1, #0
 8000c9a:	4620      	mov	r0, r4
 8000c9c:	f7ff fc67 	bl	800056e <HAL_PCD_SetAddress>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_PMAOVR))
 8000ca0:	6823      	ldr	r3, [r4, #0]
 8000ca2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000ca6:	0452      	lsls	r2, r2, #17
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_PMAOVR);    
 8000ca8:	bf44      	itt	mi
 8000caa:	f64b 72ff 	movwmi	r2, #49151	; 0xbfff
 8000cae:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ERR))
 8000cb2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000cb6:	0497      	lsls	r7, r2, #18
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ERR); 
 8000cb8:	bf44      	itt	mi
 8000cba:	f64d 72ff 	movwmi	r2, #57343	; 0xdfff
 8000cbe:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP))
 8000cc2:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000cc6:	04d6      	lsls	r6, r2, #19
 8000cc8:	d517      	bpl.n	8000cfa <HAL_PCD_IRQHandler+0x8a>
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_LPMODE);
 8000cca:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8000cce:	f022 0204 	bic.w	r2, r2, #4
 8000cd2:	0412      	lsls	r2, r2, #16
 8000cd4:	0c12      	lsrs	r2, r2, #16
 8000cd6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    hpcd->Instance->CNTR &= (uint16_t) ~(USB_CNTR_FSUSP);
 8000cda:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8000cde:	f022 0208 	bic.w	r2, r2, #8
 8000ce2:	0412      	lsls	r2, r2, #16
 8000ce4:	0c12      	lsrs	r2, r2, #16
 8000ce6:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    HAL_PCD_ResumeCallback(hpcd);
 8000cea:	4620      	mov	r0, r4
 8000cec:	f002 fd12 	bl	8003714 <HAL_PCD_ResumeCallback>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_WKUP);     
 8000cf0:	6823      	ldr	r3, [r4, #0]
 8000cf2:	f64e 72ff 	movw	r2, #61439	; 0xefff
 8000cf6:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SUSP))
 8000cfa:	6823      	ldr	r3, [r4, #0]
 8000cfc:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000d00:	0515      	lsls	r5, r2, #20
 8000d02:	d518      	bpl.n	8000d36 <HAL_PCD_IRQHandler+0xc6>
    hpcd->Instance->CNTR |= USB_CNTR_FSUSP;
 8000d04:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8000d08:	b292      	uxth	r2, r2
 8000d0a:	f042 0208 	orr.w	r2, r2, #8
 8000d0e:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SUSP);
 8000d12:	f24f 72ff 	movw	r2, #63487	; 0xf7ff
 8000d16:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    hpcd->Instance->CNTR |= USB_CNTR_LPMODE;
 8000d1a:	f8b3 2040 	ldrh.w	r2, [r3, #64]	; 0x40
 8000d1e:	b292      	uxth	r2, r2
 8000d20:	f042 0204 	orr.w	r2, r2, #4
 8000d24:	f8a3 2040 	strh.w	r2, [r3, #64]	; 0x40
    if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_WKUP) == 0U)
 8000d28:	f8b3 3044 	ldrh.w	r3, [r3, #68]	; 0x44
 8000d2c:	04d8      	lsls	r0, r3, #19
 8000d2e:	d402      	bmi.n	8000d36 <HAL_PCD_IRQHandler+0xc6>
      HAL_PCD_SuspendCallback(hpcd);
 8000d30:	4620      	mov	r0, r4
 8000d32:	f002 fcdf 	bl	80036f4 <HAL_PCD_SuspendCallback>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_SOF))
 8000d36:	6823      	ldr	r3, [r4, #0]
 8000d38:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000d3c:	0591      	lsls	r1, r2, #22
 8000d3e:	d506      	bpl.n	8000d4e <HAL_PCD_IRQHandler+0xde>
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_SOF); 
 8000d40:	f64f 52ff 	movw	r2, #65023	; 0xfdff
 8000d44:	f8a3 2044 	strh.w	r2, [r3, #68]	; 0x44
    HAL_PCD_SOFCallback(hpcd);
 8000d48:	4620      	mov	r0, r4
 8000d4a:	f002 fcc2 	bl	80036d2 <HAL_PCD_SOFCallback>
  if (__HAL_PCD_GET_FLAG (hpcd, USB_ISTR_ESOF))
 8000d4e:	6823      	ldr	r3, [r4, #0]
 8000d50:	f8b3 2044 	ldrh.w	r2, [r3, #68]	; 0x44
 8000d54:	05d2      	lsls	r2, r2, #23
    __HAL_PCD_CLEAR_FLAG(hpcd, USB_ISTR_ESOF); 
 8000d56:	bf44      	itt	mi
 8000d58:	f64f 62ff 	movwmi	r2, #65279	; 0xfeff
 8000d5c:	f8a3 2044 	strhmi.w	r2, [r3, #68]	; 0x44
}
 8000d60:	b002      	add	sp, #8
 8000d62:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  __IO uint16_t wEPVal = 0U;
 8000d66:	2300      	movs	r3, #0
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8000d68:	4fc1      	ldr	r7, [pc, #772]	; (8001070 <HAL_PCD_IRQHandler+0x400>)
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID)
 8000d6a:	f8df 8308 	ldr.w	r8, [pc, #776]	; 8001074 <HAL_PCD_IRQHandler+0x404>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 8000d6e:	f8df 9308 	ldr.w	r9, [pc, #776]	; 8001078 <HAL_PCD_IRQHandler+0x408>
  __IO uint16_t wEPVal = 0U;
 8000d72:	f8ad 3006 	strh.w	r3, [sp, #6]
  while (((wIstr = hpcd->Instance->ISTR) & USB_ISTR_CTR) != 0U)
 8000d76:	6820      	ldr	r0, [r4, #0]
 8000d78:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 8000d7c:	b29b      	uxth	r3, r3
 8000d7e:	0419      	lsls	r1, r3, #16
 8000d80:	f8ad 3004 	strh.w	r3, [sp, #4]
 8000d84:	f57f af7c 	bpl.w	8000c80 <HAL_PCD_IRQHandler+0x10>
    EPindex = (uint8_t)(wIstr & USB_ISTR_EP_ID);
 8000d88:	f8bd 6004 	ldrh.w	r6, [sp, #4]
    if (EPindex == 0U)
 8000d8c:	f016 060f 	ands.w	r6, r6, #15
 8000d90:	f040 80a4 	bne.w	8000edc <HAL_PCD_IRQHandler+0x26c>
      if ((wIstr & USB_ISTR_DIR) == 0U)
 8000d94:	f8bd 1004 	ldrh.w	r1, [sp, #4]
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8000d98:	8803      	ldrh	r3, [r0, #0]
      if ((wIstr & USB_ISTR_DIR) == 0U)
 8000d9a:	f011 0110 	ands.w	r1, r1, #16
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8000d9e:	b29b      	uxth	r3, r3
      if ((wIstr & USB_ISTR_DIR) == 0U)
 8000da0:	d125      	bne.n	8000dee <HAL_PCD_IRQHandler+0x17e>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8000da2:	403b      	ands	r3, r7
 8000da4:	8003      	strh	r3, [r0, #0]
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000da6:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8000daa:	f894 2028 	ldrb.w	r2, [r4, #40]	; 0x28
 8000dae:	b29b      	uxth	r3, r3
 8000db0:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8000db4:	4418      	add	r0, r3
        ep->xfer_buff += ep->xfer_count;
 8000db6:	6ba2      	ldr	r2, [r4, #56]	; 0x38
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000db8:	f8b0 3402 	ldrh.w	r3, [r0, #1026]	; 0x402
 8000dbc:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000dc0:	6423      	str	r3, [r4, #64]	; 0x40
        ep->xfer_buff += ep->xfer_count;
 8000dc2:	4413      	add	r3, r2
 8000dc4:	63a3      	str	r3, [r4, #56]	; 0x38
        HAL_PCD_DataInStageCallback(hpcd, 0U);
 8000dc6:	4620      	mov	r0, r4
 8000dc8:	f002 fc7b 	bl	80036c2 <HAL_PCD_DataInStageCallback>
        if((hpcd->USB_Address > 0U)&& ( ep->xfer_len == 0U))
 8000dcc:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8000dd0:	2b00      	cmp	r3, #0
 8000dd2:	d0d0      	beq.n	8000d76 <HAL_PCD_IRQHandler+0x106>
 8000dd4:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000dd6:	2a00      	cmp	r2, #0
 8000dd8:	d1cd      	bne.n	8000d76 <HAL_PCD_IRQHandler+0x106>
          hpcd->Instance->DADDR = (hpcd->USB_Address | USB_DADDR_EF);
 8000dda:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 8000dde:	6821      	ldr	r1, [r4, #0]
 8000de0:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000de4:	f8a1 304c 	strh.w	r3, [r1, #76]	; 0x4c
          hpcd->USB_Address = 0U;
 8000de8:	f884 2024 	strb.w	r2, [r4, #36]	; 0x24
 8000dec:	e7c3      	b.n	8000d76 <HAL_PCD_IRQHandler+0x106>
        wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, PCD_ENDP0);
 8000dee:	f8ad 3006 	strh.w	r3, [sp, #6]
        if ((wEPVal & USB_EP_SETUP) != 0U)
 8000df2:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000df6:	051e      	lsls	r6, r3, #20
 8000df8:	d51e      	bpl.n	8000e38 <HAL_PCD_IRQHandler+0x1c8>
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8000dfa:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8000dfe:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
 8000e02:	b29b      	uxth	r3, r3
 8000e04:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8000e08:	4403      	add	r3, r0
          PCD_ReadPMA(hpcd->Instance, (uint8_t*)(void*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);
 8000e0a:	f8b4 21d0 	ldrh.w	r2, [r4, #464]	; 0x1d0
 8000e0e:	f8b3 3406 	ldrh.w	r3, [r3, #1030]	; 0x406
 8000e12:	f3c3 0309 	ubfx	r3, r3, #0, #10
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8000e16:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
          PCD_ReadPMA(hpcd->Instance, (uint8_t*)(void*)hpcd->Setup ,ep->pmaadress , ep->xfer_count);
 8000e1a:	f504 715d 	add.w	r1, r4, #884	; 0x374
 8000e1e:	f000 fa49 	bl	80012b4 <PCD_ReadPMA>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0); 
 8000e22:	6822      	ldr	r2, [r4, #0]
 8000e24:	8813      	ldrh	r3, [r2, #0]
 8000e26:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000e2a:	051b      	lsls	r3, r3, #20
 8000e2c:	0d1b      	lsrs	r3, r3, #20
 8000e2e:	8013      	strh	r3, [r2, #0]
          HAL_PCD_SetupStageCallback(hpcd);
 8000e30:	4620      	mov	r0, r4
 8000e32:	f002 fc37 	bl	80036a4 <HAL_PCD_SetupStageCallback>
 8000e36:	e79e      	b.n	8000d76 <HAL_PCD_IRQHandler+0x106>
        else if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8000e38:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000e3c:	041d      	lsls	r5, r3, #16
 8000e3e:	d59a      	bpl.n	8000d76 <HAL_PCD_IRQHandler+0x106>
          PCD_CLEAR_RX_EP_CTR(hpcd->Instance, PCD_ENDP0);
 8000e40:	8803      	ldrh	r3, [r0, #0]
 8000e42:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000e46:	051b      	lsls	r3, r3, #20
 8000e48:	0d1b      	lsrs	r3, r3, #20
 8000e4a:	8003      	strh	r3, [r0, #0]
          ep->xfer_count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8000e4c:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8000e50:	f894 21cc 	ldrb.w	r2, [r4, #460]	; 0x1cc
 8000e54:	b29b      	uxth	r3, r3
 8000e56:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8000e5a:	4403      	add	r3, r0
 8000e5c:	f8b3 3406 	ldrh.w	r3, [r3, #1030]	; 0x406
 8000e60:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000e64:	f8c4 31e4 	str.w	r3, [r4, #484]	; 0x1e4
          if (ep->xfer_count != 0U)
 8000e68:	b163      	cbz	r3, 8000e84 <HAL_PCD_IRQHandler+0x214>
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 8000e6a:	f8b4 21d0 	ldrh.w	r2, [r4, #464]	; 0x1d0
 8000e6e:	f8d4 11dc 	ldr.w	r1, [r4, #476]	; 0x1dc
 8000e72:	f000 fa1f 	bl	80012b4 <PCD_ReadPMA>
            ep->xfer_buff+=ep->xfer_count;
 8000e76:	f8d4 31dc 	ldr.w	r3, [r4, #476]	; 0x1dc
 8000e7a:	f8d4 21e4 	ldr.w	r2, [r4, #484]	; 0x1e4
 8000e7e:	4413      	add	r3, r2
 8000e80:	f8c4 31dc 	str.w	r3, [r4, #476]	; 0x1dc
           HAL_PCD_DataOutStageCallback(hpcd, 0U);
 8000e84:	2100      	movs	r1, #0
 8000e86:	4620      	mov	r0, r4
 8000e88:	f002 fc12 	bl	80036b0 <HAL_PCD_DataOutStageCallback>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 8000e8c:	6822      	ldr	r2, [r4, #0]
 8000e8e:	f8d4 11d8 	ldr.w	r1, [r4, #472]	; 0x1d8
 8000e92:	f8b2 0050 	ldrh.w	r0, [r2, #80]	; 0x50
 8000e96:	293e      	cmp	r1, #62	; 0x3e
 8000e98:	b280      	uxth	r0, r0
 8000e9a:	f202 4506 	addw	r5, r2, #1030	; 0x406
 8000e9e:	d915      	bls.n	8000ecc <HAL_PCD_IRQHandler+0x25c>
 8000ea0:	f3c1 134f 	ubfx	r3, r1, #5, #16
 8000ea4:	06c9      	lsls	r1, r1, #27
 8000ea6:	bf04      	itt	eq
 8000ea8:	f103 33ff 	addeq.w	r3, r3, #4294967295
 8000eac:	b29b      	uxtheq	r3, r3
 8000eae:	ea49 2383 	orr.w	r3, r9, r3, lsl #10
 8000eb2:	522b      	strh	r3, [r5, r0]
          PCD_SET_EP_RX_STATUS(hpcd->Instance, PCD_ENDP0, USB_EP_RX_VALID)
 8000eb4:	8813      	ldrh	r3, [r2, #0]
 8000eb6:	b29b      	uxth	r3, r3
 8000eb8:	ea03 0308 	and.w	r3, r3, r8
 8000ebc:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8000ec0:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8000ec4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000ec8:	8013      	strh	r3, [r2, #0]
 8000eca:	e754      	b.n	8000d76 <HAL_PCD_IRQHandler+0x106>
          PCD_SET_EP_RX_CNT(hpcd->Instance, PCD_ENDP0, ep->maxpacket)
 8000ecc:	f3c1 034f 	ubfx	r3, r1, #1, #16
 8000ed0:	07ce      	lsls	r6, r1, #31
 8000ed2:	bf44      	itt	mi
 8000ed4:	3301      	addmi	r3, #1
 8000ed6:	b29b      	uxthmi	r3, r3
 8000ed8:	029b      	lsls	r3, r3, #10
 8000eda:	e7ea      	b.n	8000eb2 <HAL_PCD_IRQHandler+0x242>
      wEPVal = PCD_GET_ENDPOINT(hpcd->Instance, EPindex);
 8000edc:	fa0f fa86 	sxth.w	sl, r6
 8000ee0:	f830 302a 	ldrh.w	r3, [r0, sl, lsl #2]
 8000ee4:	b29b      	uxth	r3, r3
 8000ee6:	f8ad 3006 	strh.w	r3, [sp, #6]
      if ((wEPVal & USB_EP_CTR_RX) != 0U)
 8000eea:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000eee:	041d      	lsls	r5, r3, #16
 8000ef0:	d53f      	bpl.n	8000f72 <HAL_PCD_IRQHandler+0x302>
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
 8000ef2:	f830 302a 	ldrh.w	r3, [r0, sl, lsl #2]
 8000ef6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8000efa:	051b      	lsls	r3, r3, #20
 8000efc:	0d1b      	lsrs	r3, r3, #20
        if (ep->doublebuffer == 0U)
 8000efe:	211c      	movs	r1, #28
        PCD_CLEAR_RX_EP_CTR(hpcd->Instance, EPindex);
 8000f00:	f820 302a 	strh.w	r3, [r0, sl, lsl #2]
        if (ep->doublebuffer == 0U)
 8000f04:	fb01 4106 	mla	r1, r1, r6, r4
 8000f08:	f891 31d6 	ldrb.w	r3, [r1, #470]	; 0x1d6
 8000f0c:	2b00      	cmp	r3, #0
 8000f0e:	d170      	bne.n	8000ff2 <HAL_PCD_IRQHandler+0x382>
          count = PCD_GET_EP_RX_CNT(hpcd->Instance, ep->num);
 8000f10:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8000f14:	f891 21cc 	ldrb.w	r2, [r1, #460]	; 0x1cc
 8000f18:	b29b      	uxth	r3, r3
 8000f1a:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8000f1e:	4403      	add	r3, r0
 8000f20:	f8b3 5406 	ldrh.w	r5, [r3, #1030]	; 0x406
 8000f24:	f3c5 0509 	ubfx	r5, r5, #0, #10
          if (count != 0U)
 8000f28:	b135      	cbz	r5, 8000f38 <HAL_PCD_IRQHandler+0x2c8>
            PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, count);
 8000f2a:	f8b1 21d0 	ldrh.w	r2, [r1, #464]	; 0x1d0
 8000f2e:	f8d1 11dc 	ldr.w	r1, [r1, #476]	; 0x1dc
 8000f32:	462b      	mov	r3, r5
 8000f34:	f000 f9be 	bl	80012b4 <PCD_ReadPMA>
        ep->xfer_count+=count;
 8000f38:	211c      	movs	r1, #28
 8000f3a:	fb01 4106 	mla	r1, r1, r6, r4
 8000f3e:	f8d1 31e4 	ldr.w	r3, [r1, #484]	; 0x1e4
        ep->xfer_buff+=count;
 8000f42:	f8d1 21dc 	ldr.w	r2, [r1, #476]	; 0x1dc
        ep->xfer_count+=count;
 8000f46:	442b      	add	r3, r5
 8000f48:	f8c1 31e4 	str.w	r3, [r1, #484]	; 0x1e4
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 8000f4c:	f8d1 31e0 	ldr.w	r3, [r1, #480]	; 0x1e0
        ep->xfer_buff+=count;
 8000f50:	442a      	add	r2, r5
 8000f52:	f8c1 21dc 	str.w	r2, [r1, #476]	; 0x1dc
        if ((ep->xfer_len == 0U) || (count < ep->maxpacket))
 8000f56:	b123      	cbz	r3, 8000f62 <HAL_PCD_IRQHandler+0x2f2>
 8000f58:	f8d1 01d8 	ldr.w	r0, [r1, #472]	; 0x1d8
 8000f5c:	4285      	cmp	r5, r0
 8000f5e:	f080 8081 	bcs.w	8001064 <HAL_PCD_IRQHandler+0x3f4>
          HAL_PCD_DataOutStageCallback(hpcd, ep->num);
 8000f62:	231c      	movs	r3, #28
 8000f64:	fb03 4306 	mla	r3, r3, r6, r4
 8000f68:	4620      	mov	r0, r4
 8000f6a:	f893 11cc 	ldrb.w	r1, [r3, #460]	; 0x1cc
 8000f6e:	f002 fb9f 	bl	80036b0 <HAL_PCD_DataOutStageCallback>
      if ((wEPVal & USB_EP_CTR_TX) != 0U)
 8000f72:	f8bd 3006 	ldrh.w	r3, [sp, #6]
 8000f76:	0618      	lsls	r0, r3, #24
 8000f78:	f57f aefd 	bpl.w	8000d76 <HAL_PCD_IRQHandler+0x106>
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8000f7c:	6820      	ldr	r0, [r4, #0]
 8000f7e:	f830 302a 	ldrh.w	r3, [r0, sl, lsl #2]
 8000f82:	b29b      	uxth	r3, r3
 8000f84:	403b      	ands	r3, r7
        if (ep->doublebuffer == 0U)
 8000f86:	211c      	movs	r1, #28
        PCD_CLEAR_TX_EP_CTR(hpcd->Instance, EPindex);
 8000f88:	f820 302a 	strh.w	r3, [r0, sl, lsl #2]
        if (ep->doublebuffer == 0U)
 8000f8c:	fb01 4106 	mla	r1, r1, r6, r4
 8000f90:	f891 3032 	ldrb.w	r3, [r1, #50]	; 0x32
 8000f94:	2b00      	cmp	r3, #0
 8000f96:	d171      	bne.n	800107c <HAL_PCD_IRQHandler+0x40c>
          ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000f98:	f8b0 3050 	ldrh.w	r3, [r0, #80]	; 0x50
 8000f9c:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
 8000fa0:	b29b      	uxth	r3, r3
 8000fa2:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 8000fa6:	4403      	add	r3, r0
 8000fa8:	f8b3 3402 	ldrh.w	r3, [r3, #1026]	; 0x402
 8000fac:	f3c3 0309 	ubfx	r3, r3, #0, #10
 8000fb0:	640b      	str	r3, [r1, #64]	; 0x40
          if (ep->xfer_count != 0U)
 8000fb2:	b11b      	cbz	r3, 8000fbc <HAL_PCD_IRQHandler+0x34c>
            PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaadress, ep->xfer_count);
 8000fb4:	8d8a      	ldrh	r2, [r1, #44]	; 0x2c
 8000fb6:	6b89      	ldr	r1, [r1, #56]	; 0x38
 8000fb8:	f000 f96a 	bl	8001290 <PCD_WritePMA>
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000fbc:	6822      	ldr	r2, [r4, #0]
 8000fbe:	211c      	movs	r1, #28
 8000fc0:	fb01 4606 	mla	r6, r1, r6, r4
 8000fc4:	f8b2 3050 	ldrh.w	r3, [r2, #80]	; 0x50
 8000fc8:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
 8000fcc:	b29b      	uxth	r3, r3
 8000fce:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
 8000fd2:	4413      	add	r3, r2
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8000fd4:	4620      	mov	r0, r4
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000fd6:	f8b3 2402 	ldrh.w	r2, [r3, #1026]	; 0x402
        ep->xfer_buff+=ep->xfer_count;
 8000fda:	6bb3      	ldr	r3, [r6, #56]	; 0x38
        ep->xfer_count = PCD_GET_EP_TX_CNT(hpcd->Instance, ep->num);
 8000fdc:	f3c2 0209 	ubfx	r2, r2, #0, #10
 8000fe0:	6432      	str	r2, [r6, #64]	; 0x40
        ep->xfer_buff+=ep->xfer_count;
 8000fe2:	441a      	add	r2, r3
        if (ep->xfer_len == 0U)
 8000fe4:	6bf3      	ldr	r3, [r6, #60]	; 0x3c
        ep->xfer_buff+=ep->xfer_count;
 8000fe6:	63b2      	str	r2, [r6, #56]	; 0x38
        if (ep->xfer_len == 0U)
 8000fe8:	2b00      	cmp	r3, #0
 8000fea:	d17d      	bne.n	80010e8 <HAL_PCD_IRQHandler+0x478>
          HAL_PCD_DataInStageCallback(hpcd, ep->num);
 8000fec:	f002 fb69 	bl	80036c2 <HAL_PCD_DataInStageCallback>
 8000ff0:	e6c1      	b.n	8000d76 <HAL_PCD_IRQHandler+0x106>
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 8000ff2:	f891 51cc 	ldrb.w	r5, [r1, #460]	; 0x1cc
 8000ff6:	b22b      	sxth	r3, r5
 8000ff8:	f830 3023 	ldrh.w	r3, [r0, r3, lsl #2]
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8000ffc:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 8001000:	f413 4f80 	tst.w	r3, #16384	; 0x4000
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001004:	b292      	uxth	r2, r2
 8001006:	f04f 0308 	mov.w	r3, #8
 800100a:	fb13 2305 	smlabb	r3, r3, r5, r2
 800100e:	4403      	add	r3, r0
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_RX) == USB_EP_DTOG_RX)
 8001010:	d01e      	beq.n	8001050 <HAL_PCD_IRQHandler+0x3e0>
            count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001012:	f8b3 5402 	ldrh.w	r5, [r3, #1026]	; 0x402
 8001016:	f3c5 0509 	ubfx	r5, r5, #0, #10
            if (count != 0U)
 800101a:	b135      	cbz	r5, 800102a <HAL_PCD_IRQHandler+0x3ba>
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, count);
 800101c:	f8b1 21d2 	ldrh.w	r2, [r1, #466]	; 0x1d2
 8001020:	462b      	mov	r3, r5
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 8001022:	f8d1 11dc 	ldr.w	r1, [r1, #476]	; 0x1dc
 8001026:	f000 f945 	bl	80012b4 <PCD_ReadPMA>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_OUT)  
 800102a:	231c      	movs	r3, #28
 800102c:	fb03 4306 	mla	r3, r3, r6, r4
 8001030:	6822      	ldr	r2, [r4, #0]
 8001032:	f893 11cc 	ldrb.w	r1, [r3, #460]	; 0x1cc
 8001036:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 800103a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800103e:	051b      	lsls	r3, r3, #20
 8001040:	0d1b      	lsrs	r3, r3, #20
 8001042:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001046:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 800104a:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 800104e:	e773      	b.n	8000f38 <HAL_PCD_IRQHandler+0x2c8>
            count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 8001050:	f8b3 5406 	ldrh.w	r5, [r3, #1030]	; 0x406
 8001054:	f3c5 0509 	ubfx	r5, r5, #0, #10
            if (count != 0U)
 8001058:	2d00      	cmp	r5, #0
 800105a:	d0e6      	beq.n	800102a <HAL_PCD_IRQHandler+0x3ba>
              PCD_ReadPMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, count);
 800105c:	462b      	mov	r3, r5
 800105e:	f8b1 21d4 	ldrh.w	r2, [r1, #468]	; 0x1d4
 8001062:	e7de      	b.n	8001022 <HAL_PCD_IRQHandler+0x3b2>
          HAL_PCD_EP_Receive(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 8001064:	f891 11cc 	ldrb.w	r1, [r1, #460]	; 0x1cc
 8001068:	4620      	mov	r0, r4
 800106a:	f7ff fd19 	bl	8000aa0 <HAL_PCD_EP_Receive>
 800106e:	e780      	b.n	8000f72 <HAL_PCD_IRQHandler+0x302>
 8001070:	ffff8f0f 	.word	0xffff8f0f
 8001074:	ffffbf8f 	.word	0xffffbf8f
 8001078:	ffff8000 	.word	0xffff8000
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 800107c:	f891 5028 	ldrb.w	r5, [r1, #40]	; 0x28
 8001080:	b22b      	sxth	r3, r5
 8001082:	f830 3023 	ldrh.w	r3, [r0, r3, lsl #2]
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 8001086:	f8b0 2050 	ldrh.w	r2, [r0, #80]	; 0x50
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 800108a:	f013 0f40 	tst.w	r3, #64	; 0x40
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 800108e:	b292      	uxth	r2, r2
 8001090:	f04f 0308 	mov.w	r3, #8
 8001094:	fb13 2305 	smlabb	r3, r3, r5, r2
 8001098:	4403      	add	r3, r0
          if ((PCD_GET_ENDPOINT(hpcd->Instance, ep->num)& USB_EP_DTOG_TX) == USB_EP_DTOG_TX)
 800109a:	d01c      	beq.n	80010d6 <HAL_PCD_IRQHandler+0x466>
 800109c:	f8b3 3402 	ldrh.w	r3, [r3, #1026]	; 0x402
 80010a0:	f3c3 0309 	ubfx	r3, r3, #0, #10
            ep->xfer_count = PCD_GET_EP_DBUF0_CNT(hpcd->Instance, ep->num);
 80010a4:	640b      	str	r3, [r1, #64]	; 0x40
            if (ep->xfer_count != 0U)
 80010a6:	b11b      	cbz	r3, 80010b0 <HAL_PCD_IRQHandler+0x440>
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr0, ep->xfer_count);
 80010a8:	8dca      	ldrh	r2, [r1, #46]	; 0x2e
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80010aa:	6b89      	ldr	r1, [r1, #56]	; 0x38
 80010ac:	f000 f8f0 	bl	8001290 <PCD_WritePMA>
          PCD_FreeUserBuffer(hpcd->Instance, ep->num, PCD_EP_DBUF_IN)  
 80010b0:	231c      	movs	r3, #28
 80010b2:	fb03 4306 	mla	r3, r3, r6, r4
 80010b6:	6822      	ldr	r2, [r4, #0]
 80010b8:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
 80010bc:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80010c0:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80010c4:	051b      	lsls	r3, r3, #20
 80010c6:	0d1b      	lsrs	r3, r3, #20
 80010c8:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 80010cc:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80010d0:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 80010d4:	e772      	b.n	8000fbc <HAL_PCD_IRQHandler+0x34c>
 80010d6:	f8b3 3406 	ldrh.w	r3, [r3, #1030]	; 0x406
 80010da:	f3c3 0309 	ubfx	r3, r3, #0, #10
            ep->xfer_count = PCD_GET_EP_DBUF1_CNT(hpcd->Instance, ep->num);
 80010de:	640b      	str	r3, [r1, #64]	; 0x40
            if (ep->xfer_count != 0U)
 80010e0:	2b00      	cmp	r3, #0
 80010e2:	d0e5      	beq.n	80010b0 <HAL_PCD_IRQHandler+0x440>
              PCD_WritePMA(hpcd->Instance, ep->xfer_buff, ep->pmaaddr1, ep->xfer_count);
 80010e4:	8e0a      	ldrh	r2, [r1, #48]	; 0x30
 80010e6:	e7e0      	b.n	80010aa <HAL_PCD_IRQHandler+0x43a>
          HAL_PCD_EP_Transmit(hpcd, ep->num, ep->xfer_buff, ep->xfer_len);
 80010e8:	f7ff fd46 	bl	8000b78 <HAL_PCD_EP_Transmit>
 80010ec:	e643      	b.n	8000d76 <HAL_PCD_IRQHandler+0x106>
 80010ee:	bf00      	nop

080010f0 <HAL_PCD_EP_SetStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_SetStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  PCD_EPTypeDef *ep;
   
  __HAL_LOCK(hpcd); 
 80010f0:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 80010f4:	2b01      	cmp	r3, #1
{
 80010f6:	b510      	push	{r4, lr}
  __HAL_LOCK(hpcd); 
 80010f8:	d049      	beq.n	800118e <HAL_PCD_EP_SetStall+0x9e>
   
  if ((0x80U & ep_addr) == 0x80U)
 80010fa:	b24c      	sxtb	r4, r1
  __HAL_LOCK(hpcd); 
 80010fc:	2301      	movs	r3, #1
 80010fe:	221c      	movs	r2, #28
 8001100:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  if ((0x80U & ep_addr) == 0x80U)
 8001104:	2c00      	cmp	r4, #0
 8001106:	f001 037f 	and.w	r3, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 800110a:	bfb5      	itete	lt
 800110c:	fb02 0203 	mlalt	r2, r2, r3, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001110:	fb02 0201 	mlage	r2, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 8001114:	3228      	addlt	r2, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 8001116:	f502 72e6 	addge.w	r2, r2, #460	; 0x1cc
  }
  
  ep->is_stall = 1U;
 800111a:	2101      	movs	r1, #1
 800111c:	7091      	strb	r1, [r2, #2]
  ep->num   = ep_addr & 0x7FU;
 800111e:	b2d9      	uxtb	r1, r3
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8001120:	0fe3      	lsrs	r3, r4, #31
  ep->num   = ep_addr & 0x7FU;
 8001122:	7011      	strb	r1, [r2, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 8001124:	7053      	strb	r3, [r2, #1]
 8001126:	6802      	ldr	r2, [r0, #0]
  
  if (ep->num == 0U)
 8001128:	b9a1      	cbnz	r1, 8001154 <HAL_PCD_EP_SetStall+0x64>
  {
    /* This macro sets STALL status for RX & TX*/ 
    PCD_SET_EP_TXRX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_STALL, USB_EP_TX_STALL) 
 800112a:	8813      	ldrh	r3, [r2, #0]
 800112c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001130:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001134:	041b      	lsls	r3, r3, #16
 8001136:	0c1b      	lsrs	r3, r3, #16
 8001138:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800113c:	f083 0310 	eor.w	r3, r3, #16
 8001140:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001144:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001148:	8013      	strh	r3, [r2, #0]
    else
    {
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
    }
  }
  __HAL_UNLOCK(hpcd); 
 800114a:	2300      	movs	r3, #0
 800114c:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
  
  return HAL_OK;
 8001150:	4618      	mov	r0, r3
 8001152:	bd10      	pop	{r4, pc}
 8001154:	b209      	sxth	r1, r1
    if (ep->is_in)
 8001156:	2c00      	cmp	r4, #0
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 8001158:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
    if (ep->is_in)
 800115c:	da0e      	bge.n	800117c <HAL_PCD_EP_SetStall+0x8c>
      PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num , USB_EP_TX_STALL) 
 800115e:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 8001162:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001166:	041b      	lsls	r3, r3, #16
 8001168:	0c1b      	lsrs	r3, r3, #16
 800116a:	f083 0310 	eor.w	r3, r3, #16
      PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num , USB_EP_RX_STALL)
 800116e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001172:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001176:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
 800117a:	e7e6      	b.n	800114a <HAL_PCD_EP_SetStall+0x5a>
 800117c:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001180:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001184:	041b      	lsls	r3, r3, #16
 8001186:	0c1b      	lsrs	r3, r3, #16
 8001188:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 800118c:	e7ef      	b.n	800116e <HAL_PCD_EP_SetStall+0x7e>
  __HAL_LOCK(hpcd); 
 800118e:	2002      	movs	r0, #2
}
 8001190:	bd10      	pop	{r4, pc}

08001192 <HAL_PCD_EP_ClrStall>:
  */
HAL_StatusTypeDef HAL_PCD_EP_ClrStall(PCD_HandleTypeDef *hpcd, uint8_t ep_addr)
{
  PCD_EPTypeDef *ep;
  
  if ((0x80U & ep_addr) == 0x80U)
 8001192:	b24b      	sxtb	r3, r1
 8001194:	2b00      	cmp	r3, #0
{
 8001196:	b510      	push	{r4, lr}
 8001198:	f04f 021c 	mov.w	r2, #28
 800119c:	f001 047f 	and.w	r4, r1, #127	; 0x7f
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80011a0:	bfb5      	itete	lt
 80011a2:	fb02 0104 	mlalt	r1, r2, r4, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 80011a6:	fb02 0101 	mlage	r1, r2, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7F];
 80011aa:	3128      	addlt	r1, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 80011ac:	f501 71e6 	addge.w	r1, r1, #460	; 0x1cc
  }
  
  ep->is_stall = 0U;
  ep->num   = ep_addr & 0x7FU;
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80011b0:	0fdb      	lsrs	r3, r3, #31
  ep->is_stall = 0U;
 80011b2:	2200      	movs	r2, #0
 80011b4:	708a      	strb	r2, [r1, #2]
  ep->num   = ep_addr & 0x7FU;
 80011b6:	700c      	strb	r4, [r1, #0]
  ep->is_in = ((ep_addr & 0x80U) == 0x80U);
 80011b8:	704b      	strb	r3, [r1, #1]
  
  __HAL_LOCK(hpcd); 
 80011ba:	f890 3370 	ldrb.w	r3, [r0, #880]	; 0x370
 80011be:	2b01      	cmp	r3, #1
 80011c0:	d049      	beq.n	8001256 <HAL_PCD_EP_ClrStall+0xc4>
 80011c2:	2301      	movs	r3, #1
 80011c4:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
 80011c8:	780b      	ldrb	r3, [r1, #0]
  
  if (ep->is_in)
 80011ca:	784c      	ldrb	r4, [r1, #1]
 80011cc:	6802      	ldr	r2, [r0, #0]
  {
    PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80011ce:	b21b      	sxth	r3, r3
  if (ep->is_in)
 80011d0:	b32c      	cbz	r4, 800121e <HAL_PCD_EP_ClrStall+0x8c>
    PCD_CLEAR_TX_DTOG(hpcd->Instance, ep->num)
 80011d2:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 80011d6:	0664      	lsls	r4, r4, #25
 80011d8:	d50b      	bpl.n	80011f2 <HAL_PCD_EP_ClrStall+0x60>
 80011da:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 80011de:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 80011e2:	0524      	lsls	r4, r4, #20
 80011e4:	0d24      	lsrs	r4, r4, #20
 80011e6:	f444 4400 	orr.w	r4, r4, #32768	; 0x8000
 80011ea:	f044 04c0 	orr.w	r4, r4, #192	; 0xc0
 80011ee:	f822 4023 	strh.w	r4, [r2, r3, lsl #2]
    PCD_SET_EP_TX_STATUS(hpcd->Instance, ep->num, USB_EP_TX_VALID)
 80011f2:	7809      	ldrb	r1, [r1, #0]
 80011f4:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 80011f8:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
 80011fc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001200:	041b      	lsls	r3, r3, #16
 8001202:	0c1b      	lsrs	r3, r3, #16
 8001204:	f083 0330 	eor.w	r3, r3, #48	; 0x30
  }
  else
  {
    PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
    PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 8001208:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800120c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001210:	f822 3021 	strh.w	r3, [r2, r1, lsl #2]
  }
  __HAL_UNLOCK(hpcd); 
 8001214:	2300      	movs	r3, #0
 8001216:	f880 3370 	strb.w	r3, [r0, #880]	; 0x370
    
  return HAL_OK;
 800121a:	4618      	mov	r0, r3
 800121c:	bd10      	pop	{r4, pc}
    PCD_CLEAR_RX_DTOG(hpcd->Instance, ep->num)
 800121e:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 8001222:	0464      	lsls	r4, r4, #17
 8001224:	d50b      	bpl.n	800123e <HAL_PCD_EP_ClrStall+0xac>
 8001226:	f832 4023 	ldrh.w	r4, [r2, r3, lsl #2]
 800122a:	f024 04f0 	bic.w	r4, r4, #240	; 0xf0
 800122e:	0524      	lsls	r4, r4, #20
 8001230:	0d24      	lsrs	r4, r4, #20
 8001232:	f444 4440 	orr.w	r4, r4, #49152	; 0xc000
 8001236:	f044 0480 	orr.w	r4, r4, #128	; 0x80
 800123a:	f822 4023 	strh.w	r4, [r2, r3, lsl #2]
    PCD_SET_EP_RX_STATUS(hpcd->Instance, ep->num, USB_EP_RX_VALID)
 800123e:	7809      	ldrb	r1, [r1, #0]
 8001240:	f832 3021 	ldrh.w	r3, [r2, r1, lsl #2]
 8001244:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
 8001248:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 800124c:	041b      	lsls	r3, r3, #16
 800124e:	0c1b      	lsrs	r3, r3, #16
 8001250:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
 8001254:	e7d8      	b.n	8001208 <HAL_PCD_EP_ClrStall+0x76>
  __HAL_LOCK(hpcd); 
 8001256:	2002      	movs	r0, #2
}
 8001258:	bd10      	pop	{r4, pc}

0800125a <HAL_PCDEx_PMAConfig>:

{
  PCD_EPTypeDef *ep;
  
  /* initialize ep structure*/
  if ((0x80U & ep_addr) == 0x80U)
 800125a:	f011 0f80 	tst.w	r1, #128	; 0x80
{
 800125e:	b510      	push	{r4, lr}
  {
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001260:	bf18      	it	ne
 8001262:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 8001266:	f04f 041c 	mov.w	r4, #28
 800126a:	bf15      	itete	ne
 800126c:	fb04 0001 	mlane	r0, r4, r1, r0
  }
  else
  {
    ep = &hpcd->OUT_ep[ep_addr];
 8001270:	fb04 0001 	mlaeq	r0, r4, r1, r0
    ep = &hpcd->IN_ep[ep_addr & 0x7FU];
 8001274:	3028      	addne	r0, #40	; 0x28
    ep = &hpcd->OUT_ep[ep_addr];
 8001276:	f500 70e6 	addeq.w	r0, r0, #460	; 0x1cc
  }
  
  /* Here we check if the endpoint is single or double Buffer*/
  if (ep_kind == PCD_SNG_BUF)
 800127a:	b91a      	cbnz	r2, 8001284 <HAL_PCDEx_PMAConfig+0x2a>
  {
    /*Single Buffer*/
    ep->doublebuffer = 0U;
 800127c:	7282      	strb	r2, [r0, #10]
    /*Configure the PMA*/
    ep->pmaadress = (uint16_t)pmaadress;
 800127e:	8083      	strh	r3, [r0, #4]
    ep->pmaaddr0 =  pmaadress & 0xFFFFU;
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
  }
  
  return HAL_OK; 
}
 8001280:	2000      	movs	r0, #0
 8001282:	bd10      	pop	{r4, pc}
    ep->doublebuffer = 1;
 8001284:	2201      	movs	r2, #1
    ep->pmaaddr0 =  pmaadress & 0xFFFFU;
 8001286:	80c3      	strh	r3, [r0, #6]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
 8001288:	0c1b      	lsrs	r3, r3, #16
    ep->doublebuffer = 1;
 800128a:	7282      	strb	r2, [r0, #10]
    ep->pmaaddr1 =  (pmaadress & 0xFFFF0000U) >> 16U;
 800128c:	8103      	strh	r3, [r0, #8]
 800128e:	e7f7      	b.n	8001280 <HAL_PCDEx_PMAConfig+0x26>

08001290 <PCD_WritePMA>:
  * @param   wPMABufAddr: address into PMA.
  * @param   wNBytes: no. of bytes to be copied.
  * @retval None
  */
void PCD_WritePMA(USB_TypeDef  *USBx, uint8_t *pbUsrBuf, uint16_t wPMABufAddr, uint16_t wNBytes)
{
 8001290:	b510      	push	{r4, lr}
  uint32_t n =  ((uint32_t)((uint32_t)wNBytes + 1U)) >> 1U;
  uint32_t i;
  uint16_t temp1, temp2;
  uint16_t *pdwVal;
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr + (uint32_t)USBx + 0x400U));  
 8001292:	f500 6080 	add.w	r0, r0, #1024	; 0x400
  uint32_t n =  ((uint32_t)((uint32_t)wNBytes + 1U)) >> 1U;
 8001296:	3301      	adds	r3, #1
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr + (uint32_t)USBx + 0x400U));  
 8001298:	4402      	add	r2, r0
 800129a:	f023 0301 	bic.w	r3, r3, #1
 800129e:	4610      	mov	r0, r2
 80012a0:	4413      	add	r3, r2
 80012a2:	1a84      	subs	r4, r0, r2
  for (i = n; i != 0U; i--)
 80012a4:	4298      	cmp	r0, r3
 80012a6:	440c      	add	r4, r1
 80012a8:	d100      	bne.n	80012ac <PCD_WritePMA+0x1c>
    pbUsrBuf++;
    temp2 = temp1 | ((uint16_t)((uint16_t)  * pbUsrBuf << 8U)) ;
    *pdwVal++ = temp2;
    pbUsrBuf++;
  }
}
 80012aa:	bd10      	pop	{r4, pc}
    temp2 = temp1 | ((uint16_t)((uint16_t)  * pbUsrBuf << 8U)) ;
 80012ac:	8824      	ldrh	r4, [r4, #0]
    *pdwVal++ = temp2;
 80012ae:	f820 4b02 	strh.w	r4, [r0], #2
 80012b2:	e7f6      	b.n	80012a2 <PCD_WritePMA+0x12>

080012b4 <PCD_ReadPMA>:
{
  uint32_t n = (uint32_t)wNBytes >> 1U;
  uint32_t i;
  uint16_t *pdwVal;
  uint32_t temp;
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr + (uint32_t)USBx + 0x400U));
 80012b4:	f500 6080 	add.w	r0, r0, #1024	; 0x400
{
 80012b8:	b5f0      	push	{r4, r5, r6, r7, lr}
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr + (uint32_t)USBx + 0x400U));
 80012ba:	4402      	add	r2, r0
  uint32_t n = (uint32_t)wNBytes >> 1U;
 80012bc:	085d      	lsrs	r5, r3, #1
 80012be:	4608      	mov	r0, r1
  pdwVal = (uint16_t *)((uint32_t)(wPMABufAddr + (uint32_t)USBx + 0x400U));
 80012c0:	4617      	mov	r7, r2

  for (i = n; i != 0U; i--)
 80012c2:	462e      	mov	r6, r5
 80012c4:	3002      	adds	r0, #2
 80012c6:	b936      	cbnz	r6, 80012d6 <PCD_ReadPMA+0x22>
    temp = *pdwVal++;
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
    *pbUsrBuf++ = ((temp >> 8) & 0xFF);
  }

  if (wNBytes % 2)
 80012c8:	07db      	lsls	r3, r3, #31
  {
    temp = *pdwVal++;
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
 80012ca:	bf44      	itt	mi
 80012cc:	f832 3015 	ldrhmi.w	r3, [r2, r5, lsl #1]
 80012d0:	f801 3015 	strbmi.w	r3, [r1, r5, lsl #1]
 80012d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
    temp = *pdwVal++;
 80012d6:	f837 4b02 	ldrh.w	r4, [r7], #2
    *pbUsrBuf++ = ((temp >> 0) & 0xFF);
 80012da:	f800 4c02 	strb.w	r4, [r0, #-2]
    *pbUsrBuf++ = ((temp >> 8) & 0xFF);
 80012de:	0a24      	lsrs	r4, r4, #8
 80012e0:	f800 4c01 	strb.w	r4, [r0, #-1]
  for (i = n; i != 0U; i--)
 80012e4:	3e01      	subs	r6, #1
 80012e6:	e7ed      	b.n	80012c4 <PCD_ReadPMA+0x10>

080012e8 <HAL_RCC_OscConfig>:
  *         supported by this macro. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 80012e8:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  uint32_t tickstart;

  /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 80012ec:	4605      	mov	r5, r0
 80012ee:	b918      	cbnz	r0, 80012f8 <HAL_RCC_OscConfig+0x10>
  {
    return HAL_ERROR;
 80012f0:	2001      	movs	r0, #1
      return HAL_ERROR;
    }
  }
  
  return HAL_OK;
}
 80012f2:	b002      	add	sp, #8
 80012f4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80012f8:	6803      	ldr	r3, [r0, #0]
 80012fa:	07df      	lsls	r7, r3, #31
 80012fc:	d411      	bmi.n	8001322 <HAL_RCC_OscConfig+0x3a>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80012fe:	682b      	ldr	r3, [r5, #0]
 8001300:	079e      	lsls	r6, r3, #30
 8001302:	f100 8088 	bmi.w	8001416 <HAL_RCC_OscConfig+0x12e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001306:	682b      	ldr	r3, [r5, #0]
 8001308:	071c      	lsls	r4, r3, #28
 800130a:	f100 80fc 	bmi.w	8001506 <HAL_RCC_OscConfig+0x21e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 800130e:	682b      	ldr	r3, [r5, #0]
 8001310:	0758      	lsls	r0, r3, #29
 8001312:	f100 8145 	bmi.w	80015a0 <HAL_RCC_OscConfig+0x2b8>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001316:	69aa      	ldr	r2, [r5, #24]
 8001318:	2a00      	cmp	r2, #0
 800131a:	f040 81dc 	bne.w	80016d6 <HAL_RCC_OscConfig+0x3ee>
  return HAL_OK;
 800131e:	2000      	movs	r0, #0
 8001320:	e7e7      	b.n	80012f2 <HAL_RCC_OscConfig+0xa>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSE) 
 8001322:	4cbd      	ldr	r4, [pc, #756]	; (8001618 <HAL_RCC_OscConfig+0x330>)
 8001324:	6863      	ldr	r3, [r4, #4]
 8001326:	f003 030c 	and.w	r3, r3, #12
 800132a:	2b04      	cmp	r3, #4
 800132c:	d00a      	beq.n	8001344 <HAL_RCC_OscConfig+0x5c>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 800132e:	6863      	ldr	r3, [r4, #4]
 8001330:	f003 030c 	and.w	r3, r3, #12
 8001334:	2b08      	cmp	r3, #8
 8001336:	d119      	bne.n	800136c <HAL_RCC_OscConfig+0x84>
 8001338:	6863      	ldr	r3, [r4, #4]
 800133a:	f403 33c0 	and.w	r3, r3, #98304	; 0x18000
 800133e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001342:	d113      	bne.n	800136c <HAL_RCC_OscConfig+0x84>
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8001344:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 8001348:	fa93 f2a3 	rbit	r2, r3
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 800134c:	6821      	ldr	r1, [r4, #0]
 800134e:	fa93 f3a3 	rbit	r3, r3
 8001352:	fab3 f383 	clz	r3, r3
 8001356:	f003 031f 	and.w	r3, r3, #31
 800135a:	2201      	movs	r2, #1
 800135c:	fa02 f303 	lsl.w	r3, r2, r3
 8001360:	420b      	tst	r3, r1
 8001362:	d0cc      	beq.n	80012fe <HAL_RCC_OscConfig+0x16>
 8001364:	686b      	ldr	r3, [r5, #4]
 8001366:	2b00      	cmp	r3, #0
 8001368:	d1c9      	bne.n	80012fe <HAL_RCC_OscConfig+0x16>
 800136a:	e7c1      	b.n	80012f0 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800136c:	686b      	ldr	r3, [r5, #4]
 800136e:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8001372:	d11e      	bne.n	80013b2 <HAL_RCC_OscConfig+0xca>
 8001374:	6823      	ldr	r3, [r4, #0]
 8001376:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800137a:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 800137c:	f7fe ff4e 	bl	800021c <HAL_GetTick>
 8001380:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 8001384:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 8001386:	2701      	movs	r7, #1
 8001388:	fa96 f3a6 	rbit	r3, r6
 800138c:	6822      	ldr	r2, [r4, #0]
 800138e:	fa96 f3a6 	rbit	r3, r6
 8001392:	fab3 f383 	clz	r3, r3
 8001396:	f003 031f 	and.w	r3, r3, #31
 800139a:	fa07 f303 	lsl.w	r3, r7, r3
 800139e:	4213      	tst	r3, r2
 80013a0:	d1ad      	bne.n	80012fe <HAL_RCC_OscConfig+0x16>
          if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80013a2:	f7fe ff3b 	bl	800021c <HAL_GetTick>
 80013a6:	eba0 0008 	sub.w	r0, r0, r8
 80013aa:	2864      	cmp	r0, #100	; 0x64
 80013ac:	d9ec      	bls.n	8001388 <HAL_RCC_OscConfig+0xa0>
            return HAL_TIMEOUT;
 80013ae:	2003      	movs	r0, #3
 80013b0:	e79f      	b.n	80012f2 <HAL_RCC_OscConfig+0xa>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013b2:	bb0b      	cbnz	r3, 80013f8 <HAL_RCC_OscConfig+0x110>
 80013b4:	6823      	ldr	r3, [r4, #0]
 80013b6:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80013ba:	6023      	str	r3, [r4, #0]
 80013bc:	6823      	ldr	r3, [r4, #0]
 80013be:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80013c2:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80013c4:	f7fe ff2a 	bl	800021c <HAL_GetTick>
 80013c8:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 80013cc:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != RESET)
 80013ce:	2701      	movs	r7, #1
 80013d0:	fa96 f3a6 	rbit	r3, r6
 80013d4:	6822      	ldr	r2, [r4, #0]
 80013d6:	fa96 f3a6 	rbit	r3, r6
 80013da:	fab3 f383 	clz	r3, r3
 80013de:	f003 031f 	and.w	r3, r3, #31
 80013e2:	fa07 f303 	lsl.w	r3, r7, r3
 80013e6:	4213      	tst	r3, r2
 80013e8:	d089      	beq.n	80012fe <HAL_RCC_OscConfig+0x16>
           if((HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80013ea:	f7fe ff17 	bl	800021c <HAL_GetTick>
 80013ee:	eba0 0008 	sub.w	r0, r0, r8
 80013f2:	2864      	cmp	r0, #100	; 0x64
 80013f4:	d9ec      	bls.n	80013d0 <HAL_RCC_OscConfig+0xe8>
 80013f6:	e7da      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80013f8:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 80013fc:	6823      	ldr	r3, [r4, #0]
 80013fe:	d103      	bne.n	8001408 <HAL_RCC_OscConfig+0x120>
 8001400:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8001404:	6023      	str	r3, [r4, #0]
 8001406:	e7b5      	b.n	8001374 <HAL_RCC_OscConfig+0x8c>
 8001408:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800140c:	6023      	str	r3, [r4, #0]
 800140e:	6823      	ldr	r3, [r4, #0]
 8001410:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001414:	e7b1      	b.n	800137a <HAL_RCC_OscConfig+0x92>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_HSI) 
 8001416:	4c80      	ldr	r4, [pc, #512]	; (8001618 <HAL_RCC_OscConfig+0x330>)
 8001418:	6863      	ldr	r3, [r4, #4]
 800141a:	f013 0f0c 	tst.w	r3, #12
 800141e:	d00a      	beq.n	8001436 <HAL_RCC_OscConfig+0x14e>
       || ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_SYSCLKSOURCE_STATUS_PLLCLK) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8001420:	6863      	ldr	r3, [r4, #4]
 8001422:	f003 030c 	and.w	r3, r3, #12
 8001426:	2b08      	cmp	r3, #8
 8001428:	d125      	bne.n	8001476 <HAL_RCC_OscConfig+0x18e>
 800142a:	6863      	ldr	r3, [r4, #4]
 800142c:	f403 33c0 	and.w	r3, r3, #98304	; 0x18000
 8001430:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8001434:	d11f      	bne.n	8001476 <HAL_RCC_OscConfig+0x18e>
 8001436:	2302      	movs	r3, #2
 8001438:	fa93 f2a3 	rbit	r2, r3
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState != RCC_HSI_ON))
 800143c:	6821      	ldr	r1, [r4, #0]
 800143e:	fa93 f3a3 	rbit	r3, r3
 8001442:	fab3 f383 	clz	r3, r3
 8001446:	f003 031f 	and.w	r3, r3, #31
 800144a:	2201      	movs	r2, #1
 800144c:	fa02 f303 	lsl.w	r3, r2, r3
 8001450:	420b      	tst	r3, r1
 8001452:	d003      	beq.n	800145c <HAL_RCC_OscConfig+0x174>
 8001454:	68eb      	ldr	r3, [r5, #12]
 8001456:	4293      	cmp	r3, r2
 8001458:	f47f af4a 	bne.w	80012f0 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 800145c:	6821      	ldr	r1, [r4, #0]
 800145e:	23f8      	movs	r3, #248	; 0xf8
 8001460:	fa93 f3a3 	rbit	r3, r3
 8001464:	fab3 f283 	clz	r2, r3
 8001468:	692b      	ldr	r3, [r5, #16]
 800146a:	4093      	lsls	r3, r2
 800146c:	f021 02f8 	bic.w	r2, r1, #248	; 0xf8
 8001470:	4313      	orrs	r3, r2
 8001472:	6023      	str	r3, [r4, #0]
 8001474:	e747      	b.n	8001306 <HAL_RCC_OscConfig+0x1e>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001476:	68ea      	ldr	r2, [r5, #12]
 8001478:	2601      	movs	r6, #1
 800147a:	b30a      	cbz	r2, 80014c0 <HAL_RCC_OscConfig+0x1d8>
 800147c:	fa96 f3a6 	rbit	r3, r6
        __HAL_RCC_HSI_ENABLE();
 8001480:	fab3 f383 	clz	r3, r3
 8001484:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8001488:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 800148c:	009b      	lsls	r3, r3, #2
 800148e:	2702      	movs	r7, #2
 8001490:	601e      	str	r6, [r3, #0]
        tickstart = HAL_GetTick();
 8001492:	f7fe fec3 	bl	800021c <HAL_GetTick>
 8001496:	4680      	mov	r8, r0
 8001498:	fa97 f3a7 	rbit	r3, r7
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800149c:	6822      	ldr	r2, [r4, #0]
 800149e:	fa97 f3a7 	rbit	r3, r7
 80014a2:	fab3 f383 	clz	r3, r3
 80014a6:	f003 031f 	and.w	r3, r3, #31
 80014aa:	fa06 f303 	lsl.w	r3, r6, r3
 80014ae:	4213      	tst	r3, r2
 80014b0:	d1d4      	bne.n	800145c <HAL_RCC_OscConfig+0x174>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80014b2:	f7fe feb3 	bl	800021c <HAL_GetTick>
 80014b6:	eba0 0008 	sub.w	r0, r0, r8
 80014ba:	2802      	cmp	r0, #2
 80014bc:	d9ec      	bls.n	8001498 <HAL_RCC_OscConfig+0x1b0>
 80014be:	e776      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
 80014c0:	fa96 f3a6 	rbit	r3, r6
        __HAL_RCC_HSI_DISABLE();
 80014c4:	fab3 f383 	clz	r3, r3
 80014c8:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 80014cc:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 80014d0:	009b      	lsls	r3, r3, #2
 80014d2:	2702      	movs	r7, #2
 80014d4:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80014d6:	f7fe fea1 	bl	800021c <HAL_GetTick>
 80014da:	4680      	mov	r8, r0
 80014dc:	fa97 f3a7 	rbit	r3, r7
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != RESET)
 80014e0:	6822      	ldr	r2, [r4, #0]
 80014e2:	fa97 f3a7 	rbit	r3, r7
 80014e6:	fab3 f383 	clz	r3, r3
 80014ea:	f003 031f 	and.w	r3, r3, #31
 80014ee:	fa06 f303 	lsl.w	r3, r6, r3
 80014f2:	4213      	tst	r3, r2
 80014f4:	f43f af07 	beq.w	8001306 <HAL_RCC_OscConfig+0x1e>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 80014f8:	f7fe fe90 	bl	800021c <HAL_GetTick>
 80014fc:	eba0 0008 	sub.w	r0, r0, r8
 8001500:	2802      	cmp	r0, #2
 8001502:	d9eb      	bls.n	80014dc <HAL_RCC_OscConfig+0x1f4>
 8001504:	e753      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001506:	696a      	ldr	r2, [r5, #20]
 8001508:	4e43      	ldr	r6, [pc, #268]	; (8001618 <HAL_RCC_OscConfig+0x330>)
 800150a:	4944      	ldr	r1, [pc, #272]	; (800161c <HAL_RCC_OscConfig+0x334>)
 800150c:	2401      	movs	r4, #1
 800150e:	b31a      	cbz	r2, 8001558 <HAL_RCC_OscConfig+0x270>
 8001510:	fa94 f3a4 	rbit	r3, r4
      __HAL_RCC_LSI_ENABLE();
 8001514:	fab3 f383 	clz	r3, r3
 8001518:	440b      	add	r3, r1
 800151a:	009b      	lsls	r3, r3, #2
 800151c:	2702      	movs	r7, #2
 800151e:	601c      	str	r4, [r3, #0]
      tickstart = HAL_GetTick();
 8001520:	f7fe fe7c 	bl	800021c <HAL_GetTick>
 8001524:	4680      	mov	r8, r0
 8001526:	fa97 f3a7 	rbit	r3, r7
 800152a:	fa97 f3a7 	rbit	r3, r7
 800152e:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == RESET)
 8001532:	6a72      	ldr	r2, [r6, #36]	; 0x24
 8001534:	fa97 f3a7 	rbit	r3, r7
 8001538:	fab3 f383 	clz	r3, r3
 800153c:	f003 031f 	and.w	r3, r3, #31
 8001540:	fa04 f303 	lsl.w	r3, r4, r3
 8001544:	4213      	tst	r3, r2
 8001546:	f47f aee2 	bne.w	800130e <HAL_RCC_OscConfig+0x26>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 800154a:	f7fe fe67 	bl	800021c <HAL_GetTick>
 800154e:	eba0 0008 	sub.w	r0, r0, r8
 8001552:	2802      	cmp	r0, #2
 8001554:	d9e7      	bls.n	8001526 <HAL_RCC_OscConfig+0x23e>
 8001556:	e72a      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
 8001558:	fa94 f3a4 	rbit	r3, r4
      __HAL_RCC_LSI_DISABLE();
 800155c:	fab3 f383 	clz	r3, r3
 8001560:	440b      	add	r3, r1
 8001562:	009b      	lsls	r3, r3, #2
 8001564:	2702      	movs	r7, #2
 8001566:	601a      	str	r2, [r3, #0]
      tickstart = HAL_GetTick();
 8001568:	f7fe fe58 	bl	800021c <HAL_GetTick>
 800156c:	4680      	mov	r8, r0
 800156e:	fa97 f3a7 	rbit	r3, r7
 8001572:	fa97 f3a7 	rbit	r3, r7
 8001576:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != RESET)
 800157a:	6a72      	ldr	r2, [r6, #36]	; 0x24
 800157c:	fa97 f3a7 	rbit	r3, r7
 8001580:	fab3 f383 	clz	r3, r3
 8001584:	f003 031f 	and.w	r3, r3, #31
 8001588:	fa04 f303 	lsl.w	r3, r4, r3
 800158c:	4213      	tst	r3, r2
 800158e:	f43f aebe 	beq.w	800130e <HAL_RCC_OscConfig+0x26>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001592:	f7fe fe43 	bl	800021c <HAL_GetTick>
 8001596:	eba0 0008 	sub.w	r0, r0, r8
 800159a:	2802      	cmp	r0, #2
 800159c:	d9e7      	bls.n	800156e <HAL_RCC_OscConfig+0x286>
 800159e:	e706      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80015a0:	4c1d      	ldr	r4, [pc, #116]	; (8001618 <HAL_RCC_OscConfig+0x330>)
 80015a2:	69e3      	ldr	r3, [r4, #28]
 80015a4:	00d9      	lsls	r1, r3, #3
 80015a6:	d434      	bmi.n	8001612 <HAL_RCC_OscConfig+0x32a>
      __HAL_RCC_PWR_CLK_ENABLE();
 80015a8:	69e3      	ldr	r3, [r4, #28]
 80015aa:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80015ae:	61e3      	str	r3, [r4, #28]
 80015b0:	69e3      	ldr	r3, [r4, #28]
 80015b2:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80015b6:	9301      	str	r3, [sp, #4]
 80015b8:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 80015ba:	2601      	movs	r6, #1
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 80015bc:	4f18      	ldr	r7, [pc, #96]	; (8001620 <HAL_RCC_OscConfig+0x338>)
 80015be:	683b      	ldr	r3, [r7, #0]
 80015c0:	05da      	lsls	r2, r3, #23
 80015c2:	d52f      	bpl.n	8001624 <HAL_RCC_OscConfig+0x33c>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80015c4:	68ab      	ldr	r3, [r5, #8]
 80015c6:	2b01      	cmp	r3, #1
 80015c8:	d13d      	bne.n	8001646 <HAL_RCC_OscConfig+0x35e>
 80015ca:	6a23      	ldr	r3, [r4, #32]
 80015cc:	f043 0301 	orr.w	r3, r3, #1
 80015d0:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 80015d2:	f7fe fe23 	bl	800021c <HAL_GetTick>
 80015d6:	2702      	movs	r7, #2
 80015d8:	4682      	mov	sl, r0
 80015da:	46b9      	mov	r9, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80015dc:	f04f 0801 	mov.w	r8, #1
 80015e0:	fa97 f3a7 	rbit	r3, r7
 80015e4:	fa97 f3a7 	rbit	r3, r7
 80015e8:	2b00      	cmp	r3, #0
 80015ea:	d06c      	beq.n	80016c6 <HAL_RCC_OscConfig+0x3de>
 80015ec:	6a22      	ldr	r2, [r4, #32]
 80015ee:	fa99 f3a9 	rbit	r3, r9
 80015f2:	fab3 f383 	clz	r3, r3
 80015f6:	f003 031f 	and.w	r3, r3, #31
 80015fa:	fa08 f303 	lsl.w	r3, r8, r3
 80015fe:	4213      	tst	r3, r2
 8001600:	d058      	beq.n	80016b4 <HAL_RCC_OscConfig+0x3cc>
    if(pwrclkchanged == SET)
 8001602:	2e00      	cmp	r6, #0
 8001604:	f43f ae87 	beq.w	8001316 <HAL_RCC_OscConfig+0x2e>
      __HAL_RCC_PWR_CLK_DISABLE();
 8001608:	69e3      	ldr	r3, [r4, #28]
 800160a:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 800160e:	61e3      	str	r3, [r4, #28]
 8001610:	e681      	b.n	8001316 <HAL_RCC_OscConfig+0x2e>
    FlagStatus       pwrclkchanged = RESET;
 8001612:	2600      	movs	r6, #0
 8001614:	e7d2      	b.n	80015bc <HAL_RCC_OscConfig+0x2d4>
 8001616:	bf00      	nop
 8001618:	40021000 	.word	0x40021000
 800161c:	10908120 	.word	0x10908120
 8001620:	40007000 	.word	0x40007000
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001624:	683b      	ldr	r3, [r7, #0]
 8001626:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800162a:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 800162c:	f7fe fdf6 	bl	800021c <HAL_GetTick>
 8001630:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001632:	683b      	ldr	r3, [r7, #0]
 8001634:	05db      	lsls	r3, r3, #23
 8001636:	d4c5      	bmi.n	80015c4 <HAL_RCC_OscConfig+0x2dc>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001638:	f7fe fdf0 	bl	800021c <HAL_GetTick>
 800163c:	eba0 0008 	sub.w	r0, r0, r8
 8001640:	2864      	cmp	r0, #100	; 0x64
 8001642:	d9f6      	bls.n	8001632 <HAL_RCC_OscConfig+0x34a>
 8001644:	e6b3      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001646:	bb3b      	cbnz	r3, 8001698 <HAL_RCC_OscConfig+0x3b0>
 8001648:	6a23      	ldr	r3, [r4, #32]
 800164a:	f023 0301 	bic.w	r3, r3, #1
 800164e:	6223      	str	r3, [r4, #32]
 8001650:	6a23      	ldr	r3, [r4, #32]
 8001652:	f023 0304 	bic.w	r3, r3, #4
 8001656:	6223      	str	r3, [r4, #32]
      tickstart = HAL_GetTick();
 8001658:	f7fe fde0 	bl	800021c <HAL_GetTick>
 800165c:	2702      	movs	r7, #2
 800165e:	4682      	mov	sl, r0
 8001660:	46b9      	mov	r9, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 8001662:	f04f 0801 	mov.w	r8, #1
 8001666:	fa97 f3a7 	rbit	r3, r7
 800166a:	fa97 f3a7 	rbit	r3, r7
 800166e:	b373      	cbz	r3, 80016ce <HAL_RCC_OscConfig+0x3e6>
 8001670:	6a22      	ldr	r2, [r4, #32]
 8001672:	fa99 f3a9 	rbit	r3, r9
 8001676:	fab3 f383 	clz	r3, r3
 800167a:	f003 031f 	and.w	r3, r3, #31
 800167e:	fa08 f303 	lsl.w	r3, r8, r3
 8001682:	4213      	tst	r3, r2
 8001684:	d0bd      	beq.n	8001602 <HAL_RCC_OscConfig+0x31a>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001686:	f7fe fdc9 	bl	800021c <HAL_GetTick>
 800168a:	f241 3388 	movw	r3, #5000	; 0x1388
 800168e:	eba0 000a 	sub.w	r0, r0, sl
 8001692:	4298      	cmp	r0, r3
 8001694:	d9e7      	bls.n	8001666 <HAL_RCC_OscConfig+0x37e>
 8001696:	e68a      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001698:	2b05      	cmp	r3, #5
 800169a:	6a23      	ldr	r3, [r4, #32]
 800169c:	d103      	bne.n	80016a6 <HAL_RCC_OscConfig+0x3be>
 800169e:	f043 0304 	orr.w	r3, r3, #4
 80016a2:	6223      	str	r3, [r4, #32]
 80016a4:	e791      	b.n	80015ca <HAL_RCC_OscConfig+0x2e2>
 80016a6:	f023 0301 	bic.w	r3, r3, #1
 80016aa:	6223      	str	r3, [r4, #32]
 80016ac:	6a23      	ldr	r3, [r4, #32]
 80016ae:	f023 0304 	bic.w	r3, r3, #4
 80016b2:	e78d      	b.n	80015d0 <HAL_RCC_OscConfig+0x2e8>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80016b4:	f7fe fdb2 	bl	800021c <HAL_GetTick>
 80016b8:	f241 3388 	movw	r3, #5000	; 0x1388
 80016bc:	eba0 000a 	sub.w	r0, r0, sl
 80016c0:	4298      	cmp	r0, r3
 80016c2:	d98d      	bls.n	80015e0 <HAL_RCC_OscConfig+0x2f8>
 80016c4:	e673      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
 80016c6:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 80016ca:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80016cc:	e78f      	b.n	80015ee <HAL_RCC_OscConfig+0x306>
 80016ce:	fa97 f3a7 	rbit	r3, r7
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != RESET)
 80016d2:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80016d4:	e7cd      	b.n	8001672 <HAL_RCC_OscConfig+0x38a>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_SYSCLKSOURCE_STATUS_PLLCLK)
 80016d6:	4c44      	ldr	r4, [pc, #272]	; (80017e8 <HAL_RCC_OscConfig+0x500>)
 80016d8:	6863      	ldr	r3, [r4, #4]
 80016da:	f003 030c 	and.w	r3, r3, #12
 80016de:	2b08      	cmp	r3, #8
 80016e0:	f43f ae06 	beq.w	80012f0 <HAL_RCC_OscConfig+0x8>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 80016e4:	2a02      	cmp	r2, #2
 80016e6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80016ea:	d158      	bne.n	800179e <HAL_RCC_OscConfig+0x4b6>
 80016ec:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_DISABLE();
 80016f0:	fab3 f383 	clz	r3, r3
 80016f4:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 80016f8:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 80016fc:	009b      	lsls	r3, r3, #2
 80016fe:	2200      	movs	r2, #0
 8001700:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001702:	f7fe fd8b 	bl	800021c <HAL_GetTick>
 8001706:	f04f 7700 	mov.w	r7, #33554432	; 0x2000000
 800170a:	4680      	mov	r8, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 800170c:	2601      	movs	r6, #1
 800170e:	fa97 f3a7 	rbit	r3, r7
 8001712:	6822      	ldr	r2, [r4, #0]
 8001714:	fa97 f3a7 	rbit	r3, r7
 8001718:	fab3 f383 	clz	r3, r3
 800171c:	f003 031f 	and.w	r3, r3, #31
 8001720:	fa06 f303 	lsl.w	r3, r6, r3
 8001724:	4213      	tst	r3, r2
 8001726:	d133      	bne.n	8001790 <HAL_RCC_OscConfig+0x4a8>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001728:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800172a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800172c:	f023 030f 	bic.w	r3, r3, #15
 8001730:	4313      	orrs	r3, r2
 8001732:	62e3      	str	r3, [r4, #44]	; 0x2c
 8001734:	6862      	ldr	r2, [r4, #4]
 8001736:	6a2b      	ldr	r3, [r5, #32]
 8001738:	69e9      	ldr	r1, [r5, #28]
 800173a:	f422 1276 	bic.w	r2, r2, #4030464	; 0x3d8000
 800173e:	430b      	orrs	r3, r1
 8001740:	4313      	orrs	r3, r2
 8001742:	6063      	str	r3, [r4, #4]
 8001744:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 8001748:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_ENABLE();
 800174c:	fab3 f383 	clz	r3, r3
 8001750:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 8001754:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 8001758:	009b      	lsls	r3, r3, #2
 800175a:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 800175e:	601e      	str	r6, [r3, #0]
        tickstart = HAL_GetTick();
 8001760:	f7fe fd5c 	bl	800021c <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 8001764:	2601      	movs	r6, #1
        tickstart = HAL_GetTick();
 8001766:	4607      	mov	r7, r0
 8001768:	fa95 f3a5 	rbit	r3, r5
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  == RESET)
 800176c:	6822      	ldr	r2, [r4, #0]
 800176e:	fa95 f3a5 	rbit	r3, r5
 8001772:	fab3 f383 	clz	r3, r3
 8001776:	f003 031f 	and.w	r3, r3, #31
 800177a:	fa06 f303 	lsl.w	r3, r6, r3
 800177e:	4213      	tst	r3, r2
 8001780:	f47f adcd 	bne.w	800131e <HAL_RCC_OscConfig+0x36>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001784:	f7fe fd4a 	bl	800021c <HAL_GetTick>
 8001788:	1bc0      	subs	r0, r0, r7
 800178a:	2802      	cmp	r0, #2
 800178c:	d9ec      	bls.n	8001768 <HAL_RCC_OscConfig+0x480>
 800178e:	e60e      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001790:	f7fe fd44 	bl	800021c <HAL_GetTick>
 8001794:	eba0 0008 	sub.w	r0, r0, r8
 8001798:	2802      	cmp	r0, #2
 800179a:	d9b8      	bls.n	800170e <HAL_RCC_OscConfig+0x426>
 800179c:	e607      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
 800179e:	fa93 f3a3 	rbit	r3, r3
        __HAL_RCC_PLL_DISABLE();
 80017a2:	fab3 f383 	clz	r3, r3
 80017a6:	f103 5384 	add.w	r3, r3, #276824064	; 0x10800000
 80017aa:	f503 1384 	add.w	r3, r3, #1081344	; 0x108000
 80017ae:	009b      	lsls	r3, r3, #2
 80017b0:	2200      	movs	r2, #0
 80017b2:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80017b4:	f7fe fd32 	bl	800021c <HAL_GetTick>
 80017b8:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 80017bc:	4607      	mov	r7, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY)  != RESET)
 80017be:	2601      	movs	r6, #1
 80017c0:	fa95 f3a5 	rbit	r3, r5
 80017c4:	6822      	ldr	r2, [r4, #0]
 80017c6:	fa95 f3a5 	rbit	r3, r5
 80017ca:	fab3 f383 	clz	r3, r3
 80017ce:	f003 031f 	and.w	r3, r3, #31
 80017d2:	fa06 f303 	lsl.w	r3, r6, r3
 80017d6:	4213      	tst	r3, r2
 80017d8:	f43f ada1 	beq.w	800131e <HAL_RCC_OscConfig+0x36>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80017dc:	f7fe fd1e 	bl	800021c <HAL_GetTick>
 80017e0:	1bc0      	subs	r0, r0, r7
 80017e2:	2802      	cmp	r0, #2
 80017e4:	d9ec      	bls.n	80017c0 <HAL_RCC_OscConfig+0x4d8>
 80017e6:	e5e2      	b.n	80013ae <HAL_RCC_OscConfig+0xc6>
 80017e8:	40021000 	.word	0x40021000

080017ec <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t tmpreg = 0U, prediv = 0U, pllclk = 0U, pllmul = 0U;
  uint32_t sysclockfreq = 0U;
  
  tmpreg = RCC->CFGR;
 80017ec:	4911      	ldr	r1, [pc, #68]	; (8001834 <HAL_RCC_GetSysClockFreq+0x48>)
 80017ee:	684b      	ldr	r3, [r1, #4]
  
  /* Get SYSCLK source -------------------------------------------------------*/
  switch (tmpreg & RCC_CFGR_SWS)
 80017f0:	f003 020c 	and.w	r2, r3, #12
 80017f4:	2a08      	cmp	r2, #8
 80017f6:	d11a      	bne.n	800182e <HAL_RCC_GetSysClockFreq+0x42>
 80017f8:	f44f 1270 	mov.w	r2, #3932160	; 0x3c0000
 80017fc:	fa92 f2a2 	rbit	r2, r2
 8001800:	200f      	movs	r0, #15
      sysclockfreq = HSE_VALUE;
      break;
    }
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL used as system clock */
    {
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 8001802:	fab2 f282 	clz	r2, r2
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> POSITION_VAL(RCC_CFGR2_PREDIV)];
 8001806:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8001808:	fa90 f0a0 	rbit	r0, r0
 800180c:	fab0 f080 	clz	r0, r0
 8001810:	f001 010f 	and.w	r1, r1, #15
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 8001814:	f403 1370 	and.w	r3, r3, #3932160	; 0x3c0000
 8001818:	40d3      	lsrs	r3, r2
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> POSITION_VAL(RCC_CFGR2_PREDIV)];
 800181a:	40c1      	lsrs	r1, r0
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 800181c:	4a06      	ldr	r2, [pc, #24]	; (8001838 <HAL_RCC_GetSysClockFreq+0x4c>)
      prediv = aPredivFactorTable[(uint32_t)(RCC->CFGR2 & RCC_CFGR2_PREDIV) >> POSITION_VAL(RCC_CFGR2_PREDIV)];
 800181e:	4807      	ldr	r0, [pc, #28]	; (800183c <HAL_RCC_GetSysClockFreq+0x50>)
 8001820:	5c41      	ldrb	r1, [r0, r1]
        pllclk = (HSE_VALUE / prediv) * pllmul;
      }
      else
      {
        /* HSI used as PLL clock source : PLLCLK = HSI/PREDIV * PLLMUL */
        pllclk = (HSI_VALUE / prediv) * pllmul;
 8001822:	4807      	ldr	r0, [pc, #28]	; (8001840 <HAL_RCC_GetSysClockFreq+0x54>)
 8001824:	fbb0 f1f1 	udiv	r1, r0, r1
      pllmul = aPLLMULFactorTable[(uint32_t)(tmpreg & RCC_CFGR_PLLMUL) >> POSITION_VAL(RCC_CFGR_PLLMUL)];
 8001828:	5cd0      	ldrb	r0, [r2, r3]
        pllclk = (HSI_VALUE / prediv) * pllmul;
 800182a:	4348      	muls	r0, r1
 800182c:	4770      	bx	lr
      sysclockfreq = HSE_VALUE;
 800182e:	4804      	ldr	r0, [pc, #16]	; (8001840 <HAL_RCC_GetSysClockFreq+0x54>)
      sysclockfreq = HSI_VALUE;
      break;
    }
  }
  return sysclockfreq;
}
 8001830:	4770      	bx	lr
 8001832:	bf00      	nop
 8001834:	40021000 	.word	0x40021000
 8001838:	08003a14 	.word	0x08003a14
 800183c:	08003a24 	.word	0x08003a24
 8001840:	007a1200 	.word	0x007a1200

08001844 <HAL_RCC_ClockConfig>:
{
 8001844:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001848:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 800184a:	4604      	mov	r4, r0
 800184c:	b910      	cbnz	r0, 8001854 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 800184e:	2001      	movs	r0, #1
 8001850:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8001854:	4a4c      	ldr	r2, [pc, #304]	; (8001988 <HAL_RCC_ClockConfig+0x144>)
 8001856:	6813      	ldr	r3, [r2, #0]
 8001858:	f003 0307 	and.w	r3, r3, #7
 800185c:	428b      	cmp	r3, r1
 800185e:	d32e      	bcc.n	80018be <HAL_RCC_ClockConfig+0x7a>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001860:	6822      	ldr	r2, [r4, #0]
 8001862:	0791      	lsls	r1, r2, #30
 8001864:	d436      	bmi.n	80018d4 <HAL_RCC_ClockConfig+0x90>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001866:	07d2      	lsls	r2, r2, #31
 8001868:	d43c      	bmi.n	80018e4 <HAL_RCC_ClockConfig+0xa0>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 800186a:	4a47      	ldr	r2, [pc, #284]	; (8001988 <HAL_RCC_ClockConfig+0x144>)
 800186c:	6813      	ldr	r3, [r2, #0]
 800186e:	f003 0307 	and.w	r3, r3, #7
 8001872:	429d      	cmp	r5, r3
 8001874:	d375      	bcc.n	8001962 <HAL_RCC_ClockConfig+0x11e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001876:	6822      	ldr	r2, [r4, #0]
 8001878:	4d44      	ldr	r5, [pc, #272]	; (800198c <HAL_RCC_ClockConfig+0x148>)
 800187a:	f012 0f04 	tst.w	r2, #4
 800187e:	d17c      	bne.n	800197a <HAL_RCC_ClockConfig+0x136>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001880:	0713      	lsls	r3, r2, #28
 8001882:	d506      	bpl.n	8001892 <HAL_RCC_ClockConfig+0x4e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 8001884:	686b      	ldr	r3, [r5, #4]
 8001886:	6922      	ldr	r2, [r4, #16]
 8001888:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 800188c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8001890:	606b      	str	r3, [r5, #4]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC->CFGR & RCC_CFGR_HPRE)>> RCC_CFGR_HPRE_BITNUMBER];
 8001892:	f7ff ffab 	bl	80017ec <HAL_RCC_GetSysClockFreq>
 8001896:	686b      	ldr	r3, [r5, #4]
 8001898:	22f0      	movs	r2, #240	; 0xf0
 800189a:	fa92 f2a2 	rbit	r2, r2
 800189e:	fab2 f282 	clz	r2, r2
 80018a2:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 80018a6:	40d3      	lsrs	r3, r2
 80018a8:	4a39      	ldr	r2, [pc, #228]	; (8001990 <HAL_RCC_ClockConfig+0x14c>)
 80018aa:	5cd3      	ldrb	r3, [r2, r3]
 80018ac:	40d8      	lsrs	r0, r3
 80018ae:	4b39      	ldr	r3, [pc, #228]	; (8001994 <HAL_RCC_ClockConfig+0x150>)
 80018b0:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 80018b2:	2000      	movs	r0, #0
 80018b4:	f001 fe22 	bl	80034fc <HAL_InitTick>
  return HAL_OK;
 80018b8:	2000      	movs	r0, #0
 80018ba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 80018be:	6813      	ldr	r3, [r2, #0]
 80018c0:	f023 0307 	bic.w	r3, r3, #7
 80018c4:	430b      	orrs	r3, r1
 80018c6:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80018c8:	6813      	ldr	r3, [r2, #0]
 80018ca:	f003 0307 	and.w	r3, r3, #7
 80018ce:	4299      	cmp	r1, r3
 80018d0:	d1bd      	bne.n	800184e <HAL_RCC_ClockConfig+0xa>
 80018d2:	e7c5      	b.n	8001860 <HAL_RCC_ClockConfig+0x1c>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 80018d4:	492d      	ldr	r1, [pc, #180]	; (800198c <HAL_RCC_ClockConfig+0x148>)
 80018d6:	68a0      	ldr	r0, [r4, #8]
 80018d8:	684b      	ldr	r3, [r1, #4]
 80018da:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80018de:	4303      	orrs	r3, r0
 80018e0:	604b      	str	r3, [r1, #4]
 80018e2:	e7c0      	b.n	8001866 <HAL_RCC_ClockConfig+0x22>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80018e4:	6862      	ldr	r2, [r4, #4]
 80018e6:	4e29      	ldr	r6, [pc, #164]	; (800198c <HAL_RCC_ClockConfig+0x148>)
 80018e8:	2a01      	cmp	r2, #1
 80018ea:	d127      	bne.n	800193c <HAL_RCC_ClockConfig+0xf8>
 80018ec:	f44f 3300 	mov.w	r3, #131072	; 0x20000
 80018f0:	fa93 f1a3 	rbit	r1, r3
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == RESET)
 80018f4:	6831      	ldr	r1, [r6, #0]
 80018f6:	fa93 f3a3 	rbit	r3, r3
 80018fa:	fab3 f383 	clz	r3, r3
 80018fe:	f003 031f 	and.w	r3, r3, #31
 8001902:	fa02 f303 	lsl.w	r3, r2, r3
 8001906:	420b      	tst	r3, r1
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 8001908:	d0a1      	beq.n	800184e <HAL_RCC_ClockConfig+0xa>
    __HAL_RCC_SYSCLK_CONFIG(RCC_ClkInitStruct->SYSCLKSource);
 800190a:	6873      	ldr	r3, [r6, #4]
 800190c:	f023 0303 	bic.w	r3, r3, #3
 8001910:	431a      	orrs	r2, r3
 8001912:	6072      	str	r2, [r6, #4]
    tickstart = HAL_GetTick();
 8001914:	f7fe fc82 	bl	800021c <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001918:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 800191c:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800191e:	6873      	ldr	r3, [r6, #4]
 8001920:	6862      	ldr	r2, [r4, #4]
 8001922:	f003 030c 	and.w	r3, r3, #12
 8001926:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 800192a:	d09e      	beq.n	800186a <HAL_RCC_ClockConfig+0x26>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800192c:	f7fe fc76 	bl	800021c <HAL_GetTick>
 8001930:	1bc0      	subs	r0, r0, r7
 8001932:	4540      	cmp	r0, r8
 8001934:	d9f3      	bls.n	800191e <HAL_RCC_ClockConfig+0xda>
        return HAL_TIMEOUT;
 8001936:	2003      	movs	r0, #3
}
 8001938:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800193c:	2a02      	cmp	r2, #2
 800193e:	bf0c      	ite	eq
 8001940:	f04f 7300 	moveq.w	r3, #33554432	; 0x2000000
 8001944:	2302      	movne	r3, #2
 8001946:	fa93 f1a3 	rbit	r1, r3
      if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET)
 800194a:	6830      	ldr	r0, [r6, #0]
 800194c:	fa93 f3a3 	rbit	r3, r3
 8001950:	fab3 f383 	clz	r3, r3
 8001954:	f003 031f 	and.w	r3, r3, #31
 8001958:	2101      	movs	r1, #1
 800195a:	fa01 f303 	lsl.w	r3, r1, r3
 800195e:	4203      	tst	r3, r0
 8001960:	e7d2      	b.n	8001908 <HAL_RCC_ClockConfig+0xc4>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001962:	6813      	ldr	r3, [r2, #0]
 8001964:	f023 0307 	bic.w	r3, r3, #7
 8001968:	432b      	orrs	r3, r5
 800196a:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 800196c:	6813      	ldr	r3, [r2, #0]
 800196e:	f003 0307 	and.w	r3, r3, #7
 8001972:	429d      	cmp	r5, r3
 8001974:	f47f af6b 	bne.w	800184e <HAL_RCC_ClockConfig+0xa>
 8001978:	e77d      	b.n	8001876 <HAL_RCC_ClockConfig+0x32>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 800197a:	686b      	ldr	r3, [r5, #4]
 800197c:	68e1      	ldr	r1, [r4, #12]
 800197e:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001982:	430b      	orrs	r3, r1
 8001984:	606b      	str	r3, [r5, #4]
 8001986:	e77b      	b.n	8001880 <HAL_RCC_ClockConfig+0x3c>
 8001988:	40022000 	.word	0x40022000
 800198c:	40021000 	.word	0x40021000
 8001990:	08003a45 	.word	0x08003a45
 8001994:	200000bc 	.word	0x200000bc

08001998 <HAL_RCC_GetHCLKFreq>:
  * @retval HCLK frequency
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
  return SystemCoreClock;
}
 8001998:	4b01      	ldr	r3, [pc, #4]	; (80019a0 <HAL_RCC_GetHCLKFreq+0x8>)
 800199a:	6818      	ldr	r0, [r3, #0]
 800199c:	4770      	bx	lr
 800199e:	bf00      	nop
 80019a0:	200000bc 	.word	0x200000bc

080019a4 <HAL_RCC_GetPCLK2Freq>:
  * @retval PCLK2 frequency
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
  /* Get HCLK source and Compute PCLK2 frequency ---------------------------*/
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[(RCC->CFGR & RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_BITNUMBER]);
 80019a4:	4b08      	ldr	r3, [pc, #32]	; (80019c8 <HAL_RCC_GetPCLK2Freq+0x24>)
 80019a6:	f44f 5260 	mov.w	r2, #14336	; 0x3800
 80019aa:	685b      	ldr	r3, [r3, #4]
 80019ac:	fa92 f2a2 	rbit	r2, r2
 80019b0:	fab2 f282 	clz	r2, r2
 80019b4:	f403 5360 	and.w	r3, r3, #14336	; 0x3800
 80019b8:	40d3      	lsrs	r3, r2
 80019ba:	4a04      	ldr	r2, [pc, #16]	; (80019cc <HAL_RCC_GetPCLK2Freq+0x28>)
 80019bc:	5cd3      	ldrb	r3, [r2, r3]
 80019be:	4a04      	ldr	r2, [pc, #16]	; (80019d0 <HAL_RCC_GetPCLK2Freq+0x2c>)
 80019c0:	6810      	ldr	r0, [r2, #0]
} 
 80019c2:	40d8      	lsrs	r0, r3
 80019c4:	4770      	bx	lr
 80019c6:	bf00      	nop
 80019c8:	40021000 	.word	0x40021000
 80019cc:	08003a55 	.word	0x08003a55
 80019d0:	200000bc 	.word	0x200000bc

080019d4 <HAL_RCC_GetClockConfig>:
  /* Check the parameters */
  assert_param(RCC_ClkInitStruct != NULL);
  assert_param(pFLatency != NULL);

  /* Set all possible values for the Clock type parameter --------------------*/
  RCC_ClkInitStruct->ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
 80019d4:	230f      	movs	r3, #15
 80019d6:	6003      	str	r3, [r0, #0]
  
  /* Get the SYSCLK configuration --------------------------------------------*/ 
  RCC_ClkInitStruct->SYSCLKSource = (uint32_t)(RCC->CFGR & RCC_CFGR_SW);
 80019d8:	4b0b      	ldr	r3, [pc, #44]	; (8001a08 <HAL_RCC_GetClockConfig+0x34>)
 80019da:	685a      	ldr	r2, [r3, #4]
 80019dc:	f002 0203 	and.w	r2, r2, #3
 80019e0:	6042      	str	r2, [r0, #4]
  
  /* Get the HCLK configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->AHBCLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_HPRE); 
 80019e2:	685a      	ldr	r2, [r3, #4]
 80019e4:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 80019e8:	6082      	str	r2, [r0, #8]
  
  /* Get the APB1 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB1CLKDivider = (uint32_t)(RCC->CFGR & RCC_CFGR_PPRE1);   
 80019ea:	685a      	ldr	r2, [r3, #4]
 80019ec:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 80019f0:	60c2      	str	r2, [r0, #12]
  
  /* Get the APB2 configuration ----------------------------------------------*/ 
  RCC_ClkInitStruct->APB2CLKDivider = (uint32_t)((RCC->CFGR & RCC_CFGR_PPRE2) >> 3U);
 80019f2:	685b      	ldr	r3, [r3, #4]
 80019f4:	08db      	lsrs	r3, r3, #3
 80019f6:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
 80019fa:	6103      	str	r3, [r0, #16]
  
  /* Get the Flash Wait State (Latency) configuration ------------------------*/   
  *pFLatency = (uint32_t)(FLASH->ACR & FLASH_ACR_LATENCY); 
 80019fc:	4b03      	ldr	r3, [pc, #12]	; (8001a0c <HAL_RCC_GetClockConfig+0x38>)
 80019fe:	681b      	ldr	r3, [r3, #0]
 8001a00:	f003 0307 	and.w	r3, r3, #7
 8001a04:	600b      	str	r3, [r1, #0]
 8001a06:	4770      	bx	lr
 8001a08:	40021000 	.word	0x40021000
 8001a0c:	40022000 	.word	0x40022000

08001a10 <HAL_RCCEx_PeriphCLKConfig>:
    
  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));
  
  /*---------------------------- RTC configuration -------------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8001a10:	6803      	ldr	r3, [r0, #0]
{
 8001a12:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8001a16:	03df      	lsls	r7, r3, #15
{
 8001a18:	4604      	mov	r4, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RTC) == (RCC_PERIPHCLK_RTC))
 8001a1a:	d523      	bpl.n	8001a64 <HAL_RCCEx_PeriphCLKConfig+0x54>
    FlagStatus       pwrclkchanged = RESET;

    /* As soon as function is called to change RTC clock source, activation of the 
       power domain is done. */
    /* Requires to enable write access to Backup Domain of necessary */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8001a1c:	4d9b      	ldr	r5, [pc, #620]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001a1e:	69eb      	ldr	r3, [r5, #28]
 8001a20:	00de      	lsls	r6, r3, #3
 8001a22:	f100 80d7 	bmi.w	8001bd4 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001a26:	69eb      	ldr	r3, [r5, #28]
 8001a28:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8001a2c:	61eb      	str	r3, [r5, #28]
 8001a2e:	69eb      	ldr	r3, [r5, #28]
 8001a30:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8001a34:	9301      	str	r3, [sp, #4]
 8001a36:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001a38:	2601      	movs	r6, #1
    }
    
    if(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001a3a:	4f95      	ldr	r7, [pc, #596]	; (8001c90 <HAL_RCCEx_PeriphCLKConfig+0x280>)
 8001a3c:	683b      	ldr	r3, [r7, #0]
 8001a3e:	05d8      	lsls	r0, r3, #23
 8001a40:	f140 80ca 	bpl.w	8001bd8 <HAL_RCCEx_PeriphCLKConfig+0x1c8>
        }
      }
    }
    
    /* Reset the Backup domain only if the RTC Clock source selection is modified from reset value */ 
    temp_reg = (RCC->BDCR & RCC_BDCR_RTCSEL);
 8001a44:	6a2b      	ldr	r3, [r5, #32]
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001a46:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8001a4a:	f040 80da 	bne.w	8001c02 <HAL_RCCEx_PeriphCLKConfig+0x1f2>
            return HAL_TIMEOUT;
          }      
        }  
      }
    }
    __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection); 
 8001a4e:	6a2b      	ldr	r3, [r5, #32]
 8001a50:	6862      	ldr	r2, [r4, #4]
 8001a52:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8001a56:	4313      	orrs	r3, r2
 8001a58:	622b      	str	r3, [r5, #32]

    /* Require to disable power clock if necessary */
    if(pwrclkchanged == SET)
 8001a5a:	b11e      	cbz	r6, 8001a64 <HAL_RCCEx_PeriphCLKConfig+0x54>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001a5c:	69eb      	ldr	r3, [r5, #28]
 8001a5e:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8001a62:	61eb      	str	r3, [r5, #28]
    }
  }

  /*------------------------------- USART1 Configuration ------------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8001a64:	6820      	ldr	r0, [r4, #0]
 8001a66:	07c3      	lsls	r3, r0, #31
 8001a68:	d506      	bpl.n	8001a78 <HAL_RCCEx_PeriphCLKConfig+0x68>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));
    
    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8001a6a:	4a88      	ldr	r2, [pc, #544]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001a6c:	68a1      	ldr	r1, [r4, #8]
 8001a6e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001a70:	f023 0303 	bic.w	r3, r3, #3
 8001a74:	430b      	orrs	r3, r1
 8001a76:	6313      	str	r3, [r2, #48]	; 0x30
  }

#if defined(RCC_CFGR3_USART2SW)
  /*----------------------------- USART2 Configuration --------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8001a78:	0787      	lsls	r7, r0, #30
 8001a7a:	d506      	bpl.n	8001a8a <HAL_RCCEx_PeriphCLKConfig+0x7a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));
    
    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8001a7c:	4a83      	ldr	r2, [pc, #524]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001a7e:	68e1      	ldr	r1, [r4, #12]
 8001a80:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001a82:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
 8001a86:	430b      	orrs	r3, r1
 8001a88:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* RCC_CFGR3_USART2SW */

#if defined(RCC_CFGR3_USART3SW)
  /*------------------------------ USART3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8001a8a:	0746      	lsls	r6, r0, #29
 8001a8c:	d506      	bpl.n	8001a9c <HAL_RCCEx_PeriphCLKConfig+0x8c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));
    
    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8001a8e:	4a7f      	ldr	r2, [pc, #508]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001a90:	6921      	ldr	r1, [r4, #16]
 8001a92:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001a94:	f423 2340 	bic.w	r3, r3, #786432	; 0xc0000
 8001a98:	430b      	orrs	r3, r1
 8001a9a:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* RCC_CFGR3_USART3SW */

  /*------------------------------ I2C1 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8001a9c:	0685      	lsls	r5, r0, #26
 8001a9e:	d506      	bpl.n	8001aae <HAL_RCCEx_PeriphCLKConfig+0x9e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));
    
    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8001aa0:	4a7a      	ldr	r2, [pc, #488]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001aa2:	69e1      	ldr	r1, [r4, #28]
 8001aa4:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001aa6:	f023 0310 	bic.w	r3, r3, #16
 8001aaa:	430b      	orrs	r3, r1
 8001aac:	6313      	str	r3, [r2, #48]	; 0x30
#if defined(STM32F302xE) || defined(STM32F303xE)\
 || defined(STM32F302xC) || defined(STM32F303xC)\
 || defined(STM32F302x8)                        \
 || defined(STM32F373xC)
  /*------------------------------ USB Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == RCC_PERIPHCLK_USB)
 8001aae:	0381      	lsls	r1, r0, #14
 8001ab0:	d506      	bpl.n	8001ac0 <HAL_RCCEx_PeriphCLKConfig+0xb0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->USBClockSelection));
    
    /* Configure the USB clock source */
    __HAL_RCC_USB_CONFIG(PeriphClkInit->USBClockSelection);
 8001ab2:	4a76      	ldr	r2, [pc, #472]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001ab4:	6d61      	ldr	r1, [r4, #84]	; 0x54
 8001ab6:	6853      	ldr	r3, [r2, #4]
 8001ab8:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001abc:	430b      	orrs	r3, r1
 8001abe:	6053      	str	r3, [r2, #4]
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)\
 || defined(STM32F373xC) || defined(STM32F378xx)

  /*------------------------------ I2C2 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8001ac0:	0642      	lsls	r2, r0, #25
 8001ac2:	d506      	bpl.n	8001ad2 <HAL_RCCEx_PeriphCLKConfig+0xc2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));
    
    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8001ac4:	4a71      	ldr	r2, [pc, #452]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001ac6:	6a21      	ldr	r1, [r4, #32]
 8001ac8:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001aca:	f023 0320 	bic.w	r3, r3, #32
 8001ace:	430b      	orrs	r3, r1
 8001ad0:	6313      	str	r3, [r2, #48]	; 0x30
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)

  /*------------------------------ I2C3 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8001ad2:	0343      	lsls	r3, r0, #13
 8001ad4:	d506      	bpl.n	8001ae4 <HAL_RCCEx_PeriphCLKConfig+0xd4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));
    
    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8001ad6:	4a6d      	ldr	r2, [pc, #436]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001ad8:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8001ada:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001adc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001ae0:	430b      	orrs	r3, r1
 8001ae2:	6313      	str	r3, [r2, #48]	; 0x30
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ UART4 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8001ae4:	0707      	lsls	r7, r0, #28
 8001ae6:	d506      	bpl.n	8001af6 <HAL_RCCEx_PeriphCLKConfig+0xe6>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));
    
    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8001ae8:	4a68      	ldr	r2, [pc, #416]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001aea:	6961      	ldr	r1, [r4, #20]
 8001aec:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001aee:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8001af2:	430b      	orrs	r3, r1
 8001af4:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ UART5 Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8001af6:	06c6      	lsls	r6, r0, #27
 8001af8:	d506      	bpl.n	8001b08 <HAL_RCCEx_PeriphCLKConfig+0xf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));
    
    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8001afa:	4a64      	ldr	r2, [pc, #400]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001afc:	69a1      	ldr	r1, [r4, #24]
 8001afe:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b00:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8001b04:	430b      	orrs	r3, r1
 8001b06:	6313      	str	r3, [r2, #48]	; 0x30

#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)
  /*------------------------------ I2S Configuration ------------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 8001b08:	0585      	lsls	r5, r0, #22
 8001b0a:	d506      	bpl.n	8001b1a <HAL_RCCEx_PeriphCLKConfig+0x10a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));
    
    /* Configure the I2S clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 8001b0c:	4a5f      	ldr	r2, [pc, #380]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b0e:	6b21      	ldr	r1, [r4, #48]	; 0x30
 8001b10:	6853      	ldr	r3, [r2, #4]
 8001b12:	f423 0300 	bic.w	r3, r3, #8388608	; 0x800000
 8001b16:	430b      	orrs	r3, r1
 8001b18:	6053      	str	r3, [r2, #4]
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)
      
  /*------------------------------ ADC1 & ADC2 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8001b1a:	0601      	lsls	r1, r0, #24
 8001b1c:	d506      	bpl.n	8001b2c <HAL_RCCEx_PeriphCLKConfig+0x11c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12PLLCLK_DIV(PeriphClkInit->Adc12ClockSelection));
    
    /* Configure the ADC12 clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 8001b1e:	4a5b      	ldr	r2, [pc, #364]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b20:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8001b22:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8001b24:	f423 73f8 	bic.w	r3, r3, #496	; 0x1f0
 8001b28:	430b      	orrs	r3, r1
 8001b2a:	62d3      	str	r3, [r2, #44]	; 0x2c
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ ADC3 & ADC4 clock Configuration -------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC34) == RCC_PERIPHCLK_ADC34)
 8001b2c:	05c2      	lsls	r2, r0, #23
 8001b2e:	d506      	bpl.n	8001b3e <HAL_RCCEx_PeriphCLKConfig+0x12e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC34PLLCLK_DIV(PeriphClkInit->Adc34ClockSelection));
    
    /* Configure the ADC34 clock source */
    __HAL_RCC_ADC34_CONFIG(PeriphClkInit->Adc34ClockSelection);
 8001b30:	4a56      	ldr	r2, [pc, #344]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b32:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8001b34:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8001b36:	f423 5378 	bic.w	r3, r3, #15872	; 0x3e00
 8001b3a:	430b      	orrs	r3, r1
 8001b3c:	62d3      	str	r3, [r2, #44]	; 0x2c
 || defined(STM32F302xC) || defined(STM32F303xC) || defined(STM32F358xx)\
 || defined(STM32F303x8) || defined(STM32F334x8) || defined(STM32F328xx)\
 || defined(STM32F301x8) || defined(STM32F302x8) || defined(STM32F318xx)

  /*------------------------------ TIM1 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM1) == RCC_PERIPHCLK_TIM1)
 8001b3e:	04c3      	lsls	r3, r0, #19
 8001b40:	d506      	bpl.n	8001b50 <HAL_RCCEx_PeriphCLKConfig+0x140>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM1CLKSOURCE(PeriphClkInit->Tim1ClockSelection));
    
    /* Configure the TIM1 clock source */
    __HAL_RCC_TIM1_CONFIG(PeriphClkInit->Tim1ClockSelection);
 8001b42:	4a52      	ldr	r2, [pc, #328]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b44:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8001b46:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b48:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8001b4c:	430b      	orrs	r3, r1
 8001b4e:	6313      	str	r3, [r2, #48]	; 0x30
  
#if defined(STM32F303xE) || defined(STM32F398xx)\
 || defined(STM32F303xC) || defined(STM32F358xx)

  /*------------------------------ TIM8 clock Configuration ----------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM8) == RCC_PERIPHCLK_TIM8)
 8001b50:	0487      	lsls	r7, r0, #18
 8001b52:	d506      	bpl.n	8001b62 <HAL_RCCEx_PeriphCLKConfig+0x152>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM8CLKSOURCE(PeriphClkInit->Tim8ClockSelection));
    
    /* Configure the TIM8 clock source */
    __HAL_RCC_TIM8_CONFIG(PeriphClkInit->Tim8ClockSelection);
 8001b54:	4a4d      	ldr	r2, [pc, #308]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b56:	6c21      	ldr	r1, [r4, #64]	; 0x40
 8001b58:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b5a:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001b5e:	430b      	orrs	r3, r1
 8001b60:	6313      	str	r3, [r2, #48]	; 0x30
#endif /* STM32F373xC || STM32F378xx */
  
#if defined(STM32F302xE) || defined(STM32F303xE) || defined(STM32F398xx)
  
  /*------------------------------ TIM2 clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM2) == RCC_PERIPHCLK_TIM2)
 8001b62:	02c6      	lsls	r6, r0, #11
 8001b64:	d506      	bpl.n	8001b74 <HAL_RCCEx_PeriphCLKConfig+0x164>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM2CLKSOURCE(PeriphClkInit->Tim2ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM2_CONFIG(PeriphClkInit->Tim2ClockSelection);
 8001b66:	4a49      	ldr	r2, [pc, #292]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b68:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8001b6a:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b6c:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001b70:	430b      	orrs	r3, r1
 8001b72:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ TIM3 clock Configuration -------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM34) == RCC_PERIPHCLK_TIM34)
 8001b74:	0285      	lsls	r5, r0, #10
 8001b76:	d506      	bpl.n	8001b86 <HAL_RCCEx_PeriphCLKConfig+0x176>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM3CLKSOURCE(PeriphClkInit->Tim34ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM34_CONFIG(PeriphClkInit->Tim34ClockSelection);
 8001b78:	4a44      	ldr	r2, [pc, #272]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b7a:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001b7c:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b7e:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
 8001b82:	430b      	orrs	r3, r1
 8001b84:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ TIM15 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM15) == RCC_PERIPHCLK_TIM15)
 8001b86:	0241      	lsls	r1, r0, #9
 8001b88:	d506      	bpl.n	8001b98 <HAL_RCCEx_PeriphCLKConfig+0x188>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM15CLKSOURCE(PeriphClkInit->Tim15ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM15_CONFIG(PeriphClkInit->Tim15ClockSelection);
 8001b8a:	4a40      	ldr	r2, [pc, #256]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b8c:	6c61      	ldr	r1, [r4, #68]	; 0x44
 8001b8e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001b90:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8001b94:	430b      	orrs	r3, r1
 8001b96:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ TIM16 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM16) == RCC_PERIPHCLK_TIM16)
 8001b98:	0202      	lsls	r2, r0, #8
 8001b9a:	d506      	bpl.n	8001baa <HAL_RCCEx_PeriphCLKConfig+0x19a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM16CLKSOURCE(PeriphClkInit->Tim16ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM16_CONFIG(PeriphClkInit->Tim16ClockSelection);
 8001b9c:	4a3b      	ldr	r2, [pc, #236]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001b9e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8001ba0:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001ba2:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
 8001ba6:	430b      	orrs	r3, r1
 8001ba8:	6313      	str	r3, [r2, #48]	; 0x30
  }

  /*------------------------------ TIM17 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM17) == RCC_PERIPHCLK_TIM17)
 8001baa:	01c3      	lsls	r3, r0, #7
 8001bac:	d506      	bpl.n	8001bbc <HAL_RCCEx_PeriphCLKConfig+0x1ac>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM17CLKSOURCE(PeriphClkInit->Tim17ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM17_CONFIG(PeriphClkInit->Tim17ClockSelection);
 8001bae:	4a37      	ldr	r2, [pc, #220]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001bb0:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8001bb2:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001bb4:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 8001bb8:	430b      	orrs	r3, r1
 8001bba:	6313      	str	r3, [r2, #48]	; 0x30

#endif /* STM32F302xE || STM32F303xE || STM32F398xx */  

#if defined(STM32F303xE) || defined(STM32F398xx)
  /*------------------------------ TIM20 clock Configuration ------------------*/ 
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_TIM20) == RCC_PERIPHCLK_TIM20)
 8001bbc:	f010 7000 	ands.w	r0, r0, #33554432	; 0x2000000
 8001bc0:	d01c      	beq.n	8001bfc <HAL_RCCEx_PeriphCLKConfig+0x1ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIM20CLKSOURCE(PeriphClkInit->Tim20ClockSelection));
    
    /* Configure the CEC clock source */
    __HAL_RCC_TIM20_CONFIG(PeriphClkInit->Tim20ClockSelection);
 8001bc2:	4a32      	ldr	r2, [pc, #200]	; (8001c8c <HAL_RCCEx_PeriphCLKConfig+0x27c>)
 8001bc4:	6d21      	ldr	r1, [r4, #80]	; 0x50
 8001bc6:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8001bc8:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001bcc:	430b      	orrs	r3, r1
 8001bce:	6313      	str	r3, [r2, #48]	; 0x30
  }
#endif /* STM32F303xE || STM32F398xx */  

  
  return HAL_OK;
 8001bd0:	2000      	movs	r0, #0
 8001bd2:	e013      	b.n	8001bfc <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    FlagStatus       pwrclkchanged = RESET;
 8001bd4:	2600      	movs	r6, #0
 8001bd6:	e730      	b.n	8001a3a <HAL_RCCEx_PeriphCLKConfig+0x2a>
      SET_BIT(PWR->CR, PWR_CR_DBP);
 8001bd8:	683b      	ldr	r3, [r7, #0]
 8001bda:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001bde:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 8001be0:	f7fe fb1c 	bl	800021c <HAL_GetTick>
 8001be4:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR, PWR_CR_DBP))
 8001be6:	683b      	ldr	r3, [r7, #0]
 8001be8:	05d9      	lsls	r1, r3, #23
 8001bea:	f53f af2b 	bmi.w	8001a44 <HAL_RCCEx_PeriphCLKConfig+0x34>
          if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001bee:	f7fe fb15 	bl	800021c <HAL_GetTick>
 8001bf2:	eba0 0008 	sub.w	r0, r0, r8
 8001bf6:	2864      	cmp	r0, #100	; 0x64
 8001bf8:	d9f5      	bls.n	8001be6 <HAL_RCCEx_PeriphCLKConfig+0x1d6>
          return HAL_TIMEOUT;
 8001bfa:	2003      	movs	r0, #3
}
 8001bfc:	b002      	add	sp, #8
 8001bfe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((temp_reg != 0x00000000U) && (temp_reg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
 8001c02:	6862      	ldr	r2, [r4, #4]
 8001c04:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8001c08:	4293      	cmp	r3, r2
 8001c0a:	f43f af20 	beq.w	8001a4e <HAL_RCCEx_PeriphCLKConfig+0x3e>
      temp_reg = (RCC->BDCR & ~(RCC_BDCR_RTCSEL));
 8001c0e:	6a29      	ldr	r1, [r5, #32]
 8001c10:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 8001c14:	f421 7040 	bic.w	r0, r1, #768	; 0x300
 8001c18:	fa93 f2a3 	rbit	r2, r3
      __HAL_RCC_BACKUPRESET_FORCE();
 8001c1c:	f8df e074 	ldr.w	lr, [pc, #116]	; 8001c94 <HAL_RCCEx_PeriphCLKConfig+0x284>
 8001c20:	fab2 f282 	clz	r2, r2
 8001c24:	4472      	add	r2, lr
 8001c26:	0092      	lsls	r2, r2, #2
 8001c28:	2701      	movs	r7, #1
 8001c2a:	6017      	str	r7, [r2, #0]
 8001c2c:	fa93 f3a3 	rbit	r3, r3
      __HAL_RCC_BACKUPRESET_RELEASE();
 8001c30:	fab3 f383 	clz	r3, r3
 8001c34:	4473      	add	r3, lr
 8001c36:	009b      	lsls	r3, r3, #2
 8001c38:	2200      	movs	r2, #0
 8001c3a:	601a      	str	r2, [r3, #0]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8001c3c:	07ca      	lsls	r2, r1, #31
      RCC->BDCR = temp_reg;
 8001c3e:	6228      	str	r0, [r5, #32]
      if (HAL_IS_BIT_SET(temp_reg, RCC_BDCR_LSEON))
 8001c40:	f57f af05 	bpl.w	8001a4e <HAL_RCCEx_PeriphCLKConfig+0x3e>
        tickstart = HAL_GetTick();
 8001c44:	f7fe faea 	bl	800021c <HAL_GetTick>
 8001c48:	f04f 0802 	mov.w	r8, #2
 8001c4c:	4682      	mov	sl, r0
 8001c4e:	46c1      	mov	r9, r8
 8001c50:	fa98 f3a8 	rbit	r3, r8
 8001c54:	fa98 f3a8 	rbit	r3, r8
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001c58:	b1a3      	cbz	r3, 8001c84 <HAL_RCCEx_PeriphCLKConfig+0x274>
 8001c5a:	6a2a      	ldr	r2, [r5, #32]
 8001c5c:	fa99 f3a9 	rbit	r3, r9
 8001c60:	fab3 f383 	clz	r3, r3
 8001c64:	f003 031f 	and.w	r3, r3, #31
 8001c68:	fa07 f303 	lsl.w	r3, r7, r3
 8001c6c:	4213      	tst	r3, r2
 8001c6e:	f47f aeee 	bne.w	8001a4e <HAL_RCCEx_PeriphCLKConfig+0x3e>
            if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001c72:	f7fe fad3 	bl	800021c <HAL_GetTick>
 8001c76:	f241 3388 	movw	r3, #5000	; 0x1388
 8001c7a:	eba0 000a 	sub.w	r0, r0, sl
 8001c7e:	4298      	cmp	r0, r3
 8001c80:	d9e6      	bls.n	8001c50 <HAL_RCCEx_PeriphCLKConfig+0x240>
 8001c82:	e7ba      	b.n	8001bfa <HAL_RCCEx_PeriphCLKConfig+0x1ea>
 8001c84:	fa98 f3a8 	rbit	r3, r8
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == RESET)
 8001c88:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001c8a:	e7e7      	b.n	8001c5c <HAL_RCCEx_PeriphCLKConfig+0x24c>
 8001c8c:	40021000 	.word	0x40021000
 8001c90:	40007000 	.word	0x40007000
 8001c94:	10908100 	.word	0x10908100

08001c98 <HAL_TIM_Base_MspInit>:
 8001c98:	4770      	bx	lr

08001c9a <HAL_TIM_Base_Start_IT>:
{
  /* Check the parameters */
  assert_param(IS_TIM_INSTANCE(htim->Instance));
  
   /* Enable the TIM Update interrupt */
   __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8001c9a:	6803      	ldr	r3, [r0, #0]
 8001c9c:	68da      	ldr	r2, [r3, #12]
 8001c9e:	f042 0201 	orr.w	r2, r2, #1
 8001ca2:	60da      	str	r2, [r3, #12]
      
   /* Enable the Peripheral */
  __HAL_TIM_ENABLE(htim);
 8001ca4:	681a      	ldr	r2, [r3, #0]
 8001ca6:	f042 0201 	orr.w	r2, r2, #1
 8001caa:	601a      	str	r2, [r3, #0]
      
  /* Return function status */
  return HAL_OK;
}
 8001cac:	2000      	movs	r0, #0
 8001cae:	4770      	bx	lr

08001cb0 <HAL_TIM_OC_DelayElapsedCallback>:
 8001cb0:	4770      	bx	lr

08001cb2 <HAL_TIM_IC_CaptureCallback>:
 8001cb2:	4770      	bx	lr

08001cb4 <HAL_TIM_PWM_PulseFinishedCallback>:
 8001cb4:	4770      	bx	lr

08001cb6 <HAL_TIM_TriggerCallback>:
 8001cb6:	4770      	bx	lr

08001cb8 <HAL_TIM_IRQHandler>:
  * @retval None
  */
void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
{
  /* Capture compare 1 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001cb8:	6803      	ldr	r3, [r0, #0]
 8001cba:	691a      	ldr	r2, [r3, #16]
 8001cbc:	0791      	lsls	r1, r2, #30
{
 8001cbe:	b510      	push	{r4, lr}
 8001cc0:	4604      	mov	r4, r0
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
 8001cc2:	d50f      	bpl.n	8001ce4 <HAL_TIM_IRQHandler+0x2c>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
 8001cc4:	68da      	ldr	r2, [r3, #12]
 8001cc6:	0792      	lsls	r2, r2, #30
 8001cc8:	d50c      	bpl.n	8001ce4 <HAL_TIM_IRQHandler+0x2c>
    {
      {
        __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC1);
 8001cca:	f06f 0202 	mvn.w	r2, #2
 8001cce:	611a      	str	r2, [r3, #16]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
        
        /* Input capture event */
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001cd0:	699b      	ldr	r3, [r3, #24]
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001cd2:	2201      	movs	r2, #1
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001cd4:	0799      	lsls	r1, r3, #30
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
 8001cd6:	7702      	strb	r2, [r0, #28]
        if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
 8001cd8:	f000 8085 	beq.w	8001de6 <HAL_TIM_IRQHandler+0x12e>
        {
          HAL_TIM_IC_CaptureCallback(htim);
 8001cdc:	f7ff ffe9 	bl	8001cb2 <HAL_TIM_IC_CaptureCallback>
        else
        {
          HAL_TIM_OC_DelayElapsedCallback(htim);
          HAL_TIM_PWM_PulseFinishedCallback(htim);
        }
        htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001ce0:	2300      	movs	r3, #0
 8001ce2:	7723      	strb	r3, [r4, #28]
      }
    }
  }
  /* Capture compare 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
 8001ce4:	6823      	ldr	r3, [r4, #0]
 8001ce6:	691a      	ldr	r2, [r3, #16]
 8001ce8:	0752      	lsls	r2, r2, #29
 8001cea:	d510      	bpl.n	8001d0e <HAL_TIM_IRQHandler+0x56>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
 8001cec:	68da      	ldr	r2, [r3, #12]
 8001cee:	0750      	lsls	r0, r2, #29
 8001cf0:	d50d      	bpl.n	8001d0e <HAL_TIM_IRQHandler+0x56>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC2);
 8001cf2:	f06f 0204 	mvn.w	r2, #4
 8001cf6:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
      /* Input capture event */
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001cf8:	699b      	ldr	r3, [r3, #24]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001cfa:	2202      	movs	r2, #2
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001cfc:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
 8001d00:	7722      	strb	r2, [r4, #28]
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001d02:	4620      	mov	r0, r4
      if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
 8001d04:	d075      	beq.n	8001df2 <HAL_TIM_IRQHandler+0x13a>
        HAL_TIM_IC_CaptureCallback(htim);
 8001d06:	f7ff ffd4 	bl	8001cb2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001d0a:	2300      	movs	r3, #0
 8001d0c:	7723      	strb	r3, [r4, #28]
    } 
  }
  /* Capture compare 3 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
 8001d0e:	6823      	ldr	r3, [r4, #0]
 8001d10:	691a      	ldr	r2, [r3, #16]
 8001d12:	0711      	lsls	r1, r2, #28
 8001d14:	d50f      	bpl.n	8001d36 <HAL_TIM_IRQHandler+0x7e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
 8001d16:	68da      	ldr	r2, [r3, #12]
 8001d18:	0712      	lsls	r2, r2, #28
 8001d1a:	d50c      	bpl.n	8001d36 <HAL_TIM_IRQHandler+0x7e>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC3);
 8001d1c:	f06f 0208 	mvn.w	r2, #8
 8001d20:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8001d22:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001d24:	2204      	movs	r2, #4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8001d26:	079b      	lsls	r3, r3, #30
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
 8001d28:	7722      	strb	r2, [r4, #28]
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001d2a:	4620      	mov	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
 8001d2c:	d067      	beq.n	8001dfe <HAL_TIM_IRQHandler+0x146>
        HAL_TIM_IC_CaptureCallback(htim);
 8001d2e:	f7ff ffc0 	bl	8001cb2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001d32:	2300      	movs	r3, #0
 8001d34:	7723      	strb	r3, [r4, #28]
    }
  }
  /* Capture compare 4 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
 8001d36:	6823      	ldr	r3, [r4, #0]
 8001d38:	691a      	ldr	r2, [r3, #16]
 8001d3a:	06d0      	lsls	r0, r2, #27
 8001d3c:	d510      	bpl.n	8001d60 <HAL_TIM_IRQHandler+0xa8>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
 8001d3e:	68da      	ldr	r2, [r3, #12]
 8001d40:	06d1      	lsls	r1, r2, #27
 8001d42:	d50d      	bpl.n	8001d60 <HAL_TIM_IRQHandler+0xa8>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_CC4);
 8001d44:	f06f 0210 	mvn.w	r2, #16
 8001d48:	611a      	str	r2, [r3, #16]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
      /* Input capture event */
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001d4a:	69db      	ldr	r3, [r3, #28]
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001d4c:	2208      	movs	r2, #8
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001d4e:	f413 7f40 	tst.w	r3, #768	; 0x300
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
 8001d52:	7722      	strb	r2, [r4, #28]
      {          
        HAL_TIM_IC_CaptureCallback(htim);
 8001d54:	4620      	mov	r0, r4
      if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
 8001d56:	d058      	beq.n	8001e0a <HAL_TIM_IRQHandler+0x152>
        HAL_TIM_IC_CaptureCallback(htim);
 8001d58:	f7ff ffab 	bl	8001cb2 <HAL_TIM_IC_CaptureCallback>
      else
      {
        HAL_TIM_OC_DelayElapsedCallback(htim);
        HAL_TIM_PWM_PulseFinishedCallback(htim);
      }
      htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
 8001d5c:	2300      	movs	r3, #0
 8001d5e:	7723      	strb	r3, [r4, #28]
    } 
  }
  /* TIM Update event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
 8001d60:	6823      	ldr	r3, [r4, #0]
 8001d62:	691a      	ldr	r2, [r3, #16]
 8001d64:	07d2      	lsls	r2, r2, #31
 8001d66:	d508      	bpl.n	8001d7a <HAL_TIM_IRQHandler+0xc2>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
 8001d68:	68da      	ldr	r2, [r3, #12]
 8001d6a:	07d0      	lsls	r0, r2, #31
 8001d6c:	d505      	bpl.n	8001d7a <HAL_TIM_IRQHandler+0xc2>
    { 
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_UPDATE);
 8001d6e:	f06f 0201 	mvn.w	r2, #1
 8001d72:	611a      	str	r2, [r3, #16]
      HAL_TIM_PeriodElapsedCallback(htim);
 8001d74:	4620      	mov	r0, r4
 8001d76:	f001 fb6f 	bl	8003458 <HAL_TIM_PeriodElapsedCallback>
    }
  }
  /* TIM Break input event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
 8001d7a:	6823      	ldr	r3, [r4, #0]
 8001d7c:	691a      	ldr	r2, [r3, #16]
 8001d7e:	0611      	lsls	r1, r2, #24
 8001d80:	d508      	bpl.n	8001d94 <HAL_TIM_IRQHandler+0xdc>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8001d82:	68da      	ldr	r2, [r3, #12]
 8001d84:	0612      	lsls	r2, r2, #24
 8001d86:	d505      	bpl.n	8001d94 <HAL_TIM_IRQHandler+0xdc>
    { 
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK);
 8001d88:	f06f 0280 	mvn.w	r2, #128	; 0x80
 8001d8c:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_BreakCallback(htim);
 8001d8e:	4620      	mov	r0, r4
 8001d90:	f000 f8c7 	bl	8001f22 <HAL_TIMEx_BreakCallback>
    }
  }

#if defined(TIM_FLAG_BREAK2)
  /* TIM Break input 2 event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK2) != RESET)
 8001d94:	6823      	ldr	r3, [r4, #0]
 8001d96:	691a      	ldr	r2, [r3, #16]
 8001d98:	05d0      	lsls	r0, r2, #23
 8001d9a:	d508      	bpl.n	8001dae <HAL_TIM_IRQHandler+0xf6>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
 8001d9c:	68da      	ldr	r2, [r3, #12]
 8001d9e:	0611      	lsls	r1, r2, #24
 8001da0:	d505      	bpl.n	8001dae <HAL_TIM_IRQHandler+0xf6>
    {
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_BREAK2);
 8001da2:	f46f 7280 	mvn.w	r2, #256	; 0x100
 8001da6:	611a      	str	r2, [r3, #16]
      HAL_TIMEx_Break2Callback(htim);
 8001da8:	4620      	mov	r0, r4
 8001daa:	f000 f8bb 	bl	8001f24 <HAL_TIMEx_Break2Callback>
    }
  }
#endif

  /* TIM Trigger detection event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
 8001dae:	6823      	ldr	r3, [r4, #0]
 8001db0:	691a      	ldr	r2, [r3, #16]
 8001db2:	0652      	lsls	r2, r2, #25
 8001db4:	d508      	bpl.n	8001dc8 <HAL_TIM_IRQHandler+0x110>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
 8001db6:	68da      	ldr	r2, [r3, #12]
 8001db8:	0650      	lsls	r0, r2, #25
 8001dba:	d505      	bpl.n	8001dc8 <HAL_TIM_IRQHandler+0x110>
    { 
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_TRIGGER);
 8001dbc:	f06f 0240 	mvn.w	r2, #64	; 0x40
 8001dc0:	611a      	str	r2, [r3, #16]
      HAL_TIM_TriggerCallback(htim);
 8001dc2:	4620      	mov	r0, r4
 8001dc4:	f7ff ff77 	bl	8001cb6 <HAL_TIM_TriggerCallback>
    }
  }
  /* TIM commutation event */
  if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
 8001dc8:	6823      	ldr	r3, [r4, #0]
 8001dca:	691a      	ldr	r2, [r3, #16]
 8001dcc:	0691      	lsls	r1, r2, #26
 8001dce:	d522      	bpl.n	8001e16 <HAL_TIM_IRQHandler+0x15e>
  {
    if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
 8001dd0:	68da      	ldr	r2, [r3, #12]
 8001dd2:	0692      	lsls	r2, r2, #26
 8001dd4:	d51f      	bpl.n	8001e16 <HAL_TIM_IRQHandler+0x15e>
    { 
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8001dd6:	f06f 0220 	mvn.w	r2, #32
      HAL_TIMEx_CommutationCallback(htim);
 8001dda:	4620      	mov	r0, r4
      __HAL_TIM_CLEAR_FLAG(htim, TIM_FLAG_COM);
 8001ddc:	611a      	str	r2, [r3, #16]
    }
  }
}
 8001dde:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      HAL_TIMEx_CommutationCallback(htim);
 8001de2:	f000 b89d 	b.w	8001f20 <HAL_TIMEx_CommutationCallback>
          HAL_TIM_OC_DelayElapsedCallback(htim);
 8001de6:	f7ff ff63 	bl	8001cb0 <HAL_TIM_OC_DelayElapsedCallback>
          HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001dea:	4620      	mov	r0, r4
 8001dec:	f7ff ff62 	bl	8001cb4 <HAL_TIM_PWM_PulseFinishedCallback>
 8001df0:	e776      	b.n	8001ce0 <HAL_TIM_IRQHandler+0x28>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001df2:	f7ff ff5d 	bl	8001cb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001df6:	4620      	mov	r0, r4
 8001df8:	f7ff ff5c 	bl	8001cb4 <HAL_TIM_PWM_PulseFinishedCallback>
 8001dfc:	e785      	b.n	8001d0a <HAL_TIM_IRQHandler+0x52>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001dfe:	f7ff ff57 	bl	8001cb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim); 
 8001e02:	4620      	mov	r0, r4
 8001e04:	f7ff ff56 	bl	8001cb4 <HAL_TIM_PWM_PulseFinishedCallback>
 8001e08:	e793      	b.n	8001d32 <HAL_TIM_IRQHandler+0x7a>
        HAL_TIM_OC_DelayElapsedCallback(htim);
 8001e0a:	f7ff ff51 	bl	8001cb0 <HAL_TIM_OC_DelayElapsedCallback>
        HAL_TIM_PWM_PulseFinishedCallback(htim);
 8001e0e:	4620      	mov	r0, r4
 8001e10:	f7ff ff50 	bl	8001cb4 <HAL_TIM_PWM_PulseFinishedCallback>
 8001e14:	e7a2      	b.n	8001d5c <HAL_TIM_IRQHandler+0xa4>
 8001e16:	bd10      	pop	{r4, pc}

08001e18 <TIM_Base_SetConfig>:
{
  uint32_t tmpcr1 = 0U;
  tmpcr1 = TIMx->CR1;
  
  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001e18:	4a32      	ldr	r2, [pc, #200]	; (8001ee4 <TIM_Base_SetConfig+0xcc>)
  tmpcr1 = TIMx->CR1;
 8001e1a:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8001e1c:	4290      	cmp	r0, r2
 8001e1e:	d012      	beq.n	8001e46 <TIM_Base_SetConfig+0x2e>
 8001e20:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001e24:	d00f      	beq.n	8001e46 <TIM_Base_SetConfig+0x2e>
 8001e26:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8001e2a:	4290      	cmp	r0, r2
 8001e2c:	d00b      	beq.n	8001e46 <TIM_Base_SetConfig+0x2e>
 8001e2e:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001e32:	4290      	cmp	r0, r2
 8001e34:	d007      	beq.n	8001e46 <TIM_Base_SetConfig+0x2e>
 8001e36:	f502 3296 	add.w	r2, r2, #76800	; 0x12c00
 8001e3a:	4290      	cmp	r0, r2
 8001e3c:	d003      	beq.n	8001e46 <TIM_Base_SetConfig+0x2e>
 8001e3e:	f502 52e0 	add.w	r2, r2, #7168	; 0x1c00
 8001e42:	4290      	cmp	r0, r2
 8001e44:	d115      	bne.n	8001e72 <TIM_Base_SetConfig+0x5a>
  {
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
 8001e46:	684a      	ldr	r2, [r1, #4]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8001e48:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    tmpcr1 |= Structure->CounterMode;
 8001e4c:	4313      	orrs	r3, r2
  }
 
  if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8001e4e:	4a25      	ldr	r2, [pc, #148]	; (8001ee4 <TIM_Base_SetConfig+0xcc>)
 8001e50:	4290      	cmp	r0, r2
 8001e52:	d01d      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e54:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
 8001e58:	d01a      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e5a:	f5a2 3294 	sub.w	r2, r2, #75776	; 0x12800
 8001e5e:	4290      	cmp	r0, r2
 8001e60:	d016      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e62:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001e66:	4290      	cmp	r0, r2
 8001e68:	d012      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e6a:	f502 3296 	add.w	r2, r2, #76800	; 0x12c00
 8001e6e:	4290      	cmp	r0, r2
 8001e70:	d00e      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e72:	4a1d      	ldr	r2, [pc, #116]	; (8001ee8 <TIM_Base_SetConfig+0xd0>)
 8001e74:	4290      	cmp	r0, r2
 8001e76:	d00b      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e78:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001e7c:	4290      	cmp	r0, r2
 8001e7e:	d007      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e80:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 8001e84:	4290      	cmp	r0, r2
 8001e86:	d003      	beq.n	8001e90 <TIM_Base_SetConfig+0x78>
 8001e88:	f502 6200 	add.w	r2, r2, #2048	; 0x800
 8001e8c:	4290      	cmp	r0, r2
 8001e8e:	d103      	bne.n	8001e98 <TIM_Base_SetConfig+0x80>
  {
    /* Set the clock division */
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e90:	68ca      	ldr	r2, [r1, #12]
    tmpcr1 &= ~TIM_CR1_CKD;
 8001e92:	f423 7340 	bic.w	r3, r3, #768	; 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8001e96:	4313      	orrs	r3, r2
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8001e98:	694a      	ldr	r2, [r1, #20]
 8001e9a:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8001e9e:	4313      	orrs	r3, r2

  TIMx->CR1 = tmpcr1;
 8001ea0:	6003      	str	r3, [r0, #0]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;
 8001ea2:	688b      	ldr	r3, [r1, #8]
 8001ea4:	62c3      	str	r3, [r0, #44]	; 0x2c
 
  /* Set the Prescaler value */
  TIMx->PSC = (uint32_t)Structure->Prescaler;
 8001ea6:	680b      	ldr	r3, [r1, #0]
 8001ea8:	6283      	str	r3, [r0, #40]	; 0x28
    
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))  
 8001eaa:	4b0e      	ldr	r3, [pc, #56]	; (8001ee4 <TIM_Base_SetConfig+0xcc>)
 8001eac:	4298      	cmp	r0, r3
 8001eae:	d013      	beq.n	8001ed8 <TIM_Base_SetConfig+0xc0>
 8001eb0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8001eb4:	4298      	cmp	r0, r3
 8001eb6:	d00f      	beq.n	8001ed8 <TIM_Base_SetConfig+0xc0>
 8001eb8:	f503 6340 	add.w	r3, r3, #3072	; 0xc00
 8001ebc:	4298      	cmp	r0, r3
 8001ebe:	d00b      	beq.n	8001ed8 <TIM_Base_SetConfig+0xc0>
 8001ec0:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ec4:	4298      	cmp	r0, r3
 8001ec6:	d007      	beq.n	8001ed8 <TIM_Base_SetConfig+0xc0>
 8001ec8:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001ecc:	4298      	cmp	r0, r3
 8001ece:	d003      	beq.n	8001ed8 <TIM_Base_SetConfig+0xc0>
 8001ed0:	f503 6300 	add.w	r3, r3, #2048	; 0x800
 8001ed4:	4298      	cmp	r0, r3
 8001ed6:	d101      	bne.n	8001edc <TIM_Base_SetConfig+0xc4>
  {
    /* Set the Repetition Counter value */
    TIMx->RCR = Structure->RepetitionCounter;
 8001ed8:	690b      	ldr	r3, [r1, #16]
 8001eda:	6303      	str	r3, [r0, #48]	; 0x30
  }

  /* Generate an update event to reload the Prescaler 
     and the repetition counter(only for TIM1 and TIM8) value immediatly */
  TIMx->EGR = TIM_EGR_UG;
 8001edc:	2301      	movs	r3, #1
 8001ede:	6143      	str	r3, [r0, #20]
 8001ee0:	4770      	bx	lr
 8001ee2:	bf00      	nop
 8001ee4:	40012c00 	.word	0x40012c00
 8001ee8:	40014000 	.word	0x40014000

08001eec <HAL_TIM_Base_Init>:
{ 
 8001eec:	b510      	push	{r4, lr}
  if(htim == NULL)
 8001eee:	4604      	mov	r4, r0
 8001ef0:	b1a0      	cbz	r0, 8001f1c <HAL_TIM_Base_Init+0x30>
  if(htim->State == HAL_TIM_STATE_RESET)
 8001ef2:	f890 303d 	ldrb.w	r3, [r0, #61]	; 0x3d
 8001ef6:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001efa:	b91b      	cbnz	r3, 8001f04 <HAL_TIM_Base_Init+0x18>
    htim->Lock = HAL_UNLOCKED;
 8001efc:	f880 203c 	strb.w	r2, [r0, #60]	; 0x3c
    HAL_TIM_Base_MspInit(htim);
 8001f00:	f7ff feca 	bl	8001c98 <HAL_TIM_Base_MspInit>
  htim->State= HAL_TIM_STATE_BUSY;
 8001f04:	2302      	movs	r3, #2
 8001f06:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  TIM_Base_SetConfig(htim->Instance, &htim->Init); 
 8001f0a:	6820      	ldr	r0, [r4, #0]
 8001f0c:	1d21      	adds	r1, r4, #4
 8001f0e:	f7ff ff83 	bl	8001e18 <TIM_Base_SetConfig>
  htim->State= HAL_TIM_STATE_READY;
 8001f12:	2301      	movs	r3, #1
 8001f14:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
  return HAL_OK;
 8001f18:	2000      	movs	r0, #0
 8001f1a:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001f1c:	2001      	movs	r0, #1
}
 8001f1e:	bd10      	pop	{r4, pc}

08001f20 <HAL_TIMEx_CommutationCallback>:
 8001f20:	4770      	bx	lr

08001f22 <HAL_TIMEx_BreakCallback>:
 8001f22:	4770      	bx	lr

08001f24 <HAL_TIMEx_Break2Callback>:
  * @brief  Hall Break2 detection callback in non blocking mode
  * @param  htim: TIM handle
  * @retval None
  */
__weak void HAL_TIMEx_Break2Callback(TIM_HandleTypeDef *htim)
{
 8001f24:	4770      	bx	lr
	...

08001f28 <USBD_AUDIO_GetCfgDesc>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_AUDIO_GetCfgDesc (uint16_t *length)
{
  *length = sizeof (USBD_AUDIO_CfgDesc);
 8001f28:	236d      	movs	r3, #109	; 0x6d
 8001f2a:	8003      	strh	r3, [r0, #0]
  return USBD_AUDIO_CfgDesc;
}
 8001f2c:	4800      	ldr	r0, [pc, #0]	; (8001f30 <USBD_AUDIO_GetCfgDesc+0x8>)
 8001f2e:	4770      	bx	lr
 8001f30:	2000003c 	.word	0x2000003c

08001f34 <USBD_AUDIO_EP0_RxReady>:
  *         handle EP0 Rx Ready event
  * @param  pdev: device instance
  * @retval status
  */
static uint8_t  USBD_AUDIO_EP0_RxReady (USBD_HandleTypeDef *pdev)
{
 8001f34:	b538      	push	{r3, r4, r5, lr}
  USBD_AUDIO_HandleTypeDef   *haudio;
  haudio = (USBD_AUDIO_HandleTypeDef*) pdev->pClassData;
 8001f36:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
  
  if (haudio->control.cmd == AUDIO_REQ_SET_CUR)
 8001f3a:	f641 358a 	movw	r5, #7050	; 0x1b8a
 8001f3e:	5d63      	ldrb	r3, [r4, r5]
 8001f40:	2b01      	cmp	r3, #1
 8001f42:	d110      	bne.n	8001f66 <USBD_AUDIO_EP0_RxReady+0x32>
  {/* In this driver, to simplify code, only SET_CUR request is managed */

    if (haudio->control.unit == AUDIO_OUT_STREAMING_CTRL)
 8001f44:	f641 33cc 	movw	r3, #7116	; 0x1bcc
 8001f48:	5ce3      	ldrb	r3, [r4, r3]
 8001f4a:	2b02      	cmp	r3, #2
 8001f4c:	d10b      	bne.n	8001f66 <USBD_AUDIO_EP0_RxReady+0x32>
    {
     ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->MuteCtl(haudio->control.data[0]);     
 8001f4e:	f8d0 321c 	ldr.w	r3, [r0, #540]	; 0x21c
 8001f52:	f641 328b 	movw	r2, #7051	; 0x1b8b
 8001f56:	691b      	ldr	r3, [r3, #16]
 8001f58:	5ca0      	ldrb	r0, [r4, r2]
 8001f5a:	4798      	blx	r3
      haudio->control.cmd = 0;
      haudio->control.len = 0;
 8001f5c:	f641 32cb 	movw	r2, #7115	; 0x1bcb
      haudio->control.cmd = 0;
 8001f60:	2300      	movs	r3, #0
 8001f62:	5563      	strb	r3, [r4, r5]
      haudio->control.len = 0;
 8001f64:	54a3      	strb	r3, [r4, r2]
    }
  } 

  return USBD_OK;
}
 8001f66:	2000      	movs	r0, #0
 8001f68:	bd38      	pop	{r3, r4, r5, pc}

08001f6a <USBD_AUDIO_SOF>:
  * @retval status
  */
static uint8_t  USBD_AUDIO_SOF (USBD_HandleTypeDef *pdev)
{
  return USBD_OK;
}
 8001f6a:	2000      	movs	r0, #0
 8001f6c:	4770      	bx	lr

08001f6e <USBD_AUDIO_IsoOutIncomplete>:
  */
static uint8_t  USBD_AUDIO_IsoOutIncomplete (USBD_HandleTypeDef *pdev, uint8_t epnum)
{

  return USBD_OK;
}
 8001f6e:	2000      	movs	r0, #0
 8001f70:	4770      	bx	lr
	...

08001f74 <USBD_AUDIO_GetDeviceQualifierDesc>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_AUDIO_GetDeviceQualifierDesc (uint16_t *length)
{
  *length = sizeof (USBD_AUDIO_DeviceQualifierDesc);
 8001f74:	230a      	movs	r3, #10
 8001f76:	8003      	strh	r3, [r0, #0]
  return USBD_AUDIO_DeviceQualifierDesc;
}
 8001f78:	4800      	ldr	r0, [pc, #0]	; (8001f7c <USBD_AUDIO_GetDeviceQualifierDesc+0x8>)
 8001f7a:	4770      	bx	lr
 8001f7c:	200000ac 	.word	0x200000ac

08001f80 <USBD_AUDIO_DataOut>:
  if (epnum == AUDIO_OUT_EP)
 8001f80:	2901      	cmp	r1, #1
{
 8001f82:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001f84:	460a      	mov	r2, r1
 8001f86:	4605      	mov	r5, r0
  if (epnum == AUDIO_OUT_EP)
 8001f88:	d120      	bne.n	8001fcc <USBD_AUDIO_DataOut+0x4c>
  haudio = (USBD_AUDIO_HandleTypeDef*) pdev->pClassData;
 8001f8a:	f8d0 4218 	ldr.w	r4, [r0, #536]	; 0x218
    haudio->wr_ptr += AUDIO_OUT_PACKET;
 8001f8e:	f641 3088 	movw	r0, #7048	; 0x1b88
 8001f92:	5a23      	ldrh	r3, [r4, r0]
 8001f94:	3358      	adds	r3, #88	; 0x58
 8001f96:	b29b      	uxth	r3, r3
    if (haudio->wr_ptr == AUDIO_TOTAL_BUF_SIZE)
 8001f98:	f5b3 5fdc 	cmp.w	r3, #7040	; 0x1b80
 8001f9c:	d018      	beq.n	8001fd0 <USBD_AUDIO_DataOut+0x50>
    haudio->wr_ptr += AUDIO_OUT_PACKET;
 8001f9e:	5223      	strh	r3, [r4, r0]
    if(haudio->rd_enable == 0)
 8001fa0:	f641 3385 	movw	r3, #7045	; 0x1b85
 8001fa4:	5ce2      	ldrb	r2, [r4, r3]
 8001fa6:	b93a      	cbnz	r2, 8001fb8 <USBD_AUDIO_DataOut+0x38>
      if (haudio->wr_ptr == (AUDIO_TOTAL_BUF_SIZE / 2))
 8001fa8:	f641 3288 	movw	r2, #7048	; 0x1b88
 8001fac:	5aa2      	ldrh	r2, [r4, r2]
 8001fae:	f5b2 6f5c 	cmp.w	r2, #3520	; 0xdc0
        haudio->rd_enable = 1; 
 8001fb2:	bf04      	itt	eq
 8001fb4:	2201      	moveq	r2, #1
 8001fb6:	54e2      	strbeq	r2, [r4, r3]
                           &haudio->buffer[haudio->wr_ptr], 
 8001fb8:	f641 3388 	movw	r3, #7048	; 0x1b88
    USBD_LL_PrepareReceive(pdev,
 8001fbc:	2101      	movs	r1, #1
 8001fbe:	5ae2      	ldrh	r2, [r4, r3]
 8001fc0:	3204      	adds	r2, #4
 8001fc2:	2358      	movs	r3, #88	; 0x58
 8001fc4:	4422      	add	r2, r4
 8001fc6:	4628      	mov	r0, r5
 8001fc8:	f001 fc52 	bl	8003870 <USBD_LL_PrepareReceive>
}
 8001fcc:	2000      	movs	r0, #0
 8001fce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if(haudio->offset == AUDIO_OFFSET_UNKNOWN)
 8001fd0:	f641 3684 	movw	r6, #7044	; 0x1b84
      haudio->wr_ptr = 0;
 8001fd4:	2700      	movs	r7, #0
      if(haudio->offset == AUDIO_OFFSET_UNKNOWN)
 8001fd6:	5da3      	ldrb	r3, [r4, r6]
      haudio->wr_ptr = 0;
 8001fd8:	5227      	strh	r7, [r4, r0]
      if(haudio->offset == AUDIO_OFFSET_UNKNOWN)
 8001fda:	2b03      	cmp	r3, #3
 8001fdc:	d1e0      	bne.n	8001fa0 <USBD_AUDIO_DataOut+0x20>
        ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->AudioCmd(&haudio->buffer[0],
 8001fde:	f8d5 321c 	ldr.w	r3, [r5, #540]	; 0x21c
 8001fe2:	f44f 615c 	mov.w	r1, #3520	; 0xdc0
 8001fe6:	689b      	ldr	r3, [r3, #8]
 8001fe8:	1d20      	adds	r0, r4, #4
 8001fea:	4798      	blx	r3
          haudio->offset = AUDIO_OFFSET_NONE;
 8001fec:	55a7      	strb	r7, [r4, r6]
 8001fee:	e7d7      	b.n	8001fa0 <USBD_AUDIO_DataOut+0x20>

08001ff0 <USBD_AUDIO_DeInit>:
{
 8001ff0:	b510      	push	{r4, lr}
 8001ff2:	4604      	mov	r4, r0
  USBD_LL_CloseEP(pdev,
 8001ff4:	2101      	movs	r1, #1
 8001ff6:	f001 fbe1 	bl	80037bc <USBD_LL_CloseEP>
  if(pdev->pClassData != NULL)
 8001ffa:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
 8001ffe:	b15b      	cbz	r3, 8002018 <USBD_AUDIO_DeInit+0x28>
   ((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->DeInit(0);
 8002000:	f8d4 321c 	ldr.w	r3, [r4, #540]	; 0x21c
 8002004:	2000      	movs	r0, #0
 8002006:	685b      	ldr	r3, [r3, #4]
 8002008:	4798      	blx	r3
    USBD_free(pdev->pClassData);
 800200a:	f8d4 0218 	ldr.w	r0, [r4, #536]	; 0x218
 800200e:	f001 fc41 	bl	8003894 <USBD_static_free>
    pdev->pClassData = NULL;
 8002012:	2300      	movs	r3, #0
 8002014:	f8c4 3218 	str.w	r3, [r4, #536]	; 0x218
}
 8002018:	2000      	movs	r0, #0
 800201a:	bd10      	pop	{r4, pc}

0800201c <USBD_AUDIO_Init>:
  USBD_LL_OpenEP(pdev,
 800201c:	2201      	movs	r2, #1
{
 800201e:	b570      	push	{r4, r5, r6, lr}
  USBD_LL_OpenEP(pdev,
 8002020:	2358      	movs	r3, #88	; 0x58
 8002022:	4611      	mov	r1, r2
{
 8002024:	4606      	mov	r6, r0
  USBD_LL_OpenEP(pdev,
 8002026:	f001 fbb9 	bl	800379c <USBD_LL_OpenEP>
  pdev->pClassData = USBD_malloc(sizeof (USBD_AUDIO_HandleTypeDef));
 800202a:	f641 30d0 	movw	r0, #7120	; 0x1bd0
 800202e:	f001 fc2d 	bl	800388c <USBD_static_malloc>
 8002032:	4604      	mov	r4, r0
 8002034:	f8c6 0218 	str.w	r0, [r6, #536]	; 0x218
  if(pdev->pClassData == NULL)
 8002038:	b908      	cbnz	r0, 800203e <USBD_AUDIO_Init+0x22>
    return USBD_FAIL; 
 800203a:	2002      	movs	r0, #2
 800203c:	bd70      	pop	{r4, r5, r6, pc}
    haudio->offset = AUDIO_OFFSET_UNKNOWN;
 800203e:	f641 3384 	movw	r3, #7044	; 0x1b84
    haudio->alt_setting = 0;
 8002042:	2200      	movs	r2, #0
    haudio->offset = AUDIO_OFFSET_UNKNOWN;
 8002044:	2103      	movs	r1, #3
    haudio->alt_setting = 0;
 8002046:	6002      	str	r2, [r0, #0]
    haudio->offset = AUDIO_OFFSET_UNKNOWN;
 8002048:	54c1      	strb	r1, [r0, r3]
    haudio->wr_ptr = 0; 
 800204a:	f641 3388 	movw	r3, #7048	; 0x1b88
    if (((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Init(USBD_AUDIO_FREQ, AUDIO_DEFAULT_VOLUME, 0) != USBD_OK)
 800204e:	2146      	movs	r1, #70	; 0x46
    haudio->wr_ptr = 0; 
 8002050:	52c2      	strh	r2, [r0, r3]
    haudio->rd_ptr = 0;  
 8002052:	f641 3386 	movw	r3, #7046	; 0x1b86
 8002056:	52c2      	strh	r2, [r0, r3]
    haudio->rd_enable = 0;
 8002058:	f641 3385 	movw	r3, #7045	; 0x1b85
 800205c:	54c2      	strb	r2, [r0, r3]
    if (((USBD_AUDIO_ItfTypeDef *)pdev->pUserData)->Init(USBD_AUDIO_FREQ, AUDIO_DEFAULT_VOLUME, 0) != USBD_OK)
 800205e:	f8d6 321c 	ldr.w	r3, [r6, #540]	; 0x21c
 8002062:	f245 6054 	movw	r0, #22100	; 0x5654
 8002066:	681b      	ldr	r3, [r3, #0]
 8002068:	4798      	blx	r3
 800206a:	4605      	mov	r5, r0
 800206c:	2800      	cmp	r0, #0
 800206e:	d1e4      	bne.n	800203a <USBD_AUDIO_Init+0x1e>
    USBD_LL_PrepareReceive(pdev,
 8002070:	2358      	movs	r3, #88	; 0x58
 8002072:	1d22      	adds	r2, r4, #4
 8002074:	2101      	movs	r1, #1
 8002076:	4630      	mov	r0, r6
 8002078:	f001 fbfa 	bl	8003870 <USBD_LL_PrepareReceive>
  return USBD_OK;
 800207c:	4628      	mov	r0, r5
}
 800207e:	bd70      	pop	{r4, r5, r6, pc}

08002080 <USBD_AUDIO_Setup>:
{
 8002080:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002082:	780c      	ldrb	r4, [r1, #0]
  haudio = (USBD_AUDIO_HandleTypeDef*) pdev->pClassData;
 8002084:	f8d0 5218 	ldr.w	r5, [r0, #536]	; 0x218
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002088:	f014 0460 	ands.w	r4, r4, #96	; 0x60
{
 800208c:	4607      	mov	r7, r0
 800208e:	460e      	mov	r6, r1
  switch (req->bmRequest & USB_REQ_TYPE_MASK)
 8002090:	d029      	beq.n	80020e6 <USBD_AUDIO_Setup+0x66>
 8002092:	2c20      	cmp	r4, #32
 8002094:	d111      	bne.n	80020ba <USBD_AUDIO_Setup+0x3a>
    switch (req->bRequest)
 8002096:	784c      	ldrb	r4, [r1, #1]
 8002098:	2c01      	cmp	r4, #1
 800209a:	d010      	beq.n	80020be <USBD_AUDIO_Setup+0x3e>
 800209c:	2c81      	cmp	r4, #129	; 0x81
 800209e:	d141      	bne.n	8002124 <USBD_AUDIO_Setup+0xa4>
  memset(haudio->control.data, 0, 64);
 80020a0:	f505 55dc 	add.w	r5, r5, #7040	; 0x1b80
 80020a4:	350b      	adds	r5, #11
 80020a6:	2240      	movs	r2, #64	; 0x40
 80020a8:	2100      	movs	r1, #0
 80020aa:	4628      	mov	r0, r5
 80020ac:	f001 fc94 	bl	80039d8 <memset>
  USBD_CtlSendData (pdev, 
 80020b0:	88f2      	ldrh	r2, [r6, #6]
 80020b2:	4629      	mov	r1, r5
 80020b4:	4638      	mov	r0, r7
 80020b6:	f000 fb21 	bl	80026fc <USBD_CtlSendData>
  uint8_t ret = USBD_OK;
 80020ba:	2400      	movs	r4, #0
 80020bc:	e025      	b.n	800210a <USBD_AUDIO_Setup+0x8a>
  if (req->wLength)
 80020be:	88ca      	ldrh	r2, [r1, #6]
 80020c0:	b3a2      	cbz	r2, 800212c <USBD_AUDIO_Setup+0xac>
    USBD_CtlPrepareRx (pdev,
 80020c2:	f505 51dc 	add.w	r1, r5, #7040	; 0x1b80
 80020c6:	310b      	adds	r1, #11
 80020c8:	f000 fb2d 	bl	8002726 <USBD_CtlPrepareRx>
    haudio->control.cmd = AUDIO_REQ_SET_CUR;     /* Set the request value */
 80020cc:	f641 338a 	movw	r3, #7050	; 0x1b8a
 80020d0:	54ec      	strb	r4, [r5, r3]
    haudio->control.len = req->wLength;          /* Set the request data length */
 80020d2:	f641 33cb 	movw	r3, #7115	; 0x1bcb
 80020d6:	88f2      	ldrh	r2, [r6, #6]
 80020d8:	54ea      	strb	r2, [r5, r3]
    haudio->control.unit = HIBYTE(req->wIndex);  /* Set the request target unit */
 80020da:	88b3      	ldrh	r3, [r6, #4]
 80020dc:	f641 32cc 	movw	r2, #7116	; 0x1bcc
 80020e0:	0a1b      	lsrs	r3, r3, #8
 80020e2:	54ab      	strb	r3, [r5, r2]
 80020e4:	e7e9      	b.n	80020ba <USBD_AUDIO_Setup+0x3a>
    switch (req->bRequest)
 80020e6:	784b      	ldrb	r3, [r1, #1]
 80020e8:	2b0a      	cmp	r3, #10
 80020ea:	d010      	beq.n	800210e <USBD_AUDIO_Setup+0x8e>
 80020ec:	2b0b      	cmp	r3, #11
 80020ee:	d011      	beq.n	8002114 <USBD_AUDIO_Setup+0x94>
 80020f0:	2b06      	cmp	r3, #6
 80020f2:	d117      	bne.n	8002124 <USBD_AUDIO_Setup+0xa4>
      if( (req->wValue >> 8) == AUDIO_DESCRIPTOR_TYPE)
 80020f4:	884b      	ldrh	r3, [r1, #2]
 80020f6:	0a1b      	lsrs	r3, r3, #8
 80020f8:	2b21      	cmp	r3, #33	; 0x21
 80020fa:	d106      	bne.n	800210a <USBD_AUDIO_Setup+0x8a>
        len = MIN(USB_AUDIO_DESC_SIZ , req->wLength);
 80020fc:	88ca      	ldrh	r2, [r1, #6]
        USBD_CtlSendData (pdev, 
 80020fe:	490c      	ldr	r1, [pc, #48]	; (8002130 <USBD_AUDIO_Setup+0xb0>)
 8002100:	2a09      	cmp	r2, #9
 8002102:	bf28      	it	cs
 8002104:	2209      	movcs	r2, #9
      USBD_CtlSendData (pdev,
 8002106:	f000 faf9 	bl	80026fc <USBD_CtlSendData>
}
 800210a:	4620      	mov	r0, r4
 800210c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      USBD_CtlSendData (pdev,
 800210e:	2201      	movs	r2, #1
 8002110:	4629      	mov	r1, r5
 8002112:	e7f8      	b.n	8002106 <USBD_AUDIO_Setup+0x86>
      if ((uint8_t)(req->wValue) <= USBD_MAX_NUM_INTERFACES)
 8002114:	788b      	ldrb	r3, [r1, #2]
 8002116:	2b01      	cmp	r3, #1
 8002118:	d801      	bhi.n	800211e <USBD_AUDIO_Setup+0x9e>
        haudio->alt_setting = (uint8_t)(req->wValue);
 800211a:	602b      	str	r3, [r5, #0]
 800211c:	e7f5      	b.n	800210a <USBD_AUDIO_Setup+0x8a>
        USBD_CtlError (pdev, req);
 800211e:	f000 fac6 	bl	80026ae <USBD_CtlError>
 8002122:	e7f2      	b.n	800210a <USBD_AUDIO_Setup+0x8a>
      USBD_CtlError (pdev, req);
 8002124:	f000 fac3 	bl	80026ae <USBD_CtlError>
      ret = USBD_FAIL;     
 8002128:	2402      	movs	r4, #2
 800212a:	e7ee      	b.n	800210a <USBD_AUDIO_Setup+0x8a>
  uint8_t ret = USBD_OK;
 800212c:	4614      	mov	r4, r2
 800212e:	e7ec      	b.n	800210a <USBD_AUDIO_Setup+0x8a>
 8002130:	2000004e 	.word	0x2000004e

08002134 <USBD_AUDIO_DataIn>:
 8002134:	2000      	movs	r0, #0
 8002136:	4770      	bx	lr

08002138 <USBD_AUDIO_IsoINIncomplete>:
 8002138:	2000      	movs	r0, #0
 800213a:	4770      	bx	lr

0800213c <USBD_AUDIO_EP0_TxReady>:
 800213c:	2000      	movs	r0, #0
 800213e:	4770      	bx	lr

08002140 <USBD_AUDIO_RegisterInterface>:
* @retval status
*/
uint8_t  USBD_AUDIO_RegisterInterface  (USBD_HandleTypeDef   *pdev, 
                                        USBD_AUDIO_ItfTypeDef *fops)
{
  if(fops != NULL)
 8002140:	b109      	cbz	r1, 8002146 <USBD_AUDIO_RegisterInterface+0x6>
  {
    pdev->pUserData= fops;
 8002142:	f8c0 121c 	str.w	r1, [r0, #540]	; 0x21c
  }
  return 0;
}
 8002146:	2000      	movs	r0, #0
 8002148:	4770      	bx	lr

0800214a <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
 800214a:	b508      	push	{r3, lr}
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
 800214c:	b180      	cbz	r0, 8002170 <USBD_Init+0x26>
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }
  
  /* Unlink previous class*/
  if(pdev->pClass != NULL)
 800214e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002152:	b113      	cbz	r3, 800215a <USBD_Init+0x10>
  {
    pdev->pClass = NULL;
 8002154:	2300      	movs	r3, #0
 8002156:	f8c0 3214 	str.w	r3, [r0, #532]	; 0x214
  }
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
 800215a:	b109      	cbz	r1, 8002160 <USBD_Init+0x16>
  {
    pdev->pDesc = pdesc;
 800215c:	f8c0 1210 	str.w	r1, [r0, #528]	; 0x210
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
 8002160:	2301      	movs	r3, #1
 8002162:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  pdev->id = id;
 8002166:	7002      	strb	r2, [r0, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
 8002168:	f001 fad8 	bl	800371c <USBD_LL_Init>
  
  return USBD_OK; 
 800216c:	2000      	movs	r0, #0
 800216e:	bd08      	pop	{r3, pc}
    return USBD_FAIL; 
 8002170:	2002      	movs	r0, #2
}
 8002172:	bd08      	pop	{r3, pc}

08002174 <USBD_RegisterClass>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_RegisterClass(USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
 8002174:	b119      	cbz	r1, 800217e <USBD_RegisterClass+0xa>
  {
    /* link the class to the USB Device handle */
    pdev->pClass = pclass;
 8002176:	f8c0 1214 	str.w	r1, [r0, #532]	; 0x214
    status = USBD_OK;
 800217a:	2000      	movs	r0, #0
 800217c:	4770      	bx	lr
  }
  else
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
 800217e:	2002      	movs	r0, #2
  }
  
  return status;
}
 8002180:	4770      	bx	lr

08002182 <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
 8002182:	b508      	push	{r3, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
 8002184:	f001 fafc 	bl	8003780 <USBD_LL_Start>
  
  return USBD_OK;  
}
 8002188:	2000      	movs	r0, #0
 800218a:	bd08      	pop	{r3, pc}

0800218c <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 800218c:	b508      	push	{r3, lr}
  USBD_StatusTypeDef   ret = USBD_FAIL;
  
  if(pdev->pClass != NULL)
 800218e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002192:	b90b      	cbnz	r3, 8002198 <USBD_SetClassConfig+0xc>
  USBD_StatusTypeDef   ret = USBD_FAIL;
 8002194:	2002      	movs	r0, #2
 8002196:	bd08      	pop	{r3, pc}
  {
    /* Set configuration  and Start the Class*/
    if(pdev->pClass->Init(pdev, cfgidx) == 0)
 8002198:	681b      	ldr	r3, [r3, #0]
 800219a:	4798      	blx	r3
 800219c:	2800      	cmp	r0, #0
 800219e:	d1f9      	bne.n	8002194 <USBD_SetClassConfig+0x8>
    {
      ret = USBD_OK;
    }
  }
  return ret; 
}
 80021a0:	bd08      	pop	{r3, pc}

080021a2 <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
 80021a2:	b508      	push	{r3, lr}
  /* Clear configuration  and De-initialize the Class process*/
  pdev->pClass->DeInit(pdev, cfgidx);  
 80021a4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80021a8:	685b      	ldr	r3, [r3, #4]
 80021aa:	4798      	blx	r3
  return USBD_OK;
}
 80021ac:	2000      	movs	r0, #0
 80021ae:	bd08      	pop	{r3, pc}

080021b0 <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
 80021b0:	b538      	push	{r3, r4, r5, lr}
 80021b2:	4604      	mov	r4, r0

  USBD_ParseSetupRequest(&pdev->request, psetup);
 80021b4:	f500 7502 	add.w	r5, r0, #520	; 0x208
 80021b8:	4628      	mov	r0, r5
 80021ba:	f000 fa64 	bl	8002686 <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
 80021be:	2301      	movs	r3, #1
  pdev->ep0_data_len = pdev->request.wLength;
  
  switch (pdev->request.bmRequest & 0x1F) 
 80021c0:	f894 1208 	ldrb.w	r1, [r4, #520]	; 0x208
  pdev->ep0_state = USBD_EP0_SETUP;
 80021c4:	f8c4 31f4 	str.w	r3, [r4, #500]	; 0x1f4
  pdev->ep0_data_len = pdev->request.wLength;
 80021c8:	f8b4 320e 	ldrh.w	r3, [r4, #526]	; 0x20e
 80021cc:	f8c4 31f8 	str.w	r3, [r4, #504]	; 0x1f8
  switch (pdev->request.bmRequest & 0x1F) 
 80021d0:	f001 031f 	and.w	r3, r1, #31
 80021d4:	2b01      	cmp	r3, #1
 80021d6:	d00e      	beq.n	80021f6 <USBD_LL_SetupStage+0x46>
 80021d8:	d307      	bcc.n	80021ea <USBD_LL_SetupStage+0x3a>
 80021da:	2b02      	cmp	r3, #2
 80021dc:	d010      	beq.n	8002200 <USBD_LL_SetupStage+0x50>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
 80021de:	f001 0180 	and.w	r1, r1, #128	; 0x80
 80021e2:	4620      	mov	r0, r4
 80021e4:	f001 faf8 	bl	80037d8 <USBD_LL_StallEP>
    break;
 80021e8:	e003      	b.n	80021f2 <USBD_LL_SetupStage+0x42>
    USBD_StdDevReq (pdev, &pdev->request);
 80021ea:	4629      	mov	r1, r5
 80021ec:	4620      	mov	r0, r4
 80021ee:	f000 f8d5 	bl	800239c <USBD_StdDevReq>
  }  
  return USBD_OK;  
}
 80021f2:	2000      	movs	r0, #0
 80021f4:	bd38      	pop	{r3, r4, r5, pc}
    USBD_StdItfReq(pdev, &pdev->request);
 80021f6:	4629      	mov	r1, r5
 80021f8:	4620      	mov	r0, r4
 80021fa:	f000 f9c9 	bl	8002590 <USBD_StdItfReq>
    break;
 80021fe:	e7f8      	b.n	80021f2 <USBD_LL_SetupStage+0x42>
    USBD_StdEPReq(pdev, &pdev->request);   
 8002200:	4629      	mov	r1, r5
 8002202:	4620      	mov	r0, r4
 8002204:	f000 f9dc 	bl	80025c0 <USBD_StdEPReq>
    break;
 8002208:	e7f3      	b.n	80021f2 <USBD_LL_SetupStage+0x42>

0800220a <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
 800220a:	b538      	push	{r3, r4, r5, lr}
 800220c:	4604      	mov	r4, r0
 800220e:	4615      	mov	r5, r2
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
 8002210:	bb11      	cbnz	r1, 8002258 <USBD_LL_DataOutStage+0x4e>
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
 8002212:	f8d0 31f4 	ldr.w	r3, [r0, #500]	; 0x1f4
 8002216:	2b03      	cmp	r3, #3
 8002218:	d10f      	bne.n	800223a <USBD_LL_DataOutStage+0x30>
    {
      if(pep->rem_length > pep->maxpacket)
 800221a:	f8d0 310c 	ldr.w	r3, [r0, #268]	; 0x10c
 800221e:	f8d0 2110 	ldr.w	r2, [r0, #272]	; 0x110
 8002222:	4293      	cmp	r3, r2
 8002224:	d90b      	bls.n	800223e <USBD_LL_DataOutStage+0x34>
      {
        pep->rem_length -=  pep->maxpacket;
 8002226:	1a9b      	subs	r3, r3, r2
       
        USBD_CtlContinueRx (pdev, 
                            pdata,
                            MIN(pep->rem_length ,pep->maxpacket));
 8002228:	429a      	cmp	r2, r3
 800222a:	bf28      	it	cs
 800222c:	461a      	movcs	r2, r3
        pep->rem_length -=  pep->maxpacket;
 800222e:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
        USBD_CtlContinueRx (pdev, 
 8002232:	b292      	uxth	r2, r2
 8002234:	4629      	mov	r1, r5
 8002236:	f000 fa85 	bl	8002744 <USBD_CtlContinueRx>
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataOut(pdev, epnum); 
  }  
  return USBD_OK;
}
 800223a:	2000      	movs	r0, #0
 800223c:	bd38      	pop	{r3, r4, r5, pc}
        if((pdev->pClass->EP0_RxReady != NULL)&&
 800223e:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002242:	691b      	ldr	r3, [r3, #16]
 8002244:	b123      	cbz	r3, 8002250 <USBD_LL_DataOutStage+0x46>
 8002246:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 800224a:	2a03      	cmp	r2, #3
 800224c:	d100      	bne.n	8002250 <USBD_LL_DataOutStage+0x46>
          pdev->pClass->EP0_RxReady(pdev); 
 800224e:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8002250:	4620      	mov	r0, r4
 8002252:	f000 fa7f 	bl	8002754 <USBD_CtlSendStatus>
 8002256:	e7f0      	b.n	800223a <USBD_LL_DataOutStage+0x30>
  else if((pdev->pClass->DataOut != NULL)&&
 8002258:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800225c:	699b      	ldr	r3, [r3, #24]
 800225e:	2b00      	cmp	r3, #0
 8002260:	d0eb      	beq.n	800223a <USBD_LL_DataOutStage+0x30>
 8002262:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002266:	2a03      	cmp	r2, #3
 8002268:	d1e7      	bne.n	800223a <USBD_LL_DataOutStage+0x30>
    pdev->pClass->DataOut(pdev, epnum); 
 800226a:	4798      	blx	r3
 800226c:	e7e5      	b.n	800223a <USBD_LL_DataOutStage+0x30>

0800226e <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
 800226e:	b570      	push	{r4, r5, r6, lr}
 8002270:	4613      	mov	r3, r2
 8002272:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
    
  if(epnum == 0) 
 8002274:	460e      	mov	r6, r1
 8002276:	2900      	cmp	r1, #0
 8002278:	d13d      	bne.n	80022f6 <USBD_LL_DataInStage+0x88>
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
 800227a:	f8d0 21f4 	ldr.w	r2, [r0, #500]	; 0x1f4
 800227e:	2a02      	cmp	r2, #2
 8002280:	d10f      	bne.n	80022a2 <USBD_LL_DataInStage+0x34>
    {
      if(pep->rem_length > pep->maxpacket)
 8002282:	69c5      	ldr	r5, [r0, #28]
 8002284:	6a02      	ldr	r2, [r0, #32]
 8002286:	4295      	cmp	r5, r2
 8002288:	d914      	bls.n	80022b4 <USBD_LL_DataInStage+0x46>
      {
        pep->rem_length -=  pep->maxpacket;
 800228a:	1aaa      	subs	r2, r5, r2
 800228c:	61c2      	str	r2, [r0, #28]
        
        USBD_CtlContinueSendData (pdev, 
 800228e:	4619      	mov	r1, r3
 8002290:	b292      	uxth	r2, r2
 8002292:	f000 fa40 	bl	8002716 <USBD_CtlContinueSendData>
                                  pdata, 
                                  pep->rem_length);
        
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8002296:	4633      	mov	r3, r6
          
          USBD_CtlContinueSendData(pdev , NULL, 0);
          pdev->ep0_data_len = 0;
          
        /* Prepare endpoint for premature end of transfer */
        USBD_LL_PrepareReceive (pdev,
 8002298:	461a      	mov	r2, r3
 800229a:	4619      	mov	r1, r3
 800229c:	4620      	mov	r0, r4
 800229e:	f001 fae7 	bl	8003870 <USBD_LL_PrepareReceive>
          }          
          USBD_CtlReceiveStatus(pdev);
        }
      }
    }
    if (pdev->dev_test_mode == 1)
 80022a2:	f894 3200 	ldrb.w	r3, [r4, #512]	; 0x200
 80022a6:	2b01      	cmp	r3, #1
 80022a8:	d102      	bne.n	80022b0 <USBD_LL_DataInStage+0x42>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
 80022aa:	2300      	movs	r3, #0
 80022ac:	f884 3200 	strb.w	r3, [r4, #512]	; 0x200
          (pdev->dev_state == USBD_STATE_CONFIGURED))
  {
    pdev->pClass->DataIn(pdev, epnum); 
  }  
  return USBD_OK;
}
 80022b0:	2000      	movs	r0, #0
 80022b2:	bd70      	pop	{r4, r5, r6, pc}
        if((pep->total_length % pep->maxpacket == 0) &&
 80022b4:	6983      	ldr	r3, [r0, #24]
 80022b6:	fbb3 f5f2 	udiv	r5, r3, r2
 80022ba:	fb02 3515 	mls	r5, r2, r5, r3
 80022be:	b965      	cbnz	r5, 80022da <USBD_LL_DataInStage+0x6c>
 80022c0:	429a      	cmp	r2, r3
 80022c2:	d80a      	bhi.n	80022da <USBD_LL_DataInStage+0x6c>
           (pep->total_length >= pep->maxpacket) &&
 80022c4:	f8d0 21f8 	ldr.w	r2, [r0, #504]	; 0x1f8
 80022c8:	4293      	cmp	r3, r2
 80022ca:	d206      	bcs.n	80022da <USBD_LL_DataInStage+0x6c>
          USBD_CtlContinueSendData(pdev , NULL, 0);
 80022cc:	462a      	mov	r2, r5
 80022ce:	f000 fa22 	bl	8002716 <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
 80022d2:	f8c4 51f8 	str.w	r5, [r4, #504]	; 0x1f8
        USBD_LL_PrepareReceive (pdev,
 80022d6:	462b      	mov	r3, r5
 80022d8:	e7de      	b.n	8002298 <USBD_LL_DataInStage+0x2a>
          if((pdev->pClass->EP0_TxSent != NULL)&&
 80022da:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 80022de:	68db      	ldr	r3, [r3, #12]
 80022e0:	b12b      	cbz	r3, 80022ee <USBD_LL_DataInStage+0x80>
 80022e2:	f894 21fc 	ldrb.w	r2, [r4, #508]	; 0x1fc
 80022e6:	2a03      	cmp	r2, #3
 80022e8:	d101      	bne.n	80022ee <USBD_LL_DataInStage+0x80>
            pdev->pClass->EP0_TxSent(pdev); 
 80022ea:	4620      	mov	r0, r4
 80022ec:	4798      	blx	r3
          USBD_CtlReceiveStatus(pdev);
 80022ee:	4620      	mov	r0, r4
 80022f0:	f000 fa3b 	bl	800276a <USBD_CtlReceiveStatus>
 80022f4:	e7d5      	b.n	80022a2 <USBD_LL_DataInStage+0x34>
  else if((pdev->pClass->DataIn != NULL)&& 
 80022f6:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80022fa:	695b      	ldr	r3, [r3, #20]
 80022fc:	2b00      	cmp	r3, #0
 80022fe:	d0d7      	beq.n	80022b0 <USBD_LL_DataInStage+0x42>
 8002300:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002304:	2a03      	cmp	r2, #3
 8002306:	d1d3      	bne.n	80022b0 <USBD_LL_DataInStage+0x42>
    pdev->pClass->DataIn(pdev, epnum); 
 8002308:	4798      	blx	r3
 800230a:	e7d1      	b.n	80022b0 <USBD_LL_DataInStage+0x42>

0800230c <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
 800230c:	b538      	push	{r3, r4, r5, lr}
  /* Open EP0 OUT */
  USBD_LL_OpenEP(pdev,
 800230e:	2200      	movs	r2, #0
{
 8002310:	4604      	mov	r4, r0
  USBD_LL_OpenEP(pdev,
 8002312:	4611      	mov	r1, r2
              0x00,
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 8002314:	2540      	movs	r5, #64	; 0x40
  USBD_LL_OpenEP(pdev,
 8002316:	2340      	movs	r3, #64	; 0x40
 8002318:	f001 fa40 	bl	800379c <USBD_LL_OpenEP>
  
  /* Open EP0 IN */
  USBD_LL_OpenEP(pdev,
 800231c:	462b      	mov	r3, r5
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
 800231e:	f8c4 5110 	str.w	r5, [r4, #272]	; 0x110
  USBD_LL_OpenEP(pdev,
 8002322:	2200      	movs	r2, #0
 8002324:	2180      	movs	r1, #128	; 0x80
 8002326:	4620      	mov	r0, r4
 8002328:	f001 fa38 	bl	800379c <USBD_LL_OpenEP>
              USBD_EP_TYPE_CTRL,
              USB_MAX_EP0_SIZE);
  
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 800232c:	2301      	movs	r3, #1
 800232e:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
  
  if (pdev->pClassData) 
 8002332:	f8d4 3218 	ldr.w	r3, [r4, #536]	; 0x218
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
 8002336:	6225      	str	r5, [r4, #32]
  if (pdev->pClassData) 
 8002338:	b12b      	cbz	r3, 8002346 <USBD_LL_Reset+0x3a>
    pdev->pClass->DeInit(pdev, pdev->dev_config);  
 800233a:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800233e:	7921      	ldrb	r1, [r4, #4]
 8002340:	685b      	ldr	r3, [r3, #4]
 8002342:	4620      	mov	r0, r4
 8002344:	4798      	blx	r3
 
  
  return USBD_OK;
}
 8002346:	2000      	movs	r0, #0
 8002348:	bd38      	pop	{r3, r4, r5, pc}

0800234a <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
 800234a:	7401      	strb	r1, [r0, #16]
  return USBD_OK;
}
 800234c:	2000      	movs	r0, #0
 800234e:	4770      	bx	lr

08002350 <USBD_LL_Suspend>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Suspend(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_old_state =  pdev->dev_state;
 8002350:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002354:	f880 31fd 	strb.w	r3, [r0, #509]	; 0x1fd
  pdev->dev_state  = USBD_STATE_SUSPENDED;
 8002358:	2304      	movs	r3, #4
 800235a:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 800235e:	2000      	movs	r0, #0
 8002360:	4770      	bx	lr

08002362 <USBD_LL_Resume>:
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  pdev->dev_state = pdev->dev_old_state;  
 8002362:	f890 31fd 	ldrb.w	r3, [r0, #509]	; 0x1fd
 8002366:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
  return USBD_OK;
}
 800236a:	2000      	movs	r0, #0
 800236c:	4770      	bx	lr

0800236e <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
 800236e:	b508      	push	{r3, lr}
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
 8002370:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002374:	2a03      	cmp	r2, #3
 8002376:	d104      	bne.n	8002382 <USBD_LL_SOF+0x14>
  {
    if(pdev->pClass->SOF != NULL)
 8002378:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800237c:	69db      	ldr	r3, [r3, #28]
 800237e:	b103      	cbz	r3, 8002382 <USBD_LL_SOF+0x14>
    {
      pdev->pClass->SOF(pdev);
 8002380:	4798      	blx	r3
    }
  }
  return USBD_OK;
}
 8002382:	2000      	movs	r0, #0
 8002384:	bd08      	pop	{r3, pc}

08002386 <USBD_CtlError.constprop.0>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/

void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 8002386:	b510      	push	{r4, lr}
                            USBD_SetupReqTypedef *req)
{
  USBD_LL_StallEP(pdev , 0x80);
 8002388:	2180      	movs	r1, #128	; 0x80
void USBD_CtlError( USBD_HandleTypeDef *pdev ,
 800238a:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 800238c:	f001 fa24 	bl	80037d8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 8002390:	4620      	mov	r0, r4
 8002392:	2100      	movs	r1, #0
}
 8002394:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0);
 8002398:	f001 ba1e 	b.w	80037d8 <USBD_LL_StallEP>

0800239c <USBD_StdDevReq>:
{
 800239c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  switch (req->bRequest) 
 800239e:	784b      	ldrb	r3, [r1, #1]
{
 80023a0:	4604      	mov	r4, r0
 80023a2:	460d      	mov	r5, r1
  switch (req->bRequest) 
 80023a4:	2b09      	cmp	r3, #9
 80023a6:	d879      	bhi.n	800249c <USBD_StdDevReq+0x100>
 80023a8:	e8df f013 	tbh	[pc, r3, lsl #1]
 80023ac:	00e500c9 	.word	0x00e500c9
 80023b0:	00d90078 	.word	0x00d90078
 80023b4:	006d0078 	.word	0x006d0078
 80023b8:	0078000a 	.word	0x0078000a
 80023bc:	008d00b9 	.word	0x008d00b9
  switch (req->wValue >> 8)
 80023c0:	884b      	ldrh	r3, [r1, #2]
 80023c2:	0a1a      	lsrs	r2, r3, #8
 80023c4:	3a01      	subs	r2, #1
 80023c6:	2a06      	cmp	r2, #6
 80023c8:	d868      	bhi.n	800249c <USBD_StdDevReq+0x100>
 80023ca:	e8df f002 	tbb	[pc, r2]
 80023ce:	1c04      	.short	0x1c04
 80023d0:	49676729 	.word	0x49676729
 80023d4:	52          	.byte	0x52
 80023d5:	00          	.byte	0x00
    pbuf = pdev->pDesc->GetDeviceDescriptor(pdev->dev_speed, &len);
 80023d6:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 80023da:	681b      	ldr	r3, [r3, #0]
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 80023dc:	7c20      	ldrb	r0, [r4, #16]
 80023de:	f10d 0106 	add.w	r1, sp, #6
 80023e2:	4798      	blx	r3
  if((len != 0)&& (req->wLength != 0))
 80023e4:	f8bd 2006 	ldrh.w	r2, [sp, #6]
 80023e8:	2a00      	cmp	r2, #0
 80023ea:	d067      	beq.n	80024bc <USBD_StdDevReq+0x120>
 80023ec:	88eb      	ldrh	r3, [r5, #6]
 80023ee:	2b00      	cmp	r3, #0
 80023f0:	d064      	beq.n	80024bc <USBD_StdDevReq+0x120>
    len = MIN(len , req->wLength);
 80023f2:	429a      	cmp	r2, r3
 80023f4:	bf28      	it	cs
 80023f6:	461a      	movcs	r2, r3
 80023f8:	f8ad 2006 	strh.w	r2, [sp, #6]
    USBD_CtlSendData (pdev, 
 80023fc:	4601      	mov	r1, r0
    USBD_CtlSendData (pdev, 
 80023fe:	4620      	mov	r0, r4
 8002400:	f000 f97c 	bl	80026fc <USBD_CtlSendData>
 8002404:	e05a      	b.n	80024bc <USBD_StdDevReq+0x120>
    if(pdev->dev_speed == USBD_SPEED_HIGH )   
 8002406:	7c02      	ldrb	r2, [r0, #16]
 8002408:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800240c:	b932      	cbnz	r2, 800241c <USBD_StdDevReq+0x80>
      pbuf   = (uint8_t *)pdev->pClass->GetHSConfigDescriptor(&len);
 800240e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 8002410:	f10d 0006 	add.w	r0, sp, #6
 8002414:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_CONFIGURATION;
 8002416:	2302      	movs	r3, #2
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8002418:	7043      	strb	r3, [r0, #1]
 800241a:	e7e3      	b.n	80023e4 <USBD_StdDevReq+0x48>
      pbuf   = (uint8_t *)pdev->pClass->GetFSConfigDescriptor(&len);
 800241c:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800241e:	e7f7      	b.n	8002410 <USBD_StdDevReq+0x74>
    switch ((uint8_t)(req->wValue))
 8002420:	b2db      	uxtb	r3, r3
 8002422:	2b05      	cmp	r3, #5
 8002424:	d83a      	bhi.n	800249c <USBD_StdDevReq+0x100>
 8002426:	e8df f003 	tbb	[pc, r3]
 800242a:	0703      	.short	0x0703
 800242c:	17130f0b 	.word	0x17130f0b
     pbuf = pdev->pDesc->GetLangIDStrDescriptor(pdev->dev_speed, &len);        
 8002430:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002434:	685b      	ldr	r3, [r3, #4]
 8002436:	e7d1      	b.n	80023dc <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetManufacturerStrDescriptor(pdev->dev_speed, &len);
 8002438:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800243c:	689b      	ldr	r3, [r3, #8]
 800243e:	e7cd      	b.n	80023dc <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetProductStrDescriptor(pdev->dev_speed, &len);
 8002440:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002444:	68db      	ldr	r3, [r3, #12]
 8002446:	e7c9      	b.n	80023dc <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetSerialStrDescriptor(pdev->dev_speed, &len);
 8002448:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800244c:	691b      	ldr	r3, [r3, #16]
 800244e:	e7c5      	b.n	80023dc <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetConfigurationStrDescriptor(pdev->dev_speed, &len);
 8002450:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 8002454:	695b      	ldr	r3, [r3, #20]
 8002456:	e7c1      	b.n	80023dc <USBD_StdDevReq+0x40>
      pbuf = pdev->pDesc->GetInterfaceStrDescriptor(pdev->dev_speed, &len);
 8002458:	f8d0 3210 	ldr.w	r3, [r0, #528]	; 0x210
 800245c:	699b      	ldr	r3, [r3, #24]
 800245e:	e7bd      	b.n	80023dc <USBD_StdDevReq+0x40>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8002460:	7c03      	ldrb	r3, [r0, #16]
 8002462:	b9db      	cbnz	r3, 800249c <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetDeviceQualifierDescriptor(&len);
 8002464:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 8002468:	f10d 0006 	add.w	r0, sp, #6
 800246c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800246e:	4798      	blx	r3
 8002470:	e7b8      	b.n	80023e4 <USBD_StdDevReq+0x48>
    if(pdev->dev_speed == USBD_SPEED_HIGH  )   
 8002472:	7c03      	ldrb	r3, [r0, #16]
 8002474:	b993      	cbnz	r3, 800249c <USBD_StdDevReq+0x100>
      pbuf   = (uint8_t *)pdev->pClass->GetOtherSpeedConfigDescriptor(&len);
 8002476:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 800247a:	f10d 0006 	add.w	r0, sp, #6
 800247e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002480:	4798      	blx	r3
      pbuf[1] = USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION;
 8002482:	2307      	movs	r3, #7
 8002484:	e7c8      	b.n	8002418 <USBD_StdDevReq+0x7c>
  if ((req->wIndex == 0) && (req->wLength == 0)) 
 8002486:	888b      	ldrh	r3, [r1, #4]
 8002488:	b943      	cbnz	r3, 800249c <USBD_StdDevReq+0x100>
 800248a:	88cb      	ldrh	r3, [r1, #6]
 800248c:	b933      	cbnz	r3, 800249c <USBD_StdDevReq+0x100>
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800248e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8002492:	788d      	ldrb	r5, [r1, #2]
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 8002494:	2b03      	cmp	r3, #3
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
 8002496:	f005 057f 	and.w	r5, r5, #127	; 0x7f
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
 800249a:	d103      	bne.n	80024a4 <USBD_StdDevReq+0x108>
    USBD_CtlError(pdev , req);
 800249c:	4620      	mov	r0, r4
 800249e:	f7ff ff72 	bl	8002386 <USBD_CtlError.constprop.0>
    break;
 80024a2:	e00b      	b.n	80024bc <USBD_StdDevReq+0x120>
      pdev->dev_address = dev_addr;
 80024a4:	f880 51fe 	strb.w	r5, [r0, #510]	; 0x1fe
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
 80024a8:	4629      	mov	r1, r5
 80024aa:	f001 f9c5 	bl	8003838 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
 80024ae:	4620      	mov	r0, r4
 80024b0:	f000 f950 	bl	8002754 <USBD_CtlSendStatus>
      if (dev_addr != 0) 
 80024b4:	b12d      	cbz	r5, 80024c2 <USBD_StdDevReq+0x126>
        pdev->dev_state  = USBD_STATE_ADDRESSED;
 80024b6:	2302      	movs	r3, #2
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 80024b8:	f884 31fc 	strb.w	r3, [r4, #508]	; 0x1fc
}
 80024bc:	2000      	movs	r0, #0
 80024be:	b003      	add	sp, #12
 80024c0:	bd30      	pop	{r4, r5, pc}
        pdev->dev_state  = USBD_STATE_DEFAULT; 
 80024c2:	2301      	movs	r3, #1
 80024c4:	e7f8      	b.n	80024b8 <USBD_StdDevReq+0x11c>
  cfgidx = (uint8_t)(req->wValue);                 
 80024c6:	7889      	ldrb	r1, [r1, #2]
 80024c8:	4d30      	ldr	r5, [pc, #192]	; (800258c <USBD_StdDevReq+0x1f0>)
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 80024ca:	2901      	cmp	r1, #1
  cfgidx = (uint8_t)(req->wValue);                 
 80024cc:	7029      	strb	r1, [r5, #0]
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
 80024ce:	d8e5      	bhi.n	800249c <USBD_StdDevReq+0x100>
    switch (pdev->dev_state) 
 80024d0:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 80024d4:	2b02      	cmp	r3, #2
 80024d6:	d00c      	beq.n	80024f2 <USBD_StdDevReq+0x156>
 80024d8:	2b03      	cmp	r3, #3
 80024da:	d1df      	bne.n	800249c <USBD_StdDevReq+0x100>
      if (cfgidx == 0) 
 80024dc:	b9b1      	cbnz	r1, 800250c <USBD_StdDevReq+0x170>
        pdev->dev_state = USBD_STATE_ADDRESSED;
 80024de:	2302      	movs	r3, #2
 80024e0:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        pdev->dev_config = cfgidx;          
 80024e4:	6041      	str	r1, [r0, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
 80024e6:	f7ff fe5c 	bl	80021a2 <USBD_ClrClassConfig>
      USBD_CtlSendStatus(pdev);
 80024ea:	4620      	mov	r0, r4
 80024ec:	f000 f932 	bl	8002754 <USBD_CtlSendStatus>
 80024f0:	e7e4      	b.n	80024bc <USBD_StdDevReq+0x120>
      if (cfgidx) 
 80024f2:	2900      	cmp	r1, #0
 80024f4:	d0f9      	beq.n	80024ea <USBD_StdDevReq+0x14e>
        pdev->dev_config = cfgidx;
 80024f6:	2101      	movs	r1, #1
        pdev->dev_state = USBD_STATE_CONFIGURED;
 80024f8:	2303      	movs	r3, #3
        pdev->dev_config = cfgidx;
 80024fa:	6041      	str	r1, [r0, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
 80024fc:	f880 31fc 	strb.w	r3, [r0, #508]	; 0x1fc
        if(USBD_SetClassConfig(pdev , cfgidx) == USBD_FAIL)
 8002500:	4620      	mov	r0, r4
 8002502:	f7ff fe43 	bl	800218c <USBD_SetClassConfig>
 8002506:	2802      	cmp	r0, #2
 8002508:	d1ef      	bne.n	80024ea <USBD_StdDevReq+0x14e>
 800250a:	e7c7      	b.n	800249c <USBD_StdDevReq+0x100>
      else  if (cfgidx != pdev->dev_config) 
 800250c:	6841      	ldr	r1, [r0, #4]
 800250e:	2901      	cmp	r1, #1
 8002510:	d0eb      	beq.n	80024ea <USBD_StdDevReq+0x14e>
        USBD_ClrClassConfig(pdev , pdev->dev_config);
 8002512:	b2c9      	uxtb	r1, r1
 8002514:	f7ff fe45 	bl	80021a2 <USBD_ClrClassConfig>
        pdev->dev_config = cfgidx;
 8002518:	7829      	ldrb	r1, [r5, #0]
 800251a:	6061      	str	r1, [r4, #4]
 800251c:	e7f0      	b.n	8002500 <USBD_StdDevReq+0x164>
  if (req->wLength != 1) 
 800251e:	88ca      	ldrh	r2, [r1, #6]
 8002520:	2a01      	cmp	r2, #1
 8002522:	d1bb      	bne.n	800249c <USBD_StdDevReq+0x100>
    switch (pdev->dev_state )  
 8002524:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002528:	2b02      	cmp	r3, #2
 800252a:	d003      	beq.n	8002534 <USBD_StdDevReq+0x198>
 800252c:	2b03      	cmp	r3, #3
 800252e:	d1b5      	bne.n	800249c <USBD_StdDevReq+0x100>
      USBD_CtlSendData (pdev, 
 8002530:	1d01      	adds	r1, r0, #4
 8002532:	e764      	b.n	80023fe <USBD_StdDevReq+0x62>
      pdev->dev_default_config = 0;
 8002534:	4601      	mov	r1, r0
 8002536:	2300      	movs	r3, #0
 8002538:	f841 3f08 	str.w	r3, [r1, #8]!
 800253c:	e75f      	b.n	80023fe <USBD_StdDevReq+0x62>
  switch (pdev->dev_state) 
 800253e:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002542:	3b02      	subs	r3, #2
 8002544:	2b01      	cmp	r3, #1
 8002546:	d8a9      	bhi.n	800249c <USBD_StdDevReq+0x100>
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
 8002548:	2301      	movs	r3, #1
 800254a:	60c3      	str	r3, [r0, #12]
    if (pdev->dev_remote_wakeup) 
 800254c:	f8d0 3204 	ldr.w	r3, [r0, #516]	; 0x204
 8002550:	b10b      	cbz	r3, 8002556 <USBD_StdDevReq+0x1ba>
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
 8002552:	2303      	movs	r3, #3
 8002554:	60c3      	str	r3, [r0, #12]
    USBD_CtlSendData (pdev, 
 8002556:	2202      	movs	r2, #2
 8002558:	f104 010c 	add.w	r1, r4, #12
 800255c:	e74f      	b.n	80023fe <USBD_StdDevReq+0x62>
  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
 800255e:	884b      	ldrh	r3, [r1, #2]
 8002560:	2b01      	cmp	r3, #1
 8002562:	d1ab      	bne.n	80024bc <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8002564:	f8c4 3204 	str.w	r3, [r4, #516]	; 0x204
      pdev->pClass->Setup (pdev, req);   
 8002568:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 800256c:	4629      	mov	r1, r5
 800256e:	689b      	ldr	r3, [r3, #8]
 8002570:	4620      	mov	r0, r4
 8002572:	4798      	blx	r3
 8002574:	e7b9      	b.n	80024ea <USBD_StdDevReq+0x14e>
  switch (pdev->dev_state)
 8002576:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 800257a:	3b02      	subs	r3, #2
 800257c:	2b01      	cmp	r3, #1
 800257e:	d88d      	bhi.n	800249c <USBD_StdDevReq+0x100>
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
 8002580:	884b      	ldrh	r3, [r1, #2]
 8002582:	2b01      	cmp	r3, #1
 8002584:	d19a      	bne.n	80024bc <USBD_StdDevReq+0x120>
      pdev->dev_remote_wakeup = 0; 
 8002586:	2300      	movs	r3, #0
 8002588:	e7ec      	b.n	8002564 <USBD_StdDevReq+0x1c8>
 800258a:	bf00      	nop
 800258c:	2000012c 	.word	0x2000012c

08002590 <USBD_StdItfReq>:
{
 8002590:	b538      	push	{r3, r4, r5, lr}
  switch (pdev->dev_state) 
 8002592:	f890 31fc 	ldrb.w	r3, [r0, #508]	; 0x1fc
 8002596:	2b03      	cmp	r3, #3
{
 8002598:	4604      	mov	r4, r0
 800259a:	460d      	mov	r5, r1
  switch (pdev->dev_state) 
 800259c:	d10d      	bne.n	80025ba <USBD_StdItfReq+0x2a>
    if (LOBYTE(req->wIndex) <= USBD_MAX_NUM_INTERFACES) 
 800259e:	790b      	ldrb	r3, [r1, #4]
 80025a0:	2b01      	cmp	r3, #1
 80025a2:	d80a      	bhi.n	80025ba <USBD_StdItfReq+0x2a>
      pdev->pClass->Setup (pdev, req); 
 80025a4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80025a8:	689b      	ldr	r3, [r3, #8]
 80025aa:	4798      	blx	r3
      if((req->wLength == 0)&& (ret == USBD_OK))
 80025ac:	88eb      	ldrh	r3, [r5, #6]
 80025ae:	b913      	cbnz	r3, 80025b6 <USBD_StdItfReq+0x26>
         USBD_CtlSendStatus(pdev);
 80025b0:	4620      	mov	r0, r4
 80025b2:	f000 f8cf 	bl	8002754 <USBD_CtlSendStatus>
}
 80025b6:	2000      	movs	r0, #0
 80025b8:	bd38      	pop	{r3, r4, r5, pc}
     USBD_CtlError(pdev , req);
 80025ba:	f7ff fee4 	bl	8002386 <USBD_CtlError.constprop.0>
    break;
 80025be:	e7fa      	b.n	80025b6 <USBD_StdItfReq+0x26>

080025c0 <USBD_StdEPReq>:
{
 80025c0:	b570      	push	{r4, r5, r6, lr}
  if ((req->bmRequest & 0x60) == 0x20)
 80025c2:	780a      	ldrb	r2, [r1, #0]
  ep_addr  = LOBYTE(req->wIndex);   
 80025c4:	888e      	ldrh	r6, [r1, #4]
  if ((req->bmRequest & 0x60) == 0x20)
 80025c6:	f002 0260 	and.w	r2, r2, #96	; 0x60
 80025ca:	2a20      	cmp	r2, #32
{
 80025cc:	4604      	mov	r4, r0
 80025ce:	460d      	mov	r5, r1
  ep_addr  = LOBYTE(req->wIndex);   
 80025d0:	b2f3      	uxtb	r3, r6
  if ((req->bmRequest & 0x60) == 0x20)
 80025d2:	d105      	bne.n	80025e0 <USBD_StdEPReq+0x20>
    pdev->pClass->Setup (pdev, req);
 80025d4:	f8d0 3214 	ldr.w	r3, [r0, #532]	; 0x214
 80025d8:	689b      	ldr	r3, [r3, #8]
 80025da:	4798      	blx	r3
}
 80025dc:	2000      	movs	r0, #0
 80025de:	bd70      	pop	{r4, r5, r6, pc}
  switch (req->bRequest) 
 80025e0:	784a      	ldrb	r2, [r1, #1]
 80025e2:	2a01      	cmp	r2, #1
 80025e4:	d01c      	beq.n	8002620 <USBD_StdEPReq+0x60>
 80025e6:	d32a      	bcc.n	800263e <USBD_StdEPReq+0x7e>
 80025e8:	2a03      	cmp	r2, #3
 80025ea:	d1f7      	bne.n	80025dc <USBD_StdEPReq+0x1c>
    switch (pdev->dev_state) 
 80025ec:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 80025f0:	2a02      	cmp	r2, #2
 80025f2:	d040      	beq.n	8002676 <USBD_StdEPReq+0xb6>
 80025f4:	2a03      	cmp	r2, #3
 80025f6:	d002      	beq.n	80025fe <USBD_StdEPReq+0x3e>
      USBD_CtlError(pdev , req);
 80025f8:	f7ff fec5 	bl	8002386 <USBD_CtlError.constprop.0>
      break;
 80025fc:	e7ee      	b.n	80025dc <USBD_StdEPReq+0x1c>
      if (req->wValue == USB_FEATURE_EP_HALT)
 80025fe:	884a      	ldrh	r2, [r1, #2]
 8002600:	b922      	cbnz	r2, 800260c <USBD_StdEPReq+0x4c>
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
 8002602:	065e      	lsls	r6, r3, #25
 8002604:	d002      	beq.n	800260c <USBD_StdEPReq+0x4c>
          USBD_LL_StallEP(pdev , ep_addr);
 8002606:	4619      	mov	r1, r3
 8002608:	f001 f8e6 	bl	80037d8 <USBD_LL_StallEP>
          pdev->pClass->Setup (pdev, req);
 800260c:	f8d4 3214 	ldr.w	r3, [r4, #532]	; 0x214
 8002610:	4629      	mov	r1, r5
 8002612:	689b      	ldr	r3, [r3, #8]
 8002614:	4620      	mov	r0, r4
 8002616:	4798      	blx	r3
        USBD_CtlSendStatus(pdev);
 8002618:	4620      	mov	r0, r4
 800261a:	f000 f89b 	bl	8002754 <USBD_CtlSendStatus>
 800261e:	e7dd      	b.n	80025dc <USBD_StdEPReq+0x1c>
    switch (pdev->dev_state) 
 8002620:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002624:	2a02      	cmp	r2, #2
 8002626:	d026      	beq.n	8002676 <USBD_StdEPReq+0xb6>
 8002628:	2a03      	cmp	r2, #3
 800262a:	d1e5      	bne.n	80025f8 <USBD_StdEPReq+0x38>
      if (req->wValue == USB_FEATURE_EP_HALT)
 800262c:	884a      	ldrh	r2, [r1, #2]
 800262e:	2a00      	cmp	r2, #0
 8002630:	d1d4      	bne.n	80025dc <USBD_StdEPReq+0x1c>
        if ((ep_addr & 0x7F) != 0x00) 
 8002632:	0659      	lsls	r1, r3, #25
 8002634:	d0f0      	beq.n	8002618 <USBD_StdEPReq+0x58>
          USBD_LL_ClearStallEP(pdev , ep_addr);
 8002636:	4619      	mov	r1, r3
 8002638:	f001 f8dc 	bl	80037f4 <USBD_LL_ClearStallEP>
 800263c:	e7e6      	b.n	800260c <USBD_StdEPReq+0x4c>
    switch (pdev->dev_state) 
 800263e:	f890 21fc 	ldrb.w	r2, [r0, #508]	; 0x1fc
 8002642:	2a02      	cmp	r2, #2
 8002644:	d017      	beq.n	8002676 <USBD_StdEPReq+0xb6>
 8002646:	2a03      	cmp	r2, #3
 8002648:	d1d6      	bne.n	80025f8 <USBD_StdEPReq+0x38>
 800264a:	f003 057f 	and.w	r5, r3, #127	; 0x7f
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 800264e:	f016 0f80 	tst.w	r6, #128	; 0x80
 8002652:	eb00 1505 	add.w	r5, r0, r5, lsl #4
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8002656:	4619      	mov	r1, r3
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
 8002658:	bf14      	ite	ne
 800265a:	3514      	addne	r5, #20
 800265c:	f505 7582 	addeq.w	r5, r5, #260	; 0x104
      if(USBD_LL_IsStallEP(pdev, ep_addr))
 8002660:	f001 f8d6 	bl	8003810 <USBD_LL_IsStallEP>
 8002664:	b168      	cbz	r0, 8002682 <USBD_StdEPReq+0xc2>
        pep->status = 0x0001;     
 8002666:	2301      	movs	r3, #1
 8002668:	602b      	str	r3, [r5, #0]
      USBD_CtlSendData (pdev,
 800266a:	2202      	movs	r2, #2
 800266c:	4629      	mov	r1, r5
 800266e:	4620      	mov	r0, r4
 8002670:	f000 f844 	bl	80026fc <USBD_CtlSendData>
      break;
 8002674:	e7b2      	b.n	80025dc <USBD_StdEPReq+0x1c>
      if ((ep_addr & 0x7F) != 0x00) 
 8002676:	065a      	lsls	r2, r3, #25
 8002678:	d0b0      	beq.n	80025dc <USBD_StdEPReq+0x1c>
        USBD_LL_StallEP(pdev , ep_addr);
 800267a:	4619      	mov	r1, r3
 800267c:	f001 f8ac 	bl	80037d8 <USBD_LL_StallEP>
 8002680:	e7ac      	b.n	80025dc <USBD_StdEPReq+0x1c>
        pep->status = 0x0000;  
 8002682:	6028      	str	r0, [r5, #0]
 8002684:	e7f1      	b.n	800266a <USBD_StdEPReq+0xaa>

08002686 <USBD_ParseSetupRequest>:
  req->bmRequest     = *(uint8_t *)  (pdata);
 8002686:	780b      	ldrb	r3, [r1, #0]
 8002688:	7003      	strb	r3, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
 800268a:	784b      	ldrb	r3, [r1, #1]
 800268c:	7043      	strb	r3, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
 800268e:	78ca      	ldrb	r2, [r1, #3]
 8002690:	788b      	ldrb	r3, [r1, #2]
 8002692:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8002696:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
 8002698:	794a      	ldrb	r2, [r1, #5]
 800269a:	790b      	ldrb	r3, [r1, #4]
 800269c:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80026a0:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
 80026a2:	79ca      	ldrb	r2, [r1, #7]
 80026a4:	798b      	ldrb	r3, [r1, #6]
 80026a6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80026aa:	80c3      	strh	r3, [r0, #6]
 80026ac:	4770      	bx	lr

080026ae <USBD_CtlError>:
{
 80026ae:	b510      	push	{r4, lr}
  USBD_LL_StallEP(pdev , 0x80);
 80026b0:	2180      	movs	r1, #128	; 0x80
{
 80026b2:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
 80026b4:	f001 f890 	bl	80037d8 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
 80026b8:	4620      	mov	r0, r4
 80026ba:	2100      	movs	r1, #0
}
 80026bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_StallEP(pdev , 0);
 80026c0:	f001 b88a 	b.w	80037d8 <USBD_LL_StallEP>

080026c4 <USBD_GetString>:
  * @param  unicode : Formatted string buffer (unicode)
  * @param  len : descriptor length
  * @retval None
  */
void USBD_GetString(uint8_t *desc, uint8_t *unicode, uint16_t *len)
{
 80026c4:	b530      	push	{r4, r5, lr}
  uint8_t idx = 0;
  
  if (desc != NULL) 
 80026c6:	b188      	cbz	r0, 80026ec <USBD_GetString+0x28>
 80026c8:	4605      	mov	r5, r0
 80026ca:	1a2b      	subs	r3, r5, r0
  */
static uint8_t USBD_GetLen(uint8_t *buf)
{
    uint8_t  len = 0;

    while (*buf != '\0') 
 80026cc:	f815 4b01 	ldrb.w	r4, [r5], #1
 80026d0:	b2db      	uxtb	r3, r3
 80026d2:	2c00      	cmp	r4, #0
 80026d4:	d1f9      	bne.n	80026ca <USBD_GetString+0x6>
    *len =  USBD_GetLen(desc) * 2 + 2;    
 80026d6:	005b      	lsls	r3, r3, #1
 80026d8:	3302      	adds	r3, #2
 80026da:	8013      	strh	r3, [r2, #0]
    unicode[idx++] = *len;
 80026dc:	700b      	strb	r3, [r1, #0]
    unicode[idx++] =  USB_DESC_TYPE_STRING;
 80026de:	2303      	movs	r3, #3
 80026e0:	704b      	strb	r3, [r1, #1]
 80026e2:	3801      	subs	r0, #1
 80026e4:	2302      	movs	r3, #2
    while (*desc != '\0') 
 80026e6:	f810 5f01 	ldrb.w	r5, [r0, #1]!
 80026ea:	b905      	cbnz	r5, 80026ee <USBD_GetString+0x2a>
 80026ec:	bd30      	pop	{r4, r5, pc}
      unicode[idx++] = *desc++;
 80026ee:	1c5a      	adds	r2, r3, #1
 80026f0:	b2d2      	uxtb	r2, r2
 80026f2:	54cd      	strb	r5, [r1, r3]
      unicode[idx++] =  0x00;
 80026f4:	3302      	adds	r3, #2
 80026f6:	b2db      	uxtb	r3, r3
 80026f8:	548c      	strb	r4, [r1, r2]
 80026fa:	e7f4      	b.n	80026e6 <USBD_GetString+0x22>

080026fc <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
 80026fc:	b510      	push	{r4, lr}
 80026fe:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
 8002700:	2202      	movs	r2, #2
 8002702:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_in[0].total_length = len;
 8002706:	6183      	str	r3, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 8002708:	460a      	mov	r2, r1
  pdev->ep_in[0].rem_length   = len;
 800270a:	61c3      	str	r3, [r0, #28]
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);  
 800270c:	2100      	movs	r1, #0
 800270e:	f001 f8a1 	bl	8003854 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002712:	2000      	movs	r0, #0
 8002714:	bd10      	pop	{r4, pc}

08002716 <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
 8002716:	b508      	push	{r3, lr}
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, len);   
 8002718:	4613      	mov	r3, r2
 800271a:	460a      	mov	r2, r1
 800271c:	2100      	movs	r1, #0
 800271e:	f001 f899 	bl	8003854 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002722:	2000      	movs	r0, #0
 8002724:	bd08      	pop	{r3, pc}

08002726 <USBD_CtlPrepareRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlPrepareRx (USBD_HandleTypeDef  *pdev,
                                  uint8_t *pbuf,                                  
                                  uint16_t len)
{
 8002726:	b510      	push	{r4, lr}
 8002728:	4613      	mov	r3, r2
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_DATA_OUT; 
 800272a:	2203      	movs	r2, #3
 800272c:	f8c0 21f4 	str.w	r2, [r0, #500]	; 0x1f4
  pdev->ep_out[0].total_length = len;
 8002730:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  pdev->ep_out[0].rem_length   = len;
  /* Start the transfer */
  USBD_LL_PrepareReceive (pdev,
 8002734:	460a      	mov	r2, r1
  pdev->ep_out[0].rem_length   = len;
 8002736:	f8c0 310c 	str.w	r3, [r0, #268]	; 0x10c
  USBD_LL_PrepareReceive (pdev,
 800273a:	2100      	movs	r1, #0
 800273c:	f001 f898 	bl	8003870 <USBD_LL_PrepareReceive>
                          0,
                          pbuf,
                         len);
  
  return USBD_OK;
}
 8002740:	2000      	movs	r0, #0
 8002742:	bd10      	pop	{r4, pc}

08002744 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
 8002744:	b508      	push	{r3, lr}

  USBD_LL_PrepareReceive (pdev,
 8002746:	4613      	mov	r3, r2
 8002748:	460a      	mov	r2, r1
 800274a:	2100      	movs	r1, #0
 800274c:	f001 f890 	bl	8003870 <USBD_LL_PrepareReceive>
                          0,                     
                          pbuf,                         
                          len);
  return USBD_OK;
}
 8002750:	2000      	movs	r0, #0
 8002752:	bd08      	pop	{r3, pc}

08002754 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
 8002754:	b508      	push	{r3, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
 8002756:	2304      	movs	r3, #4
 8002758:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
 800275c:	2300      	movs	r3, #0
 800275e:	461a      	mov	r2, r3
 8002760:	4619      	mov	r1, r3
 8002762:	f001 f877 	bl	8003854 <USBD_LL_Transmit>
  
  return USBD_OK;
}
 8002766:	2000      	movs	r0, #0
 8002768:	bd08      	pop	{r3, pc}

0800276a <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
 800276a:	b508      	push	{r3, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
 800276c:	2305      	movs	r3, #5
 800276e:	f8c0 31f4 	str.w	r3, [r0, #500]	; 0x1f4
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
 8002772:	2300      	movs	r3, #0
 8002774:	461a      	mov	r2, r3
 8002776:	4619      	mov	r1, r3
 8002778:	f001 f87a 	bl	8003870 <USBD_LL_PrepareReceive>
                    0,
                    NULL,
                    0);  

  return USBD_OK;
}
 800277c:	2000      	movs	r0, #0
 800277e:	bd08      	pop	{r3, pc}

08002780 <osKernelStart>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval status code that indicates the execution status of the function
* @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
*/
osStatus osKernelStart (void)
{
 8002780:	b508      	push	{r3, lr}
  vTaskStartScheduler();
 8002782:	f000 fbe1 	bl	8002f48 <vTaskStartScheduler>
  
  return osOK;
}
 8002786:	2000      	movs	r0, #0
 8002788:	bd08      	pop	{r3, pc}

0800278a <osThreadCreate>:
* @param  argument      pointer that is passed to the thread function as start argument.
* @retval thread ID for reference by other functions or NULL in case of error.
* @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
*/
osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
{
 800278a:	b530      	push	{r4, r5, lr}

    handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
              thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
              thread_def->buffer, thread_def->controlblock);
#else
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 800278c:	f9b0 4008 	ldrsh.w	r4, [r0, #8]
 8002790:	8a02      	ldrh	r2, [r0, #16]
{
 8002792:	460b      	mov	r3, r1
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 8002794:	e890 0022 	ldmia.w	r0, {r1, r5}
{
 8002798:	b085      	sub	sp, #20
  if (priority != osPriorityError) {
 800279a:	2c84      	cmp	r4, #132	; 0x84
    fpriority += (priority - osPriorityIdle);
 800279c:	bf14      	ite	ne
 800279e:	3403      	addne	r4, #3
  unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
 80027a0:	2400      	moveq	r4, #0
  if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
 80027a2:	a803      	add	r0, sp, #12
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9400      	str	r4, [sp, #0]
 80027a8:	4628      	mov	r0, r5
 80027aa:	f000 fafd 	bl	8002da8 <xTaskCreate>
 80027ae:	2801      	cmp	r0, #1
                   &handle) != pdPASS)  {
    return NULL;
  }     
#endif
  
  return handle;
 80027b0:	bf0c      	ite	eq
 80027b2:	9803      	ldreq	r0, [sp, #12]
    return NULL;
 80027b4:	2000      	movne	r0, #0
}
 80027b6:	b005      	add	sp, #20
 80027b8:	bd30      	pop	{r4, r5, pc}

080027ba <osDelay>:
* @brief   Wait for Timeout (Time Delay)
* @param   millisec      time delay value
* @retval  status code that indicates the execution status of the function.
*/
osStatus osDelay (uint32_t millisec)
{
 80027ba:	b508      	push	{r3, lr}
#if INCLUDE_vTaskDelay
  TickType_t ticks = millisec / portTICK_PERIOD_MS;
  
  vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
 80027bc:	2800      	cmp	r0, #0
 80027be:	bf08      	it	eq
 80027c0:	2001      	moveq	r0, #1
 80027c2:	f000 fd0f 	bl	80031e4 <vTaskDelay>
#else
  (void) millisec;
  
  return osErrorResource;
#endif
}
 80027c6:	2000      	movs	r0, #0
 80027c8:	bd08      	pop	{r3, pc}

080027ca <osSystickHandler>:
* @brief  Handles the tick increment
* @param  none.
* @retval none.
*/
void osSystickHandler(void)
{
 80027ca:	b508      	push	{r3, lr}

#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
 80027cc:	f000 fda2 	bl	8003314 <xTaskGetSchedulerState>
 80027d0:	2801      	cmp	r0, #1
 80027d2:	d003      	beq.n	80027dc <osSystickHandler+0x12>
#endif  /* INCLUDE_xTaskGetSchedulerState */  
    xPortSysTickHandler();
#if (INCLUDE_xTaskGetSchedulerState  == 1 )
  }
#endif  /* INCLUDE_xTaskGetSchedulerState */  
}
 80027d4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    xPortSysTickHandler();
 80027d8:	f000 b904 	b.w	80029e4 <xPortSysTickHandler>
 80027dc:	bd08      	pop	{r3, pc}

080027de <vListInitialise>:
void vListInitialise( List_t * const pxList )
{
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80027de:	f100 0308 	add.w	r3, r0, #8
 80027e2:	6043      	str	r3, [r0, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80027e4:	f04f 32ff 	mov.w	r2, #4294967295

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80027e8:	60c3      	str	r3, [r0, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 80027ea:	6103      	str	r3, [r0, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80027ec:	2300      	movs	r3, #0
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 80027ee:	6082      	str	r2, [r0, #8]
	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 80027f0:	6003      	str	r3, [r0, #0]
 80027f2:	4770      	bx	lr

080027f4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 80027f4:	2300      	movs	r3, #0
 80027f6:	6103      	str	r3, [r0, #16]
 80027f8:	4770      	bx	lr

080027fa <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 80027fa:	6843      	ldr	r3, [r0, #4]
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 80027fc:	604b      	str	r3, [r1, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 80027fe:	689a      	ldr	r2, [r3, #8]
 8002800:	608a      	str	r2, [r1, #8]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 8002802:	689a      	ldr	r2, [r3, #8]
 8002804:	6051      	str	r1, [r2, #4]
	pxIndex->pxPrevious = pxNewListItem;
 8002806:	6099      	str	r1, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8002808:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 800280a:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800280c:	3301      	adds	r3, #1
 800280e:	6003      	str	r3, [r0, #0]
 8002810:	4770      	bx	lr

08002812 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 8002812:	680a      	ldr	r2, [r1, #0]
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 8002814:	1c53      	adds	r3, r2, #1
{
 8002816:	b530      	push	{r4, r5, lr}
	if( xValueOfInsertion == portMAX_DELAY )
 8002818:	d10a      	bne.n	8002830 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 800281a:	6903      	ldr	r3, [r0, #16]
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 800281c:	685a      	ldr	r2, [r3, #4]
 800281e:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 8002820:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
 8002822:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = pxNewListItem;
 8002824:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
 8002826:	6803      	ldr	r3, [r0, #0]
	pxNewListItem->pvContainer = ( void * ) pxList;
 8002828:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 800282a:	3301      	adds	r3, #1
 800282c:	6003      	str	r3, [r0, #0]
 800282e:	bd30      	pop	{r4, r5, pc}
		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 8002830:	f100 0308 	add.w	r3, r0, #8
 8002834:	685c      	ldr	r4, [r3, #4]
 8002836:	6825      	ldr	r5, [r4, #0]
 8002838:	42aa      	cmp	r2, r5
 800283a:	d3ef      	bcc.n	800281c <vListInsert+0xa>
 800283c:	4623      	mov	r3, r4
 800283e:	e7f9      	b.n	8002834 <vListInsert+0x22>

08002840 <uxListRemove>:
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8002840:	6841      	ldr	r1, [r0, #4]
 8002842:	6882      	ldr	r2, [r0, #8]
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 8002844:	6903      	ldr	r3, [r0, #16]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8002846:	608a      	str	r2, [r1, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8002848:	6882      	ldr	r2, [r0, #8]
 800284a:	6051      	str	r1, [r2, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 800284c:	6859      	ldr	r1, [r3, #4]
 800284e:	4288      	cmp	r0, r1
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8002850:	bf08      	it	eq
 8002852:	605a      	streq	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 8002854:	2200      	movs	r2, #0
 8002856:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8002858:	6818      	ldr	r0, [r3, #0]
 800285a:	3801      	subs	r0, #1
 800285c:	6018      	str	r0, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800285e:	4770      	bx	lr

08002860 <prvTaskExitError>:
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
 8002860:	4b0a      	ldr	r3, [pc, #40]	; (800288c <prvTaskExitError+0x2c>)
 8002862:	681b      	ldr	r3, [r3, #0]
 8002864:	3301      	adds	r3, #1
 8002866:	d008      	beq.n	800287a <prvTaskExitError+0x1a>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 8002868:	f04f 0350 	mov.w	r3, #80	; 0x50
 800286c:	f383 8811 	msr	BASEPRI, r3
 8002870:	f3bf 8f6f 	isb	sy
 8002874:	f3bf 8f4f 	dsb	sy
 8002878:	e7fe      	b.n	8002878 <prvTaskExitError+0x18>
 800287a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800287e:	f383 8811 	msr	BASEPRI, r3
 8002882:	f3bf 8f6f 	isb	sy
 8002886:	f3bf 8f4f 	dsb	sy
 800288a:	e7fe      	b.n	800288a <prvTaskExitError+0x2a>
 800288c:	200000b8 	.word	0x200000b8

08002890 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
 8002890:	4806      	ldr	r0, [pc, #24]	; (80028ac <prvPortStartFirstTask+0x1c>)
 8002892:	6800      	ldr	r0, [r0, #0]
 8002894:	6800      	ldr	r0, [r0, #0]
 8002896:	f380 8808 	msr	MSP, r0
 800289a:	b662      	cpsie	i
 800289c:	b661      	cpsie	f
 800289e:	f3bf 8f4f 	dsb	sy
 80028a2:	f3bf 8f6f 	isb	sy
 80028a6:	df00      	svc	0
 80028a8:	bf00      	nop
 80028aa:	0000      	.short	0x0000
 80028ac:	e000ed08 	.word	0xe000ed08

080028b0 <vPortEnableVFP>:
/*-----------------------------------------------------------*/

/* This is a naked function. */
static void vPortEnableVFP( void )
{
	__asm volatile
 80028b0:	f8df 000c 	ldr.w	r0, [pc, #12]	; 80028c0 <vPortEnableVFP+0x10>
 80028b4:	6801      	ldr	r1, [r0, #0]
 80028b6:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80028ba:	6001      	str	r1, [r0, #0]
 80028bc:	4770      	bx	lr
 80028be:	0000      	.short	0x0000
 80028c0:	e000ed88 	.word	0xe000ed88

080028c4 <pxPortInitialiseStack>:
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
 80028c4:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 80028c8:	f840 3c04 	str.w	r3, [r0, #-4]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
 80028cc:	4b07      	ldr	r3, [pc, #28]	; (80028ec <pxPortInitialiseStack+0x28>)
 80028ce:	f840 3c0c 	str.w	r3, [r0, #-12]
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80028d2:	f021 0101 	bic.w	r1, r1, #1
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80028d6:	f06f 0302 	mvn.w	r3, #2
	*pxTopOfStack = ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;	/* PC */
 80028da:	f840 1c08 	str.w	r1, [r0, #-8]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
 80028de:	f840 2c20 	str.w	r2, [r0, #-32]
	*pxTopOfStack = portINITIAL_EXEC_RETURN;
 80028e2:	f840 3c24 	str.w	r3, [r0, #-36]
}
 80028e6:	3844      	subs	r0, #68	; 0x44
 80028e8:	4770      	bx	lr
 80028ea:	bf00      	nop
 80028ec:	08002861 	.word	0x08002861

080028f0 <SVC_Handler>:
	__asm volatile (
 80028f0:	4b07      	ldr	r3, [pc, #28]	; (8002910 <pxCurrentTCBConst2>)
 80028f2:	6819      	ldr	r1, [r3, #0]
 80028f4:	6808      	ldr	r0, [r1, #0]
 80028f6:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80028fa:	f380 8809 	msr	PSP, r0
 80028fe:	f3bf 8f6f 	isb	sy
 8002902:	f04f 0000 	mov.w	r0, #0
 8002906:	f380 8811 	msr	BASEPRI, r0
 800290a:	4770      	bx	lr
 800290c:	f3af 8000 	nop.w

08002910 <pxCurrentTCBConst2>:
 8002910:	20000d4c 	.word	0x20000d4c

08002914 <vPortEnterCritical>:
 8002914:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002918:	f383 8811 	msr	BASEPRI, r3
 800291c:	f3bf 8f6f 	isb	sy
 8002920:	f3bf 8f4f 	dsb	sy
	uxCriticalNesting++;
 8002924:	4a0a      	ldr	r2, [pc, #40]	; (8002950 <vPortEnterCritical+0x3c>)
 8002926:	6813      	ldr	r3, [r2, #0]
 8002928:	3301      	adds	r3, #1
	if( uxCriticalNesting == 1 )
 800292a:	2b01      	cmp	r3, #1
	uxCriticalNesting++;
 800292c:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 1 )
 800292e:	d10d      	bne.n	800294c <vPortEnterCritical+0x38>
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
 8002930:	4b08      	ldr	r3, [pc, #32]	; (8002954 <vPortEnterCritical+0x40>)
 8002932:	681b      	ldr	r3, [r3, #0]
 8002934:	f013 0fff 	tst.w	r3, #255	; 0xff
 8002938:	d008      	beq.n	800294c <vPortEnterCritical+0x38>
 800293a:	f04f 0350 	mov.w	r3, #80	; 0x50
 800293e:	f383 8811 	msr	BASEPRI, r3
 8002942:	f3bf 8f6f 	isb	sy
 8002946:	f3bf 8f4f 	dsb	sy
 800294a:	e7fe      	b.n	800294a <vPortEnterCritical+0x36>
 800294c:	4770      	bx	lr
 800294e:	bf00      	nop
 8002950:	200000b8 	.word	0x200000b8
 8002954:	e000ed04 	.word	0xe000ed04

08002958 <vPortExitCritical>:
	configASSERT( uxCriticalNesting );
 8002958:	4a08      	ldr	r2, [pc, #32]	; (800297c <vPortExitCritical+0x24>)
 800295a:	6813      	ldr	r3, [r2, #0]
 800295c:	b943      	cbnz	r3, 8002970 <vPortExitCritical+0x18>
 800295e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002962:	f383 8811 	msr	BASEPRI, r3
 8002966:	f3bf 8f6f 	isb	sy
 800296a:	f3bf 8f4f 	dsb	sy
 800296e:	e7fe      	b.n	800296e <vPortExitCritical+0x16>
	uxCriticalNesting--;
 8002970:	3b01      	subs	r3, #1
 8002972:	6013      	str	r3, [r2, #0]
	if( uxCriticalNesting == 0 )
 8002974:	b90b      	cbnz	r3, 800297a <vPortExitCritical+0x22>
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8002976:	f383 8811 	msr	BASEPRI, r3
 800297a:	4770      	bx	lr
 800297c:	200000b8 	.word	0x200000b8

08002980 <PendSV_Handler>:
	__asm volatile
 8002980:	f3ef 8009 	mrs	r0, PSP
 8002984:	f3bf 8f6f 	isb	sy
 8002988:	4b15      	ldr	r3, [pc, #84]	; (80029e0 <pxCurrentTCBConst>)
 800298a:	681a      	ldr	r2, [r3, #0]
 800298c:	f01e 0f10 	tst.w	lr, #16
 8002990:	bf08      	it	eq
 8002992:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 8002996:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800299a:	6010      	str	r0, [r2, #0]
 800299c:	f84d 3d04 	str.w	r3, [sp, #-4]!
 80029a0:	f04f 0050 	mov.w	r0, #80	; 0x50
 80029a4:	f380 8811 	msr	BASEPRI, r0
 80029a8:	f3bf 8f4f 	dsb	sy
 80029ac:	f3bf 8f6f 	isb	sy
 80029b0:	f000 fc76 	bl	80032a0 <vTaskSwitchContext>
 80029b4:	f04f 0000 	mov.w	r0, #0
 80029b8:	f380 8811 	msr	BASEPRI, r0
 80029bc:	bc08      	pop	{r3}
 80029be:	6819      	ldr	r1, [r3, #0]
 80029c0:	6808      	ldr	r0, [r1, #0]
 80029c2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80029c6:	f01e 0f10 	tst.w	lr, #16
 80029ca:	bf08      	it	eq
 80029cc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80029d0:	f380 8809 	msr	PSP, r0
 80029d4:	f3bf 8f6f 	isb	sy
 80029d8:	4770      	bx	lr
 80029da:	bf00      	nop
 80029dc:	f3af 8000 	nop.w

080029e0 <pxCurrentTCBConst>:
 80029e0:	20000d4c 	.word	0x20000d4c

080029e4 <xPortSysTickHandler>:
{
 80029e4:	b508      	push	{r3, lr}
	__asm volatile
 80029e6:	f04f 0350 	mov.w	r3, #80	; 0x50
 80029ea:	f383 8811 	msr	BASEPRI, r3
 80029ee:	f3bf 8f6f 	isb	sy
 80029f2:	f3bf 8f4f 	dsb	sy
		if( xTaskIncrementTick() != pdFALSE )
 80029f6:	f000 faeb 	bl	8002fd0 <xTaskIncrementTick>
 80029fa:	b118      	cbz	r0, 8002a04 <xPortSysTickHandler+0x20>
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 80029fc:	4b03      	ldr	r3, [pc, #12]	; (8002a0c <xPortSysTickHandler+0x28>)
 80029fe:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002a02:	601a      	str	r2, [r3, #0]
	__asm volatile
 8002a04:	2300      	movs	r3, #0
 8002a06:	f383 8811 	msr	BASEPRI, r3
 8002a0a:	bd08      	pop	{r3, pc}
 8002a0c:	e000ed04 	.word	0xe000ed04

08002a10 <vPortSetupTimerInterrupt>:
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
 8002a10:	4b06      	ldr	r3, [pc, #24]	; (8002a2c <vPortSetupTimerInterrupt+0x1c>)
 8002a12:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8002a16:	681b      	ldr	r3, [r3, #0]
 8002a18:	fbb3 f3f2 	udiv	r3, r3, r2
 8002a1c:	4a04      	ldr	r2, [pc, #16]	; (8002a30 <vPortSetupTimerInterrupt+0x20>)
 8002a1e:	3b01      	subs	r3, #1
 8002a20:	6013      	str	r3, [r2, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
 8002a22:	4b04      	ldr	r3, [pc, #16]	; (8002a34 <vPortSetupTimerInterrupt+0x24>)
 8002a24:	2207      	movs	r2, #7
 8002a26:	601a      	str	r2, [r3, #0]
 8002a28:	4770      	bx	lr
 8002a2a:	bf00      	nop
 8002a2c:	200000bc 	.word	0x200000bc
 8002a30:	e000e014 	.word	0xe000e014
 8002a34:	e000e010 	.word	0xe000e010

08002a38 <xPortStartScheduler>:
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8002a38:	4b31      	ldr	r3, [pc, #196]	; (8002b00 <xPortStartScheduler+0xc8>)
 8002a3a:	4a32      	ldr	r2, [pc, #200]	; (8002b04 <xPortStartScheduler+0xcc>)
{
 8002a3c:	b513      	push	{r0, r1, r4, lr}
	configASSERT( portCPUID != portCORTEX_M7_r0p1_ID );
 8002a3e:	6819      	ldr	r1, [r3, #0]
 8002a40:	4291      	cmp	r1, r2
 8002a42:	d108      	bne.n	8002a56 <xPortStartScheduler+0x1e>
	__asm volatile
 8002a44:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002a48:	f383 8811 	msr	BASEPRI, r3
 8002a4c:	f3bf 8f6f 	isb	sy
 8002a50:	f3bf 8f4f 	dsb	sy
 8002a54:	e7fe      	b.n	8002a54 <xPortStartScheduler+0x1c>
	configASSERT( portCPUID != portCORTEX_M7_r0p0_ID );
 8002a56:	681a      	ldr	r2, [r3, #0]
 8002a58:	4b2b      	ldr	r3, [pc, #172]	; (8002b08 <xPortStartScheduler+0xd0>)
 8002a5a:	429a      	cmp	r2, r3
 8002a5c:	d108      	bne.n	8002a70 <xPortStartScheduler+0x38>
 8002a5e:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002a62:	f383 8811 	msr	BASEPRI, r3
 8002a66:	f3bf 8f6f 	isb	sy
 8002a6a:	f3bf 8f4f 	dsb	sy
 8002a6e:	e7fe      	b.n	8002a6e <xPortStartScheduler+0x36>
		ulOriginalPriority = *pucFirstUserPriorityRegister;
 8002a70:	4b26      	ldr	r3, [pc, #152]	; (8002b0c <xPortStartScheduler+0xd4>)
 8002a72:	781a      	ldrb	r2, [r3, #0]
 8002a74:	b2d2      	uxtb	r2, r2
 8002a76:	9201      	str	r2, [sp, #4]
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
 8002a78:	22ff      	movs	r2, #255	; 0xff
 8002a7a:	701a      	strb	r2, [r3, #0]
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8002a7c:	781b      	ldrb	r3, [r3, #0]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8002a7e:	4a24      	ldr	r2, [pc, #144]	; (8002b10 <xPortStartScheduler+0xd8>)
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
 8002a80:	b2db      	uxtb	r3, r3
 8002a82:	f88d 3003 	strb.w	r3, [sp, #3]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
 8002a86:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8002a8a:	f003 0350 	and.w	r3, r3, #80	; 0x50
 8002a8e:	7013      	strb	r3, [r2, #0]
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
 8002a90:	4b20      	ldr	r3, [pc, #128]	; (8002b14 <xPortStartScheduler+0xdc>)
 8002a92:	2207      	movs	r2, #7
 8002a94:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
 8002a96:	2100      	movs	r1, #0
 8002a98:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8002a9c:	0600      	lsls	r0, r0, #24
 8002a9e:	f102 34ff 	add.w	r4, r2, #4294967295
 8002aa2:	d423      	bmi.n	8002aec <xPortStartScheduler+0xb4>
 8002aa4:	b101      	cbz	r1, 8002aa8 <xPortStartScheduler+0x70>
 8002aa6:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
 8002aa8:	681a      	ldr	r2, [r3, #0]
 8002aaa:	0212      	lsls	r2, r2, #8
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
 8002aac:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8002ab0:	601a      	str	r2, [r3, #0]
		*pucFirstUserPriorityRegister = ulOriginalPriority;
 8002ab2:	9b01      	ldr	r3, [sp, #4]
 8002ab4:	4a15      	ldr	r2, [pc, #84]	; (8002b0c <xPortStartScheduler+0xd4>)
 8002ab6:	b2db      	uxtb	r3, r3
 8002ab8:	7013      	strb	r3, [r2, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
 8002aba:	4b17      	ldr	r3, [pc, #92]	; (8002b18 <xPortStartScheduler+0xe0>)
 8002abc:	681a      	ldr	r2, [r3, #0]
 8002abe:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
 8002ac2:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
 8002ac4:	681a      	ldr	r2, [r3, #0]
 8002ac6:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
 8002aca:	601a      	str	r2, [r3, #0]
	vPortSetupTimerInterrupt();
 8002acc:	f7ff ffa0 	bl	8002a10 <vPortSetupTimerInterrupt>
	uxCriticalNesting = 0;
 8002ad0:	4b12      	ldr	r3, [pc, #72]	; (8002b1c <xPortStartScheduler+0xe4>)
 8002ad2:	2200      	movs	r2, #0
 8002ad4:	601a      	str	r2, [r3, #0]
	vPortEnableVFP();
 8002ad6:	f7ff feeb 	bl	80028b0 <vPortEnableVFP>
	*( portFPCCR ) |= portASPEN_AND_LSPEN_BITS;
 8002ada:	4a11      	ldr	r2, [pc, #68]	; (8002b20 <xPortStartScheduler+0xe8>)
 8002adc:	6813      	ldr	r3, [r2, #0]
 8002ade:	f043 4340 	orr.w	r3, r3, #3221225472	; 0xc0000000
 8002ae2:	6013      	str	r3, [r2, #0]
	prvPortStartFirstTask();
 8002ae4:	f7ff fed4 	bl	8002890 <prvPortStartFirstTask>
	prvTaskExitError();
 8002ae8:	f7ff feba 	bl	8002860 <prvTaskExitError>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
 8002aec:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8002af0:	0052      	lsls	r2, r2, #1
 8002af2:	b2d2      	uxtb	r2, r2
 8002af4:	f88d 2003 	strb.w	r2, [sp, #3]
 8002af8:	2101      	movs	r1, #1
 8002afa:	4622      	mov	r2, r4
 8002afc:	e7cc      	b.n	8002a98 <xPortStartScheduler+0x60>
 8002afe:	bf00      	nop
 8002b00:	e000ed00 	.word	0xe000ed00
 8002b04:	410fc271 	.word	0x410fc271
 8002b08:	410fc270 	.word	0x410fc270
 8002b0c:	e000e400 	.word	0xe000e400
 8002b10:	2000012d 	.word	0x2000012d
 8002b14:	20000130 	.word	0x20000130
 8002b18:	e000ed20 	.word	0xe000ed20
 8002b1c:	200000b8 	.word	0x200000b8
 8002b20:	e000ef34 	.word	0xe000ef34

08002b24 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
 8002b24:	b510      	push	{r4, lr}
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
 8002b26:	4b0f      	ldr	r3, [pc, #60]	; (8002b64 <prvInsertBlockIntoFreeList+0x40>)
 8002b28:	681a      	ldr	r2, [r3, #0]
 8002b2a:	4282      	cmp	r2, r0
 8002b2c:	d318      	bcc.n	8002b60 <prvInsertBlockIntoFreeList+0x3c>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
 8002b2e:	685c      	ldr	r4, [r3, #4]
 8002b30:	1919      	adds	r1, r3, r4
 8002b32:	4288      	cmp	r0, r1
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
 8002b34:	bf01      	itttt	eq
 8002b36:	6841      	ldreq	r1, [r0, #4]
 8002b38:	4618      	moveq	r0, r3
 8002b3a:	1909      	addeq	r1, r1, r4
 8002b3c:	6059      	streq	r1, [r3, #4]
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
 8002b3e:	6844      	ldr	r4, [r0, #4]
 8002b40:	1901      	adds	r1, r0, r4
 8002b42:	428a      	cmp	r2, r1
 8002b44:	d107      	bne.n	8002b56 <prvInsertBlockIntoFreeList+0x32>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
 8002b46:	4908      	ldr	r1, [pc, #32]	; (8002b68 <prvInsertBlockIntoFreeList+0x44>)
 8002b48:	6809      	ldr	r1, [r1, #0]
 8002b4a:	428a      	cmp	r2, r1
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8002b4c:	bf1f      	itttt	ne
 8002b4e:	6851      	ldrne	r1, [r2, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
 8002b50:	6812      	ldrne	r2, [r2, #0]
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
 8002b52:	1909      	addne	r1, r1, r4
 8002b54:	6041      	strne	r1, [r0, #4]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
 8002b56:	4298      	cmp	r0, r3
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
 8002b58:	6002      	str	r2, [r0, #0]
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
 8002b5a:	bf18      	it	ne
 8002b5c:	6018      	strne	r0, [r3, #0]
 8002b5e:	bd10      	pop	{r4, pc}
 8002b60:	4613      	mov	r3, r2
 8002b62:	e7e1      	b.n	8002b28 <prvInsertBlockIntoFreeList+0x4>
 8002b64:	20000d44 	.word	0x20000d44
 8002b68:	20000134 	.word	0x20000134

08002b6c <pvPortMalloc>:
{
 8002b6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002b70:	4604      	mov	r4, r0
	vTaskSuspendAll();
 8002b72:	f000 fa25 	bl	8002fc0 <vTaskSuspendAll>
		if( pxEnd == NULL )
 8002b76:	493e      	ldr	r1, [pc, #248]	; (8002c70 <pvPortMalloc+0x104>)
 8002b78:	4d3e      	ldr	r5, [pc, #248]	; (8002c74 <pvPortMalloc+0x108>)
 8002b7a:	680b      	ldr	r3, [r1, #0]
 8002b7c:	bb0b      	cbnz	r3, 8002bc2 <pvPortMalloc+0x56>
	uxAddress = ( size_t ) ucHeap;
 8002b7e:	4a3e      	ldr	r2, [pc, #248]	; (8002c78 <pvPortMalloc+0x10c>)
	if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
 8002b80:	0756      	lsls	r6, r2, #29
		uxAddress += ( portBYTE_ALIGNMENT - 1 );
 8002b82:	bf1f      	itttt	ne
 8002b84:	1dd0      	addne	r0, r2, #7
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8002b86:	f020 0007 	bicne.w	r0, r0, #7
		xTotalHeapSize -= uxAddress - ( size_t ) ucHeap;
 8002b8a:	f502 6340 	addne.w	r3, r2, #3072	; 0xc00
 8002b8e:	1a1b      	subne	r3, r3, r0
		uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8002b90:	bf14      	ite	ne
 8002b92:	4602      	movne	r2, r0
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
 8002b94:	f44f 6340 	moveq.w	r3, #3072	; 0xc00
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
 8002b98:	4413      	add	r3, r2
	uxAddress -= xHeapStructSize;
 8002b9a:	3b08      	subs	r3, #8
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
 8002b9c:	f023 0307 	bic.w	r3, r3, #7
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002ba0:	4e36      	ldr	r6, [pc, #216]	; (8002c7c <pvPortMalloc+0x110>)
	pxEnd = ( void * ) uxAddress;
 8002ba2:	600b      	str	r3, [r1, #0]
	xStart.xBlockSize = ( size_t ) 0;
 8002ba4:	2000      	movs	r0, #0
 8002ba6:	6070      	str	r0, [r6, #4]
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 8002ba8:	6032      	str	r2, [r6, #0]
	pxEnd->xBlockSize = 0;
 8002baa:	6058      	str	r0, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
 8002bac:	6018      	str	r0, [r3, #0]
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8002bae:	1a98      	subs	r0, r3, r2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
 8002bb0:	6013      	str	r3, [r2, #0]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002bb2:	4b33      	ldr	r3, [pc, #204]	; (8002c80 <pvPortMalloc+0x114>)
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
 8002bb4:	6050      	str	r0, [r2, #4]
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002bb6:	6018      	str	r0, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
 8002bb8:	4b32      	ldr	r3, [pc, #200]	; (8002c84 <pvPortMalloc+0x118>)
 8002bba:	6018      	str	r0, [r3, #0]
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
 8002bbc:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8002bc0:	602b      	str	r3, [r5, #0]
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
 8002bc2:	682f      	ldr	r7, [r5, #0]
 8002bc4:	4227      	tst	r7, r4
 8002bc6:	d116      	bne.n	8002bf6 <pvPortMalloc+0x8a>
			if( xWantedSize > 0 )
 8002bc8:	2c00      	cmp	r4, #0
 8002bca:	d041      	beq.n	8002c50 <pvPortMalloc+0xe4>
				xWantedSize += xHeapStructSize;
 8002bcc:	f104 0308 	add.w	r3, r4, #8
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
 8002bd0:	0758      	lsls	r0, r3, #29
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
 8002bd2:	bf1c      	itt	ne
 8002bd4:	f023 0307 	bicne.w	r3, r3, #7
 8002bd8:	3308      	addne	r3, #8
			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
 8002bda:	b163      	cbz	r3, 8002bf6 <pvPortMalloc+0x8a>
 8002bdc:	4a29      	ldr	r2, [pc, #164]	; (8002c84 <pvPortMalloc+0x118>)
 8002bde:	6816      	ldr	r6, [r2, #0]
 8002be0:	42b3      	cmp	r3, r6
 8002be2:	4690      	mov	r8, r2
 8002be4:	d807      	bhi.n	8002bf6 <pvPortMalloc+0x8a>
				pxBlock = xStart.pxNextFreeBlock;
 8002be6:	4a25      	ldr	r2, [pc, #148]	; (8002c7c <pvPortMalloc+0x110>)
 8002be8:	6815      	ldr	r5, [r2, #0]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8002bea:	6868      	ldr	r0, [r5, #4]
 8002bec:	4283      	cmp	r3, r0
 8002bee:	d804      	bhi.n	8002bfa <pvPortMalloc+0x8e>
				if( pxBlock != pxEnd )
 8002bf0:	6809      	ldr	r1, [r1, #0]
 8002bf2:	428d      	cmp	r5, r1
 8002bf4:	d107      	bne.n	8002c06 <pvPortMalloc+0x9a>
void *pvReturn = NULL;
 8002bf6:	2400      	movs	r4, #0
 8002bf8:	e02a      	b.n	8002c50 <pvPortMalloc+0xe4>
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 8002bfa:	682c      	ldr	r4, [r5, #0]
 8002bfc:	2c00      	cmp	r4, #0
 8002bfe:	d0f7      	beq.n	8002bf0 <pvPortMalloc+0x84>
 8002c00:	462a      	mov	r2, r5
 8002c02:	4625      	mov	r5, r4
 8002c04:	e7f1      	b.n	8002bea <pvPortMalloc+0x7e>
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8002c06:	6829      	ldr	r1, [r5, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002c08:	6814      	ldr	r4, [r2, #0]
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 8002c0a:	6011      	str	r1, [r2, #0]
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 8002c0c:	1ac2      	subs	r2, r0, r3
 8002c0e:	2a10      	cmp	r2, #16
 8002c10:	d90f      	bls.n	8002c32 <pvPortMalloc+0xc6>
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 8002c12:	18e8      	adds	r0, r5, r3
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
 8002c14:	0741      	lsls	r1, r0, #29
 8002c16:	d008      	beq.n	8002c2a <pvPortMalloc+0xbe>
 8002c18:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c1c:	f383 8811 	msr	BASEPRI, r3
 8002c20:	f3bf 8f6f 	isb	sy
 8002c24:	f3bf 8f4f 	dsb	sy
 8002c28:	e7fe      	b.n	8002c28 <pvPortMalloc+0xbc>
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 8002c2a:	6042      	str	r2, [r0, #4]
						pxBlock->xBlockSize = xWantedSize;
 8002c2c:	606b      	str	r3, [r5, #4]
						prvInsertBlockIntoFreeList( pxNewBlockLink );
 8002c2e:	f7ff ff79 	bl	8002b24 <prvInsertBlockIntoFreeList>
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002c32:	4913      	ldr	r1, [pc, #76]	; (8002c80 <pvPortMalloc+0x114>)
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002c34:	686b      	ldr	r3, [r5, #4]
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002c36:	6808      	ldr	r0, [r1, #0]
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002c38:	1af6      	subs	r6, r6, r3
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002c3a:	431f      	orrs	r7, r3
					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
 8002c3c:	4286      	cmp	r6, r0
					pxBlock->pxNextFreeBlock = NULL;
 8002c3e:	f04f 0300 	mov.w	r3, #0
					xFreeBytesRemaining -= pxBlock->xBlockSize;
 8002c42:	f8c8 6000 	str.w	r6, [r8]
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
 8002c46:	bf38      	it	cc
 8002c48:	600e      	strcc	r6, [r1, #0]
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
 8002c4a:	3408      	adds	r4, #8
					pxBlock->xBlockSize |= xBlockAllocatedBit;
 8002c4c:	606f      	str	r7, [r5, #4]
					pxBlock->pxNextFreeBlock = NULL;
 8002c4e:	602b      	str	r3, [r5, #0]
	( void ) xTaskResumeAll();
 8002c50:	f000 fa50 	bl	80030f4 <xTaskResumeAll>
	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
 8002c54:	0763      	lsls	r3, r4, #29
 8002c56:	d008      	beq.n	8002c6a <pvPortMalloc+0xfe>
 8002c58:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c5c:	f383 8811 	msr	BASEPRI, r3
 8002c60:	f3bf 8f6f 	isb	sy
 8002c64:	f3bf 8f4f 	dsb	sy
 8002c68:	e7fe      	b.n	8002c68 <pvPortMalloc+0xfc>
}
 8002c6a:	4620      	mov	r0, r4
 8002c6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002c70:	20000134 	.word	0x20000134
 8002c74:	20000d38 	.word	0x20000d38
 8002c78:	20000138 	.word	0x20000138
 8002c7c:	20000d44 	.word	0x20000d44
 8002c80:	20000d40 	.word	0x20000d40
 8002c84:	20000d3c 	.word	0x20000d3c

08002c88 <vPortFree>:
{
 8002c88:	b510      	push	{r4, lr}
	if( pv != NULL )
 8002c8a:	4604      	mov	r4, r0
 8002c8c:	b370      	cbz	r0, 8002cec <vPortFree+0x64>
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
 8002c8e:	4a18      	ldr	r2, [pc, #96]	; (8002cf0 <vPortFree+0x68>)
 8002c90:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8002c94:	6812      	ldr	r2, [r2, #0]
 8002c96:	4213      	tst	r3, r2
 8002c98:	d108      	bne.n	8002cac <vPortFree+0x24>
 8002c9a:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002c9e:	f383 8811 	msr	BASEPRI, r3
 8002ca2:	f3bf 8f6f 	isb	sy
 8002ca6:	f3bf 8f4f 	dsb	sy
 8002caa:	e7fe      	b.n	8002caa <vPortFree+0x22>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
 8002cac:	f850 1c08 	ldr.w	r1, [r0, #-8]
 8002cb0:	b141      	cbz	r1, 8002cc4 <vPortFree+0x3c>
 8002cb2:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002cb6:	f383 8811 	msr	BASEPRI, r3
 8002cba:	f3bf 8f6f 	isb	sy
 8002cbe:	f3bf 8f4f 	dsb	sy
 8002cc2:	e7fe      	b.n	8002cc2 <vPortFree+0x3a>
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
 8002cc4:	ea23 0302 	bic.w	r3, r3, r2
 8002cc8:	f840 3c04 	str.w	r3, [r0, #-4]
				vTaskSuspendAll();
 8002ccc:	f000 f978 	bl	8002fc0 <vTaskSuspendAll>
					xFreeBytesRemaining += pxLink->xBlockSize;
 8002cd0:	4a08      	ldr	r2, [pc, #32]	; (8002cf4 <vPortFree+0x6c>)
 8002cd2:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8002cd6:	6811      	ldr	r1, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002cd8:	f1a4 0008 	sub.w	r0, r4, #8
					xFreeBytesRemaining += pxLink->xBlockSize;
 8002cdc:	440b      	add	r3, r1
 8002cde:	6013      	str	r3, [r2, #0]
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 8002ce0:	f7ff ff20 	bl	8002b24 <prvInsertBlockIntoFreeList>
}
 8002ce4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
				( void ) xTaskResumeAll();
 8002ce8:	f000 ba04 	b.w	80030f4 <xTaskResumeAll>
 8002cec:	bd10      	pop	{r4, pc}
 8002cee:	bf00      	nop
 8002cf0:	20000d38 	.word	0x20000d38
 8002cf4:	20000d3c 	.word	0x20000d3c

08002cf8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8002cf8:	4a06      	ldr	r2, [pc, #24]	; (8002d14 <prvResetNextTaskUnblockTime+0x1c>)
 8002cfa:	6813      	ldr	r3, [r2, #0]
 8002cfc:	6819      	ldr	r1, [r3, #0]
 8002cfe:	4b06      	ldr	r3, [pc, #24]	; (8002d18 <prvResetNextTaskUnblockTime+0x20>)
 8002d00:	b919      	cbnz	r1, 8002d0a <prvResetNextTaskUnblockTime+0x12>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 8002d02:	f04f 32ff 	mov.w	r2, #4294967295
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8002d06:	601a      	str	r2, [r3, #0]
 8002d08:	4770      	bx	lr
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8002d0a:	6812      	ldr	r2, [r2, #0]
 8002d0c:	68d2      	ldr	r2, [r2, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 8002d0e:	68d2      	ldr	r2, [r2, #12]
 8002d10:	6852      	ldr	r2, [r2, #4]
 8002d12:	e7f8      	b.n	8002d06 <prvResetNextTaskUnblockTime+0xe>
 8002d14:	20000d50 	.word	0x20000d50
 8002d18:	20000e28 	.word	0x20000e28

08002d1c <prvAddCurrentTaskToDelayedList>:
#endif /* configUSE_TASK_NOTIFICATIONS */
/*-----------------------------------------------------------*/


static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
 8002d1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
 8002d1e:	4b1b      	ldr	r3, [pc, #108]	; (8002d8c <prvAddCurrentTaskToDelayedList+0x70>)
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002d20:	4e1b      	ldr	r6, [pc, #108]	; (8002d90 <prvAddCurrentTaskToDelayedList+0x74>)
const TickType_t xConstTickCount = xTickCount;
 8002d22:	681d      	ldr	r5, [r3, #0]
{
 8002d24:	4604      	mov	r4, r0
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002d26:	6830      	ldr	r0, [r6, #0]
 8002d28:	3004      	adds	r0, #4
{
 8002d2a:	460f      	mov	r7, r1
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
 8002d2c:	f7ff fd88 	bl	8002840 <uxListRemove>
 8002d30:	4633      	mov	r3, r6
 8002d32:	b940      	cbnz	r0, 8002d46 <prvAddCurrentTaskToDelayedList+0x2a>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
 8002d34:	6831      	ldr	r1, [r6, #0]
 8002d36:	4e17      	ldr	r6, [pc, #92]	; (8002d94 <prvAddCurrentTaskToDelayedList+0x78>)
 8002d38:	6ac9      	ldr	r1, [r1, #44]	; 0x2c
 8002d3a:	6832      	ldr	r2, [r6, #0]
 8002d3c:	2001      	movs	r0, #1
 8002d3e:	4088      	lsls	r0, r1
 8002d40:	ea22 0200 	bic.w	r2, r2, r0
 8002d44:	6032      	str	r2, [r6, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
 8002d46:	1c62      	adds	r2, r4, #1
 8002d48:	d107      	bne.n	8002d5a <prvAddCurrentTaskToDelayedList+0x3e>
 8002d4a:	b137      	cbz	r7, 8002d5a <prvAddCurrentTaskToDelayedList+0x3e>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d4c:	6819      	ldr	r1, [r3, #0]
 8002d4e:	4812      	ldr	r0, [pc, #72]	; (8002d98 <prvAddCurrentTaskToDelayedList+0x7c>)
 8002d50:	3104      	adds	r1, #4

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
 8002d52:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d56:	f7ff bd50 	b.w	80027fa <vListInsertEnd>
			xTimeToWake = xConstTickCount + xTicksToWait;
 8002d5a:	442c      	add	r4, r5
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8002d5c:	681a      	ldr	r2, [r3, #0]
			if( xTimeToWake < xConstTickCount )
 8002d5e:	42a5      	cmp	r5, r4
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
 8002d60:	6054      	str	r4, [r2, #4]
			if( xTimeToWake < xConstTickCount )
 8002d62:	d907      	bls.n	8002d74 <prvAddCurrentTaskToDelayedList+0x58>
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d64:	4a0d      	ldr	r2, [pc, #52]	; (8002d9c <prvAddCurrentTaskToDelayedList+0x80>)
 8002d66:	6810      	ldr	r0, [r2, #0]
 8002d68:	6819      	ldr	r1, [r3, #0]
}
 8002d6a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d6e:	3104      	adds	r1, #4
 8002d70:	f7ff bd4f 	b.w	8002812 <vListInsert>
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
 8002d74:	4a0a      	ldr	r2, [pc, #40]	; (8002da0 <prvAddCurrentTaskToDelayedList+0x84>)
 8002d76:	6810      	ldr	r0, [r2, #0]
 8002d78:	6819      	ldr	r1, [r3, #0]
 8002d7a:	3104      	adds	r1, #4
 8002d7c:	f7ff fd49 	bl	8002812 <vListInsert>
				if( xTimeToWake < xNextTaskUnblockTime )
 8002d80:	4b08      	ldr	r3, [pc, #32]	; (8002da4 <prvAddCurrentTaskToDelayedList+0x88>)
 8002d82:	681a      	ldr	r2, [r3, #0]
 8002d84:	4294      	cmp	r4, r2
					xNextTaskUnblockTime = xTimeToWake;
 8002d86:	bf38      	it	cc
 8002d88:	601c      	strcc	r4, [r3, #0]
 8002d8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002d8c:	20000e70 	.word	0x20000e70
 8002d90:	20000d4c 	.word	0x20000d4c
 8002d94:	20000df8 	.word	0x20000df8
 8002d98:	20000e48 	.word	0x20000e48
 8002d9c:	20000d54 	.word	0x20000d54
 8002da0:	20000d50 	.word	0x20000d50
 8002da4:	20000e28 	.word	0x20000e28

08002da8 <xTaskCreate>:
	{
 8002da8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002dac:	ea4f 0a82 	mov.w	sl, r2, lsl #2
	{
 8002db0:	4680      	mov	r8, r0
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002db2:	4650      	mov	r0, sl
	{
 8002db4:	460f      	mov	r7, r1
 8002db6:	4699      	mov	r9, r3
 8002db8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002dba:	f7ff fed7 	bl	8002b6c <pvPortMalloc>
			if( pxStack != NULL )
 8002dbe:	4605      	mov	r5, r0
 8002dc0:	2800      	cmp	r0, #0
 8002dc2:	f000 8096 	beq.w	8002ef2 <xTaskCreate+0x14a>
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
 8002dc6:	2054      	movs	r0, #84	; 0x54
 8002dc8:	f7ff fed0 	bl	8002b6c <pvPortMalloc>
				if( pxNewTCB != NULL )
 8002dcc:	4604      	mov	r4, r0
 8002dce:	2800      	cmp	r0, #0
 8002dd0:	f000 808c 	beq.w	8002eec <xTaskCreate+0x144>
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8002dd4:	f1aa 0a04 	sub.w	sl, sl, #4
					pxNewTCB->pxStack = pxStack;
 8002dd8:	6305      	str	r5, [r0, #48]	; 0x30
		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
 8002dda:	4455      	add	r5, sl
 8002ddc:	1e7b      	subs	r3, r7, #1
		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
 8002dde:	f025 0a07 	bic.w	sl, r5, #7
 8002de2:	f100 0234 	add.w	r2, r0, #52	; 0x34
 8002de6:	370f      	adds	r7, #15
		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
 8002de8:	7859      	ldrb	r1, [r3, #1]
 8002dea:	f802 1b01 	strb.w	r1, [r2], #1
		if( pcName[ x ] == 0x00 )
 8002dee:	f813 1f01 	ldrb.w	r1, [r3, #1]!
 8002df2:	b109      	cbz	r1, 8002df8 <xTaskCreate+0x50>
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 8002df4:	42bb      	cmp	r3, r7
 8002df6:	d1f7      	bne.n	8002de8 <xTaskCreate+0x40>
 8002df8:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 8002dfa:	2d06      	cmp	r5, #6
 8002dfc:	bf28      	it	cs
 8002dfe:	2506      	movcs	r5, #6
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002e00:	f04f 0b00 	mov.w	fp, #0
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002e04:	1d27      	adds	r7, r4, #4
	pxNewTCB->uxPriority = uxPriority;
 8002e06:	62e5      	str	r5, [r4, #44]	; 0x2c
		pxNewTCB->uxBasePriority = uxPriority;
 8002e08:	6465      	str	r5, [r4, #68]	; 0x44
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002e0a:	4638      	mov	r0, r7
	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 8002e0c:	f884 b043 	strb.w	fp, [r4, #67]	; 0x43
		pxNewTCB->uxMutexesHeld = 0;
 8002e10:	f8c4 b048 	str.w	fp, [r4, #72]	; 0x48
	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
 8002e14:	f7ff fcee 	bl	80027f4 <vListInitialiseItem>
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002e18:	f1c5 0507 	rsb	r5, r5, #7
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
 8002e1c:	f104 0018 	add.w	r0, r4, #24
 8002e20:	f7ff fce8 	bl	80027f4 <vListInitialiseItem>
		pxNewTCB->ulNotifiedValue = 0;
 8002e24:	f8c4 b04c 	str.w	fp, [r4, #76]	; 0x4c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
 8002e28:	6124      	str	r4, [r4, #16]
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8002e2a:	61a5      	str	r5, [r4, #24]
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
 8002e2c:	6264      	str	r4, [r4, #36]	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
 8002e2e:	f884 b050 	strb.w	fp, [r4, #80]	; 0x50
		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 8002e32:	464a      	mov	r2, r9
 8002e34:	4641      	mov	r1, r8
 8002e36:	4650      	mov	r0, sl
 8002e38:	f7ff fd44 	bl	80028c4 <pxPortInitialiseStack>
 8002e3c:	6020      	str	r0, [r4, #0]
	if( ( void * ) pxCreatedTask != NULL )
 8002e3e:	b106      	cbz	r6, 8002e42 <xTaskCreate+0x9a>
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 8002e40:	6034      	str	r4, [r6, #0]
	taskENTER_CRITICAL();
 8002e42:	f7ff fd67 	bl	8002914 <vPortEnterCritical>
		uxCurrentNumberOfTasks++;
 8002e46:	4b32      	ldr	r3, [pc, #200]	; (8002f10 <xTaskCreate+0x168>)
		if( pxCurrentTCB == NULL )
 8002e48:	4e32      	ldr	r6, [pc, #200]	; (8002f14 <xTaskCreate+0x16c>)
		uxCurrentNumberOfTasks++;
 8002e4a:	681a      	ldr	r2, [r3, #0]
 8002e4c:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 8002f40 <xTaskCreate+0x198>
 8002e50:	3201      	adds	r2, #1
 8002e52:	601a      	str	r2, [r3, #0]
		if( pxCurrentTCB == NULL )
 8002e54:	6835      	ldr	r5, [r6, #0]
 8002e56:	2d00      	cmp	r5, #0
 8002e58:	d14e      	bne.n	8002ef8 <xTaskCreate+0x150>
			pxCurrentTCB = pxNewTCB;
 8002e5a:	6034      	str	r4, [r6, #0]
			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 8002e5c:	681b      	ldr	r3, [r3, #0]
 8002e5e:	2b01      	cmp	r3, #1
 8002e60:	d11d      	bne.n	8002e9e <xTaskCreate+0xf6>
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 8002e62:	eb08 0005 	add.w	r0, r8, r5
 8002e66:	3514      	adds	r5, #20
 8002e68:	f7ff fcb9 	bl	80027de <vListInitialise>
	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
 8002e6c:	2d8c      	cmp	r5, #140	; 0x8c
 8002e6e:	d1f8      	bne.n	8002e62 <xTaskCreate+0xba>
	vListInitialise( &xDelayedTaskList1 );
 8002e70:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8002f44 <xTaskCreate+0x19c>
	vListInitialise( &xDelayedTaskList2 );
 8002e74:	4d28      	ldr	r5, [pc, #160]	; (8002f18 <xTaskCreate+0x170>)
	vListInitialise( &xDelayedTaskList1 );
 8002e76:	4648      	mov	r0, r9
 8002e78:	f7ff fcb1 	bl	80027de <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8002e7c:	4628      	mov	r0, r5
 8002e7e:	f7ff fcae 	bl	80027de <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8002e82:	4826      	ldr	r0, [pc, #152]	; (8002f1c <xTaskCreate+0x174>)
 8002e84:	f7ff fcab 	bl	80027de <vListInitialise>
		vListInitialise( &xTasksWaitingTermination );
 8002e88:	4825      	ldr	r0, [pc, #148]	; (8002f20 <xTaskCreate+0x178>)
 8002e8a:	f7ff fca8 	bl	80027de <vListInitialise>
		vListInitialise( &xSuspendedTaskList );
 8002e8e:	4825      	ldr	r0, [pc, #148]	; (8002f24 <xTaskCreate+0x17c>)
 8002e90:	f7ff fca5 	bl	80027de <vListInitialise>
	pxDelayedTaskList = &xDelayedTaskList1;
 8002e94:	4b24      	ldr	r3, [pc, #144]	; (8002f28 <xTaskCreate+0x180>)
 8002e96:	f8c3 9000 	str.w	r9, [r3]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8002e9a:	4b24      	ldr	r3, [pc, #144]	; (8002f2c <xTaskCreate+0x184>)
 8002e9c:	601d      	str	r5, [r3, #0]
		uxTaskNumber++;
 8002e9e:	4a24      	ldr	r2, [pc, #144]	; (8002f30 <xTaskCreate+0x188>)
		prvAddTaskToReadyList( pxNewTCB );
 8002ea0:	4924      	ldr	r1, [pc, #144]	; (8002f34 <xTaskCreate+0x18c>)
		uxTaskNumber++;
 8002ea2:	6813      	ldr	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8002ea4:	6808      	ldr	r0, [r1, #0]
		uxTaskNumber++;
 8002ea6:	3301      	adds	r3, #1
 8002ea8:	6013      	str	r3, [r2, #0]
		prvAddTaskToReadyList( pxNewTCB );
 8002eaa:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8002eac:	2501      	movs	r5, #1
 8002eae:	fa05 f302 	lsl.w	r3, r5, r2
 8002eb2:	4303      	orrs	r3, r0
 8002eb4:	2014      	movs	r0, #20
 8002eb6:	600b      	str	r3, [r1, #0]
 8002eb8:	fb00 8002 	mla	r0, r0, r2, r8
 8002ebc:	4639      	mov	r1, r7
 8002ebe:	f7ff fc9c 	bl	80027fa <vListInsertEnd>
	taskEXIT_CRITICAL();
 8002ec2:	f7ff fd49 	bl	8002958 <vPortExitCritical>
	if( xSchedulerRunning != pdFALSE )
 8002ec6:	4b1c      	ldr	r3, [pc, #112]	; (8002f38 <xTaskCreate+0x190>)
 8002ec8:	681b      	ldr	r3, [r3, #0]
 8002eca:	b163      	cbz	r3, 8002ee6 <xTaskCreate+0x13e>
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
 8002ecc:	6833      	ldr	r3, [r6, #0]
 8002ece:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002ed0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002ed2:	429a      	cmp	r2, r3
 8002ed4:	d207      	bcs.n	8002ee6 <xTaskCreate+0x13e>
			taskYIELD_IF_USING_PREEMPTION();
 8002ed6:	4b19      	ldr	r3, [pc, #100]	; (8002f3c <xTaskCreate+0x194>)
 8002ed8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8002edc:	601a      	str	r2, [r3, #0]
 8002ede:	f3bf 8f4f 	dsb	sy
 8002ee2:	f3bf 8f6f 	isb	sy
	}
 8002ee6:	4628      	mov	r0, r5
 8002ee8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
					vPortFree( pxStack );
 8002eec:	4628      	mov	r0, r5
 8002eee:	f7ff fecb 	bl	8002c88 <vPortFree>
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 8002ef2:	f04f 35ff 	mov.w	r5, #4294967295
 8002ef6:	e7f6      	b.n	8002ee6 <xTaskCreate+0x13e>
			if( xSchedulerRunning == pdFALSE )
 8002ef8:	4b0f      	ldr	r3, [pc, #60]	; (8002f38 <xTaskCreate+0x190>)
 8002efa:	681b      	ldr	r3, [r3, #0]
 8002efc:	2b00      	cmp	r3, #0
 8002efe:	d1ce      	bne.n	8002e9e <xTaskCreate+0xf6>
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
 8002f00:	6833      	ldr	r3, [r6, #0]
 8002f02:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002f04:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002f06:	429a      	cmp	r2, r3
					pxCurrentTCB = pxNewTCB;
 8002f08:	bf98      	it	ls
 8002f0a:	6034      	strls	r4, [r6, #0]
 8002f0c:	e7c7      	b.n	8002e9e <xTaskCreate+0xf6>
 8002f0e:	bf00      	nop
 8002f10:	20000de4 	.word	0x20000de4
 8002f14:	20000d4c 	.word	0x20000d4c
 8002f18:	20000e10 	.word	0x20000e10
 8002f1c:	20000e30 	.word	0x20000e30
 8002f20:	20000e5c 	.word	0x20000e5c
 8002f24:	20000e48 	.word	0x20000e48
 8002f28:	20000d50 	.word	0x20000d50
 8002f2c:	20000d54 	.word	0x20000d54
 8002f30:	20000df4 	.word	0x20000df4
 8002f34:	20000df8 	.word	0x20000df8
 8002f38:	20000e44 	.word	0x20000e44
 8002f3c:	e000ed04 	.word	0xe000ed04
 8002f40:	20000d58 	.word	0x20000d58
 8002f44:	20000dfc 	.word	0x20000dfc

08002f48 <vTaskStartScheduler>:
{
 8002f48:	b513      	push	{r0, r1, r4, lr}
		xReturn = xTaskCreate(	prvIdleTask,
 8002f4a:	4b17      	ldr	r3, [pc, #92]	; (8002fa8 <vTaskStartScheduler+0x60>)
 8002f4c:	9301      	str	r3, [sp, #4]
 8002f4e:	2400      	movs	r4, #0
 8002f50:	9400      	str	r4, [sp, #0]
 8002f52:	4623      	mov	r3, r4
 8002f54:	2280      	movs	r2, #128	; 0x80
 8002f56:	4915      	ldr	r1, [pc, #84]	; (8002fac <vTaskStartScheduler+0x64>)
 8002f58:	4815      	ldr	r0, [pc, #84]	; (8002fb0 <vTaskStartScheduler+0x68>)
 8002f5a:	f7ff ff25 	bl	8002da8 <xTaskCreate>
	if( xReturn == pdPASS )
 8002f5e:	2801      	cmp	r0, #1
 8002f60:	d114      	bne.n	8002f8c <vTaskStartScheduler+0x44>
 8002f62:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f66:	f383 8811 	msr	BASEPRI, r3
 8002f6a:	f3bf 8f6f 	isb	sy
 8002f6e:	f3bf 8f4f 	dsb	sy
		xNextTaskUnblockTime = portMAX_DELAY;
 8002f72:	4b10      	ldr	r3, [pc, #64]	; (8002fb4 <vTaskStartScheduler+0x6c>)
 8002f74:	f04f 32ff 	mov.w	r2, #4294967295
 8002f78:	601a      	str	r2, [r3, #0]
		xSchedulerRunning = pdTRUE;
 8002f7a:	4b0f      	ldr	r3, [pc, #60]	; (8002fb8 <vTaskStartScheduler+0x70>)
 8002f7c:	6018      	str	r0, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
 8002f7e:	4b0f      	ldr	r3, [pc, #60]	; (8002fbc <vTaskStartScheduler+0x74>)
 8002f80:	601c      	str	r4, [r3, #0]
}
 8002f82:	b002      	add	sp, #8
 8002f84:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		if( xPortStartScheduler() != pdFALSE )
 8002f88:	f7ff bd56 	b.w	8002a38 <xPortStartScheduler>
		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
 8002f8c:	3001      	adds	r0, #1
 8002f8e:	d108      	bne.n	8002fa2 <vTaskStartScheduler+0x5a>
 8002f90:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002f94:	f383 8811 	msr	BASEPRI, r3
 8002f98:	f3bf 8f6f 	isb	sy
 8002f9c:	f3bf 8f4f 	dsb	sy
 8002fa0:	e7fe      	b.n	8002fa0 <vTaskStartScheduler+0x58>
}
 8002fa2:	b002      	add	sp, #8
 8002fa4:	bd10      	pop	{r4, pc}
 8002fa6:	bf00      	nop
 8002fa8:	20000e24 	.word	0x20000e24
 8002fac:	08003a34 	.word	0x08003a34
 8002fb0:	0800322d 	.word	0x0800322d
 8002fb4:	20000e28 	.word	0x20000e28
 8002fb8:	20000e44 	.word	0x20000e44
 8002fbc:	20000e70 	.word	0x20000e70

08002fc0 <vTaskSuspendAll>:
	++uxSchedulerSuspended;
 8002fc0:	4a02      	ldr	r2, [pc, #8]	; (8002fcc <vTaskSuspendAll+0xc>)
 8002fc2:	6813      	ldr	r3, [r2, #0]
 8002fc4:	3301      	adds	r3, #1
 8002fc6:	6013      	str	r3, [r2, #0]
 8002fc8:	4770      	bx	lr
 8002fca:	bf00      	nop
 8002fcc:	20000df0 	.word	0x20000df0

08002fd0 <xTaskIncrementTick>:
{
 8002fd0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8002fd4:	4b3c      	ldr	r3, [pc, #240]	; (80030c8 <xTaskIncrementTick+0xf8>)
 8002fd6:	681b      	ldr	r3, [r3, #0]
 8002fd8:	2b00      	cmp	r3, #0
 8002fda:	d153      	bne.n	8003084 <xTaskIncrementTick+0xb4>
		const TickType_t xConstTickCount = xTickCount + 1;
 8002fdc:	4b3b      	ldr	r3, [pc, #236]	; (80030cc <xTaskIncrementTick+0xfc>)
 8002fde:	681c      	ldr	r4, [r3, #0]
 8002fe0:	3401      	adds	r4, #1
		xTickCount = xConstTickCount;
 8002fe2:	601c      	str	r4, [r3, #0]
		if( xConstTickCount == ( TickType_t ) 0U )
 8002fe4:	b9bc      	cbnz	r4, 8003016 <xTaskIncrementTick+0x46>
			taskSWITCH_DELAYED_LISTS();
 8002fe6:	4b3a      	ldr	r3, [pc, #232]	; (80030d0 <xTaskIncrementTick+0x100>)
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	6812      	ldr	r2, [r2, #0]
 8002fec:	b142      	cbz	r2, 8003000 <xTaskIncrementTick+0x30>
 8002fee:	f04f 0350 	mov.w	r3, #80	; 0x50
 8002ff2:	f383 8811 	msr	BASEPRI, r3
 8002ff6:	f3bf 8f6f 	isb	sy
 8002ffa:	f3bf 8f4f 	dsb	sy
 8002ffe:	e7fe      	b.n	8002ffe <xTaskIncrementTick+0x2e>
 8003000:	4a34      	ldr	r2, [pc, #208]	; (80030d4 <xTaskIncrementTick+0x104>)
 8003002:	6819      	ldr	r1, [r3, #0]
 8003004:	6810      	ldr	r0, [r2, #0]
 8003006:	6018      	str	r0, [r3, #0]
 8003008:	6011      	str	r1, [r2, #0]
 800300a:	4a33      	ldr	r2, [pc, #204]	; (80030d8 <xTaskIncrementTick+0x108>)
 800300c:	6813      	ldr	r3, [r2, #0]
 800300e:	3301      	adds	r3, #1
 8003010:	6013      	str	r3, [r2, #0]
 8003012:	f7ff fe71 	bl	8002cf8 <prvResetNextTaskUnblockTime>
		if( xConstTickCount >= xNextTaskUnblockTime )
 8003016:	4d31      	ldr	r5, [pc, #196]	; (80030dc <xTaskIncrementTick+0x10c>)
 8003018:	4f31      	ldr	r7, [pc, #196]	; (80030e0 <xTaskIncrementTick+0x110>)
 800301a:	682b      	ldr	r3, [r5, #0]
 800301c:	429c      	cmp	r4, r3
 800301e:	f04f 0b00 	mov.w	fp, #0
 8003022:	d33e      	bcc.n	80030a2 <xTaskIncrementTick+0xd2>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003024:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80030d0 <xTaskIncrementTick+0x100>
					prvAddTaskToReadyList( pxTCB );
 8003028:	f8df 90c4 	ldr.w	r9, [pc, #196]	; 80030f0 <xTaskIncrementTick+0x120>
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 800302c:	f8d8 2000 	ldr.w	r2, [r8]
 8003030:	6812      	ldr	r2, [r2, #0]
 8003032:	bb72      	cbnz	r2, 8003092 <xTaskIncrementTick+0xc2>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 8003034:	f04f 32ff 	mov.w	r2, #4294967295
 8003038:	602a      	str	r2, [r5, #0]
					break;
 800303a:	e032      	b.n	80030a2 <xTaskIncrementTick+0xd2>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800303c:	f106 0a04 	add.w	sl, r6, #4
 8003040:	4650      	mov	r0, sl
 8003042:	f7ff fbfd 	bl	8002840 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 8003046:	6ab1      	ldr	r1, [r6, #40]	; 0x28
 8003048:	b119      	cbz	r1, 8003052 <xTaskIncrementTick+0x82>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 800304a:	f106 0018 	add.w	r0, r6, #24
 800304e:	f7ff fbf7 	bl	8002840 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003052:	6af0      	ldr	r0, [r6, #44]	; 0x2c
 8003054:	f8d9 3000 	ldr.w	r3, [r9]
 8003058:	2201      	movs	r2, #1
 800305a:	fa02 f100 	lsl.w	r1, r2, r0
 800305e:	4319      	orrs	r1, r3
 8003060:	4b20      	ldr	r3, [pc, #128]	; (80030e4 <xTaskIncrementTick+0x114>)
 8003062:	f8c9 1000 	str.w	r1, [r9]
 8003066:	f04f 0e14 	mov.w	lr, #20
 800306a:	4651      	mov	r1, sl
 800306c:	fb0e 3000 	mla	r0, lr, r0, r3
 8003070:	f7ff fbc3 	bl	80027fa <vListInsertEnd>
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 8003074:	6838      	ldr	r0, [r7, #0]
 8003076:	6af1      	ldr	r1, [r6, #44]	; 0x2c
 8003078:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
							xSwitchRequired = pdTRUE;
 800307a:	4291      	cmp	r1, r2
 800307c:	bf28      	it	cs
 800307e:	f04f 0b01 	movcs.w	fp, #1
 8003082:	e7d3      	b.n	800302c <xTaskIncrementTick+0x5c>
		++uxPendedTicks;
 8003084:	4a18      	ldr	r2, [pc, #96]	; (80030e8 <xTaskIncrementTick+0x118>)
 8003086:	6813      	ldr	r3, [r2, #0]
 8003088:	3301      	adds	r3, #1
 800308a:	6013      	str	r3, [r2, #0]
BaseType_t xSwitchRequired = pdFALSE;
 800308c:	f04f 0b00 	mov.w	fp, #0
 8003090:	e011      	b.n	80030b6 <xTaskIncrementTick+0xe6>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 8003092:	f8d8 2000 	ldr.w	r2, [r8]
 8003096:	68d2      	ldr	r2, [r2, #12]
 8003098:	68d6      	ldr	r6, [r2, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800309a:	6871      	ldr	r1, [r6, #4]
					if( xConstTickCount < xItemValue )
 800309c:	428c      	cmp	r4, r1
 800309e:	d2cd      	bcs.n	800303c <xTaskIncrementTick+0x6c>
						xNextTaskUnblockTime = xItemValue;
 80030a0:	6029      	str	r1, [r5, #0]
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 80030a2:	683a      	ldr	r2, [r7, #0]
 80030a4:	4b0f      	ldr	r3, [pc, #60]	; (80030e4 <xTaskIncrementTick+0x114>)
 80030a6:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
 80030a8:	2214      	movs	r2, #20
 80030aa:	434a      	muls	r2, r1
 80030ac:	589a      	ldr	r2, [r3, r2]
				xSwitchRequired = pdTRUE;
 80030ae:	2a02      	cmp	r2, #2
 80030b0:	bf28      	it	cs
 80030b2:	f04f 0b01 	movcs.w	fp, #1
		if( xYieldPending != pdFALSE )
 80030b6:	4a0d      	ldr	r2, [pc, #52]	; (80030ec <xTaskIncrementTick+0x11c>)
 80030b8:	6812      	ldr	r2, [r2, #0]
			xSwitchRequired = pdTRUE;
 80030ba:	2a00      	cmp	r2, #0
 80030bc:	bf18      	it	ne
 80030be:	f04f 0b01 	movne.w	fp, #1
}
 80030c2:	4658      	mov	r0, fp
 80030c4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80030c8:	20000df0 	.word	0x20000df0
 80030cc:	20000e70 	.word	0x20000e70
 80030d0:	20000d50 	.word	0x20000d50
 80030d4:	20000d54 	.word	0x20000d54
 80030d8:	20000e2c 	.word	0x20000e2c
 80030dc:	20000e28 	.word	0x20000e28
 80030e0:	20000d4c 	.word	0x20000d4c
 80030e4:	20000d58 	.word	0x20000d58
 80030e8:	20000dec 	.word	0x20000dec
 80030ec:	20000e74 	.word	0x20000e74
 80030f0:	20000df8 	.word	0x20000df8

080030f4 <xTaskResumeAll>:
{
 80030f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	configASSERT( uxSchedulerSuspended );
 80030f8:	4c31      	ldr	r4, [pc, #196]	; (80031c0 <xTaskResumeAll+0xcc>)
 80030fa:	6823      	ldr	r3, [r4, #0]
 80030fc:	b943      	cbnz	r3, 8003110 <xTaskResumeAll+0x1c>
 80030fe:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003102:	f383 8811 	msr	BASEPRI, r3
 8003106:	f3bf 8f6f 	isb	sy
 800310a:	f3bf 8f4f 	dsb	sy
 800310e:	e7fe      	b.n	800310e <xTaskResumeAll+0x1a>
	taskENTER_CRITICAL();
 8003110:	f7ff fc00 	bl	8002914 <vPortEnterCritical>
		--uxSchedulerSuspended;
 8003114:	6823      	ldr	r3, [r4, #0]
 8003116:	3b01      	subs	r3, #1
 8003118:	6023      	str	r3, [r4, #0]
		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800311a:	6824      	ldr	r4, [r4, #0]
 800311c:	b12c      	cbz	r4, 800312a <xTaskResumeAll+0x36>
BaseType_t xAlreadyYielded = pdFALSE;
 800311e:	2400      	movs	r4, #0
	taskEXIT_CRITICAL();
 8003120:	f7ff fc1a 	bl	8002958 <vPortExitCritical>
}
 8003124:	4620      	mov	r0, r4
 8003126:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 800312a:	4b26      	ldr	r3, [pc, #152]	; (80031c4 <xTaskResumeAll+0xd0>)
 800312c:	681b      	ldr	r3, [r3, #0]
 800312e:	2b00      	cmp	r3, #0
 8003130:	d0f5      	beq.n	800311e <xTaskResumeAll+0x2a>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 8003132:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 80031dc <xTaskResumeAll+0xe8>
					prvAddTaskToReadyList( pxTCB );
 8003136:	4f24      	ldr	r7, [pc, #144]	; (80031c8 <xTaskResumeAll+0xd4>)
 8003138:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 80031e0 <xTaskResumeAll+0xec>
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 800313c:	f8d9 3000 	ldr.w	r3, [r9]
 8003140:	b9e3      	cbnz	r3, 800317c <xTaskResumeAll+0x88>
				if( pxTCB != NULL )
 8003142:	b10c      	cbz	r4, 8003148 <xTaskResumeAll+0x54>
					prvResetNextTaskUnblockTime();
 8003144:	f7ff fdd8 	bl	8002cf8 <prvResetNextTaskUnblockTime>
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 8003148:	4d20      	ldr	r5, [pc, #128]	; (80031cc <xTaskResumeAll+0xd8>)
 800314a:	682c      	ldr	r4, [r5, #0]
					if( uxPendedCounts > ( UBaseType_t ) 0U )
 800314c:	b144      	cbz	r4, 8003160 <xTaskResumeAll+0x6c>
								xYieldPending = pdTRUE;
 800314e:	4e20      	ldr	r6, [pc, #128]	; (80031d0 <xTaskResumeAll+0xdc>)
 8003150:	2701      	movs	r7, #1
							if( xTaskIncrementTick() != pdFALSE )
 8003152:	f7ff ff3d 	bl	8002fd0 <xTaskIncrementTick>
 8003156:	b100      	cbz	r0, 800315a <xTaskResumeAll+0x66>
								xYieldPending = pdTRUE;
 8003158:	6037      	str	r7, [r6, #0]
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 800315a:	3c01      	subs	r4, #1
 800315c:	d1f9      	bne.n	8003152 <xTaskResumeAll+0x5e>
						uxPendedTicks = 0;
 800315e:	602c      	str	r4, [r5, #0]
				if( xYieldPending != pdFALSE )
 8003160:	4b1b      	ldr	r3, [pc, #108]	; (80031d0 <xTaskResumeAll+0xdc>)
 8003162:	681b      	ldr	r3, [r3, #0]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d0da      	beq.n	800311e <xTaskResumeAll+0x2a>
					taskYIELD_IF_USING_PREEMPTION();
 8003168:	4b1a      	ldr	r3, [pc, #104]	; (80031d4 <xTaskResumeAll+0xe0>)
 800316a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 800316e:	601a      	str	r2, [r3, #0]
 8003170:	f3bf 8f4f 	dsb	sy
 8003174:	f3bf 8f6f 	isb	sy
						xAlreadyYielded = pdTRUE;
 8003178:	2401      	movs	r4, #1
 800317a:	e7d1      	b.n	8003120 <xTaskResumeAll+0x2c>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 800317c:	f8d9 300c 	ldr.w	r3, [r9, #12]
 8003180:	68dc      	ldr	r4, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003182:	1d26      	adds	r6, r4, #4
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 8003184:	f104 0018 	add.w	r0, r4, #24
 8003188:	f7ff fb5a 	bl	8002840 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800318c:	4630      	mov	r0, r6
 800318e:	f7ff fb57 	bl	8002840 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 8003192:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8003194:	6839      	ldr	r1, [r7, #0]
 8003196:	2501      	movs	r5, #1
 8003198:	fa05 f302 	lsl.w	r3, r5, r2
 800319c:	2014      	movs	r0, #20
 800319e:	430b      	orrs	r3, r1
 80031a0:	fb00 8002 	mla	r0, r0, r2, r8
 80031a4:	4631      	mov	r1, r6
 80031a6:	603b      	str	r3, [r7, #0]
 80031a8:	f7ff fb27 	bl	80027fa <vListInsertEnd>
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80031ac:	4b0a      	ldr	r3, [pc, #40]	; (80031d8 <xTaskResumeAll+0xe4>)
 80031ae:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 80031b0:	681b      	ldr	r3, [r3, #0]
 80031b2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80031b4:	429a      	cmp	r2, r3
						xYieldPending = pdTRUE;
 80031b6:	bf24      	itt	cs
 80031b8:	4b05      	ldrcs	r3, [pc, #20]	; (80031d0 <xTaskResumeAll+0xdc>)
 80031ba:	601d      	strcs	r5, [r3, #0]
 80031bc:	e7be      	b.n	800313c <xTaskResumeAll+0x48>
 80031be:	bf00      	nop
 80031c0:	20000df0 	.word	0x20000df0
 80031c4:	20000de4 	.word	0x20000de4
 80031c8:	20000df8 	.word	0x20000df8
 80031cc:	20000dec 	.word	0x20000dec
 80031d0:	20000e74 	.word	0x20000e74
 80031d4:	e000ed04 	.word	0xe000ed04
 80031d8:	20000d4c 	.word	0x20000d4c
 80031dc:	20000e30 	.word	0x20000e30
 80031e0:	20000d58 	.word	0x20000d58

080031e4 <vTaskDelay>:
	{
 80031e4:	b508      	push	{r3, lr}
		if( xTicksToDelay > ( TickType_t ) 0U )
 80031e6:	b940      	cbnz	r0, 80031fa <vTaskDelay+0x16>
			portYIELD_WITHIN_API();
 80031e8:	4b0e      	ldr	r3, [pc, #56]	; (8003224 <vTaskDelay+0x40>)
 80031ea:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 80031ee:	601a      	str	r2, [r3, #0]
 80031f0:	f3bf 8f4f 	dsb	sy
 80031f4:	f3bf 8f6f 	isb	sy
 80031f8:	bd08      	pop	{r3, pc}
			configASSERT( uxSchedulerSuspended == 0 );
 80031fa:	4b0b      	ldr	r3, [pc, #44]	; (8003228 <vTaskDelay+0x44>)
 80031fc:	6819      	ldr	r1, [r3, #0]
 80031fe:	b141      	cbz	r1, 8003212 <vTaskDelay+0x2e>
 8003200:	f04f 0350 	mov.w	r3, #80	; 0x50
 8003204:	f383 8811 	msr	BASEPRI, r3
 8003208:	f3bf 8f6f 	isb	sy
 800320c:	f3bf 8f4f 	dsb	sy
 8003210:	e7fe      	b.n	8003210 <vTaskDelay+0x2c>
			vTaskSuspendAll();
 8003212:	f7ff fed5 	bl	8002fc0 <vTaskSuspendAll>
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 8003216:	f7ff fd81 	bl	8002d1c <prvAddCurrentTaskToDelayedList>
			xAlreadyYielded = xTaskResumeAll();
 800321a:	f7ff ff6b 	bl	80030f4 <xTaskResumeAll>
		if( xAlreadyYielded == pdFALSE )
 800321e:	2800      	cmp	r0, #0
 8003220:	d0e2      	beq.n	80031e8 <vTaskDelay+0x4>
 8003222:	bd08      	pop	{r3, pc}
 8003224:	e000ed04 	.word	0xe000ed04
 8003228:	20000df0 	.word	0x20000df0

0800322c <prvIdleTask>:
{
 800322c:	b508      	push	{r3, lr}
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 800322e:	4e17      	ldr	r6, [pc, #92]	; (800328c <prvIdleTask+0x60>)
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
 8003230:	4c17      	ldr	r4, [pc, #92]	; (8003290 <prvIdleTask+0x64>)
 8003232:	6823      	ldr	r3, [r4, #0]
 8003234:	b963      	cbnz	r3, 8003250 <prvIdleTask+0x24>
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 8003236:	4b17      	ldr	r3, [pc, #92]	; (8003294 <prvIdleTask+0x68>)
 8003238:	681b      	ldr	r3, [r3, #0]
 800323a:	2b01      	cmp	r3, #1
 800323c:	d9f8      	bls.n	8003230 <prvIdleTask+0x4>
				taskYIELD();
 800323e:	4b16      	ldr	r3, [pc, #88]	; (8003298 <prvIdleTask+0x6c>)
 8003240:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8003244:	601a      	str	r2, [r3, #0]
 8003246:	f3bf 8f4f 	dsb	sy
 800324a:	f3bf 8f6f 	isb	sy
 800324e:	e7ef      	b.n	8003230 <prvIdleTask+0x4>
			vTaskSuspendAll();
 8003250:	f7ff feb6 	bl	8002fc0 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 8003254:	6835      	ldr	r5, [r6, #0]
			( void ) xTaskResumeAll();
 8003256:	f7ff ff4d 	bl	80030f4 <xTaskResumeAll>
			if( xListIsEmpty == pdFALSE )
 800325a:	2d00      	cmp	r5, #0
 800325c:	d0e9      	beq.n	8003232 <prvIdleTask+0x6>
				taskENTER_CRITICAL();
 800325e:	f7ff fb59 	bl	8002914 <vPortEnterCritical>
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 8003262:	68f3      	ldr	r3, [r6, #12]
 8003264:	68dd      	ldr	r5, [r3, #12]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003266:	1d28      	adds	r0, r5, #4
 8003268:	f7ff faea 	bl	8002840 <uxListRemove>
					--uxCurrentNumberOfTasks;
 800326c:	4a0b      	ldr	r2, [pc, #44]	; (800329c <prvIdleTask+0x70>)
 800326e:	6813      	ldr	r3, [r2, #0]
 8003270:	3b01      	subs	r3, #1
 8003272:	6013      	str	r3, [r2, #0]
					--uxDeletedTasksWaitingCleanUp;
 8003274:	6823      	ldr	r3, [r4, #0]
 8003276:	3b01      	subs	r3, #1
 8003278:	6023      	str	r3, [r4, #0]
				taskEXIT_CRITICAL();
 800327a:	f7ff fb6d 	bl	8002958 <vPortExitCritical>
			vPortFree( pxTCB->pxStack );
 800327e:	6b28      	ldr	r0, [r5, #48]	; 0x30
 8003280:	f7ff fd02 	bl	8002c88 <vPortFree>
			vPortFree( pxTCB );
 8003284:	4628      	mov	r0, r5
 8003286:	f7ff fcff 	bl	8002c88 <vPortFree>
 800328a:	e7d2      	b.n	8003232 <prvIdleTask+0x6>
 800328c:	20000e5c 	.word	0x20000e5c
 8003290:	20000de8 	.word	0x20000de8
 8003294:	20000d58 	.word	0x20000d58
 8003298:	e000ed04 	.word	0xe000ed04
 800329c:	20000de4 	.word	0x20000de4

080032a0 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80032a0:	4b17      	ldr	r3, [pc, #92]	; (8003300 <vTaskSwitchContext+0x60>)
 80032a2:	681a      	ldr	r2, [r3, #0]
 80032a4:	4b17      	ldr	r3, [pc, #92]	; (8003304 <vTaskSwitchContext+0x64>)
{
 80032a6:	b510      	push	{r4, lr}
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80032a8:	b112      	cbz	r2, 80032b0 <vTaskSwitchContext+0x10>
		xYieldPending = pdTRUE;
 80032aa:	2201      	movs	r2, #1
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80032ac:	601a      	str	r2, [r3, #0]
 80032ae:	bd10      	pop	{r4, pc}
		xYieldPending = pdFALSE;
 80032b0:	601a      	str	r2, [r3, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK();
 80032b2:	4b15      	ldr	r3, [pc, #84]	; (8003308 <vTaskSwitchContext+0x68>)
 80032b4:	681b      	ldr	r3, [r3, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
 80032b6:	fab3 f383 	clz	r3, r3
 80032ba:	b2db      	uxtb	r3, r3
 80032bc:	f1c3 031f 	rsb	r3, r3, #31
 80032c0:	2214      	movs	r2, #20
 80032c2:	4912      	ldr	r1, [pc, #72]	; (800330c <vTaskSwitchContext+0x6c>)
 80032c4:	435a      	muls	r2, r3
 80032c6:	1888      	adds	r0, r1, r2
 80032c8:	588c      	ldr	r4, [r1, r2]
 80032ca:	b944      	cbnz	r4, 80032de <vTaskSwitchContext+0x3e>
	__asm volatile
 80032cc:	f04f 0350 	mov.w	r3, #80	; 0x50
 80032d0:	f383 8811 	msr	BASEPRI, r3
 80032d4:	f3bf 8f6f 	isb	sy
 80032d8:	f3bf 8f4f 	dsb	sy
 80032dc:	e7fe      	b.n	80032dc <vTaskSwitchContext+0x3c>
 80032de:	6844      	ldr	r4, [r0, #4]
 80032e0:	3208      	adds	r2, #8
 80032e2:	6864      	ldr	r4, [r4, #4]
 80032e4:	6044      	str	r4, [r0, #4]
 80032e6:	440a      	add	r2, r1
 80032e8:	4294      	cmp	r4, r2
 80032ea:	bf04      	itt	eq
 80032ec:	6862      	ldreq	r2, [r4, #4]
 80032ee:	6042      	streq	r2, [r0, #4]
 80032f0:	2214      	movs	r2, #20
 80032f2:	fb02 1303 	mla	r3, r2, r3, r1
 80032f6:	685b      	ldr	r3, [r3, #4]
 80032f8:	68da      	ldr	r2, [r3, #12]
 80032fa:	4b05      	ldr	r3, [pc, #20]	; (8003310 <vTaskSwitchContext+0x70>)
 80032fc:	e7d6      	b.n	80032ac <vTaskSwitchContext+0xc>
 80032fe:	bf00      	nop
 8003300:	20000df0 	.word	0x20000df0
 8003304:	20000e74 	.word	0x20000e74
 8003308:	20000df8 	.word	0x20000df8
 800330c:	20000d58 	.word	0x20000d58
 8003310:	20000d4c 	.word	0x20000d4c

08003314 <xTaskGetSchedulerState>:
		if( xSchedulerRunning == pdFALSE )
 8003314:	4b05      	ldr	r3, [pc, #20]	; (800332c <xTaskGetSchedulerState+0x18>)
 8003316:	681b      	ldr	r3, [r3, #0]
 8003318:	b133      	cbz	r3, 8003328 <xTaskGetSchedulerState+0x14>
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800331a:	4b05      	ldr	r3, [pc, #20]	; (8003330 <xTaskGetSchedulerState+0x1c>)
 800331c:	681b      	ldr	r3, [r3, #0]
 800331e:	2b00      	cmp	r3, #0
				xReturn = taskSCHEDULER_SUSPENDED;
 8003320:	bf0c      	ite	eq
 8003322:	2002      	moveq	r0, #2
 8003324:	2000      	movne	r0, #0
 8003326:	4770      	bx	lr
			xReturn = taskSCHEDULER_NOT_STARTED;
 8003328:	2001      	movs	r0, #1
	}
 800332a:	4770      	bx	lr
 800332c:	20000e44 	.word	0x20000e44
 8003330:	20000df0 	.word	0x20000df0

08003334 <StartDefaultTask>:
  * @param  argument: Not used 
  * @retval None
  */
/* USER CODE END Header_StartDefaultTask */
void StartDefaultTask(void const * argument)
{
 8003334:	b508      	push	{r3, lr}
  /* init code for USB_DEVICE */
  MX_USB_DEVICE_Init();
 8003336:	f000 f965 	bl	8003604 <MX_USB_DEVICE_Init>

  /* USER CODE BEGIN 5 */
  /* Infinite loop */
  for(;;)
  {
    osDelay(1);
 800333a:	2001      	movs	r0, #1
 800333c:	f7ff fa3d 	bl	80027ba <osDelay>
 8003340:	e7fb      	b.n	800333a <StartDefaultTask+0x6>

08003342 <SystemClock_Config>:
{
 8003342:	b530      	push	{r4, r5, lr}
 8003344:	b0a7      	sub	sp, #156	; 0x9c
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8003346:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 800334a:	9307      	str	r3, [sp, #28]
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 800334c:	930d      	str	r3, [sp, #52]	; 0x34
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 800334e:	f44f 13e0 	mov.w	r3, #1835008	; 0x1c0000
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8003352:	2201      	movs	r2, #1
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003354:	2402      	movs	r4, #2
  RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
 8003356:	930e      	str	r3, [sp, #56]	; 0x38
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8003358:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 800335a:	2300      	movs	r3, #0
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 800335c:	9206      	str	r2, [sp, #24]
  RCC_OscInitStruct.HSIState = RCC_HSI_ON;
 800335e:	9209      	str	r2, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8003360:	940c      	str	r4, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
 8003362:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8003364:	f7fd ffc0 	bl	80012e8 <HAL_RCC_OscConfig>
 8003368:	b100      	cbz	r0, 800336c <SystemClock_Config+0x2a>
 800336a:	e7fe      	b.n	800336a <SystemClock_Config+0x28>
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800336c:	250f      	movs	r5, #15
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800336e:	9003      	str	r0, [sp, #12]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 8003370:	f44f 6380 	mov.w	r3, #1024	; 0x400
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8003374:	9005      	str	r0, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8003376:	4621      	mov	r1, r4
 8003378:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 800337a:	9501      	str	r5, [sp, #4]
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800337c:	9402      	str	r4, [sp, #8]
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
 800337e:	9304      	str	r3, [sp, #16]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
 8003380:	f7fe fa60 	bl	8001844 <HAL_RCC_ClockConfig>
 8003384:	b100      	cbz	r0, 8003388 <SystemClock_Config+0x46>
 8003386:	e7fe      	b.n	8003386 <SystemClock_Config+0x44>
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8003388:	f44f 3300 	mov.w	r3, #131072	; 0x20000
  PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
 800338c:	9025      	str	r0, [sp, #148]	; 0x94
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 800338e:	a810      	add	r0, sp, #64	; 0x40
  PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
 8003390:	9310      	str	r3, [sp, #64]	; 0x40
  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8003392:	f7fe fb3d 	bl	8001a10 <HAL_RCCEx_PeriphCLKConfig>
 8003396:	4604      	mov	r4, r0
 8003398:	b100      	cbz	r0, 800339c <SystemClock_Config+0x5a>
 800339a:	e7fe      	b.n	800339a <SystemClock_Config+0x58>
  HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
 800339c:	f7fe fafc 	bl	8001998 <HAL_RCC_GetHCLKFreq>
 80033a0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80033a4:	fbb0 f0f3 	udiv	r0, r0, r3
 80033a8:	f7fc ff90 	bl	80002cc <HAL_SYSTICK_Config>
  HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80033ac:	2004      	movs	r0, #4
 80033ae:	f7fc ffa3 	bl	80002f8 <HAL_SYSTICK_CLKSourceConfig>
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80033b2:	4622      	mov	r2, r4
 80033b4:	4629      	mov	r1, r5
 80033b6:	f04f 30ff 	mov.w	r0, #4294967295
 80033ba:	f7fc ff47 	bl	800024c <HAL_NVIC_SetPriority>
}
 80033be:	b027      	add	sp, #156	; 0x9c
 80033c0:	bd30      	pop	{r4, r5, pc}
	...

080033c4 <main>:
{
 80033c4:	b500      	push	{lr}
 80033c6:	b089      	sub	sp, #36	; 0x24
  HAL_Init();
 80033c8:	f7fc ff0a 	bl	80001e0 <HAL_Init>
  SystemClock_Config();
 80033cc:	f7ff ffb9 	bl	8003342 <SystemClock_Config>
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80033d0:	4b1d      	ldr	r3, [pc, #116]	; (8003448 <main+0x84>)
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 80033d2:	481e      	ldr	r0, [pc, #120]	; (800344c <main+0x88>)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80033d4:	695a      	ldr	r2, [r3, #20]
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 80033d6:	4d1e      	ldr	r5, [pc, #120]	; (8003450 <main+0x8c>)
  __HAL_RCC_GPIOF_CLK_ENABLE();
 80033d8:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80033dc:	615a      	str	r2, [r3, #20]
 80033de:	695a      	ldr	r2, [r3, #20]
 80033e0:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 80033e4:	9200      	str	r2, [sp, #0]
 80033e6:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOG_CLK_ENABLE();
 80033e8:	695a      	ldr	r2, [r3, #20]
 80033ea:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80033ee:	615a      	str	r2, [r3, #20]
 80033f0:	695a      	ldr	r2, [r3, #20]
 80033f2:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000
 80033f6:	9201      	str	r2, [sp, #4]
 80033f8:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 80033fa:	695a      	ldr	r2, [r3, #20]
 80033fc:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8003400:	615a      	str	r2, [r3, #20]
 8003402:	695b      	ldr	r3, [r3, #20]
 8003404:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 8003408:	2200      	movs	r2, #0
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800340a:	9302      	str	r3, [sp, #8]
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 800340c:	2140      	movs	r1, #64	; 0x40
  __HAL_RCC_GPIOA_CLK_ENABLE();
 800340e:	9b02      	ldr	r3, [sp, #8]
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_RESET);
 8003410:	f7fd f84e 	bl	80004b0 <HAL_GPIO_WritePin>
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8003414:	2340      	movs	r3, #64	; 0x40
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003416:	2600      	movs	r6, #0
  GPIO_InitStruct.Pin = GPIO_PIN_6;
 8003418:	9303      	str	r3, [sp, #12]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800341a:	a903      	add	r1, sp, #12
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800341c:	2301      	movs	r3, #1
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 800341e:	480b      	ldr	r0, [pc, #44]	; (800344c <main+0x88>)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8003420:	9304      	str	r3, [sp, #16]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8003422:	9605      	str	r6, [sp, #20]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8003424:	9606      	str	r6, [sp, #24]
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
 8003426:	f7fc ff73 	bl	8000310 <HAL_GPIO_Init>
  osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128);
 800342a:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800342c:	ac03      	add	r4, sp, #12
 800342e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8003430:	682b      	ldr	r3, [r5, #0]
 8003432:	6023      	str	r3, [r4, #0]
  defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
 8003434:	4631      	mov	r1, r6
 8003436:	a803      	add	r0, sp, #12
 8003438:	f7ff f9a7 	bl	800278a <osThreadCreate>
 800343c:	4b05      	ldr	r3, [pc, #20]	; (8003454 <main+0x90>)
 800343e:	6018      	str	r0, [r3, #0]
  osKernelStart();
 8003440:	f7ff f99e 	bl	8002780 <osKernelStart>
 8003444:	e7fe      	b.n	8003444 <main+0x80>
 8003446:	bf00      	nop
 8003448:	40021000 	.word	0x40021000
 800344c:	48001800 	.word	0x48001800
 8003450:	08003a00 	.word	0x08003a00
 8003454:	20002a4c 	.word	0x20002a4c

08003458 <HAL_TIM_PeriodElapsedCallback>:
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* USER CODE BEGIN Callback 0 */

  /* USER CODE END Callback 0 */
  if (htim->Instance == TIM1) {
 8003458:	6802      	ldr	r2, [r0, #0]
 800345a:	4b03      	ldr	r3, [pc, #12]	; (8003468 <HAL_TIM_PeriodElapsedCallback+0x10>)
 800345c:	429a      	cmp	r2, r3
 800345e:	d101      	bne.n	8003464 <HAL_TIM_PeriodElapsedCallback+0xc>
    HAL_IncTick();
 8003460:	f7fc bed0 	b.w	8000204 <HAL_IncTick>
 8003464:	4770      	bx	lr
 8003466:	bf00      	nop
 8003468:	40012c00 	.word	0x40012c00

0800346c <_Error_Handler>:
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
 800346c:	e7fe      	b.n	800346c <_Error_Handler>
	...

08003470 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003470:	4b21      	ldr	r3, [pc, #132]	; (80034f8 <HAL_MspInit+0x88>)
{
 8003472:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8003474:	699a      	ldr	r2, [r3, #24]
 8003476:	f042 0201 	orr.w	r2, r2, #1
 800347a:	619a      	str	r2, [r3, #24]
 800347c:	699a      	ldr	r2, [r3, #24]
 800347e:	f002 0201 	and.w	r2, r2, #1
 8003482:	9200      	str	r2, [sp, #0]
 8003484:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8003486:	69da      	ldr	r2, [r3, #28]
 8003488:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800348c:	61da      	str	r2, [r3, #28]
 800348e:	69db      	ldr	r3, [r3, #28]
 8003490:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003494:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8003496:	2003      	movs	r0, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 8003498:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800349a:	f7fc fec5 	bl	8000228 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 800349e:	2200      	movs	r2, #0
 80034a0:	4611      	mov	r1, r2
 80034a2:	f06f 000b 	mvn.w	r0, #11
 80034a6:	f7fc fed1 	bl	800024c <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 80034aa:	2200      	movs	r2, #0
 80034ac:	4611      	mov	r1, r2
 80034ae:	f06f 000a 	mvn.w	r0, #10
 80034b2:	f7fc fecb 	bl	800024c <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 80034b6:	2200      	movs	r2, #0
 80034b8:	4611      	mov	r1, r2
 80034ba:	f06f 0009 	mvn.w	r0, #9
 80034be:	f7fc fec5 	bl	800024c <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 80034c2:	2200      	movs	r2, #0
 80034c4:	4611      	mov	r1, r2
 80034c6:	f06f 0004 	mvn.w	r0, #4
 80034ca:	f7fc febf 	bl	800024c <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 80034ce:	2200      	movs	r2, #0
 80034d0:	4611      	mov	r1, r2
 80034d2:	f06f 0003 	mvn.w	r0, #3
 80034d6:	f7fc feb9 	bl	800024c <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 15, 0);
 80034da:	2200      	movs	r2, #0
 80034dc:	210f      	movs	r1, #15
 80034de:	f06f 0001 	mvn.w	r0, #1
 80034e2:	f7fc feb3 	bl	800024c <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
 80034e6:	2200      	movs	r2, #0
 80034e8:	210f      	movs	r1, #15
 80034ea:	f04f 30ff 	mov.w	r0, #4294967295
 80034ee:	f7fc fead 	bl	800024c <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 80034f2:	b003      	add	sp, #12
 80034f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80034f8:	40021000 	.word	0x40021000

080034fc <HAL_InitTick>:
  *         reset by HAL_Init() or at any time when clock is configured, by HAL_RCC_ClockConfig(). 
  * @param  TickPriority: Tick interrupt priorty.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 80034fc:	b510      	push	{r4, lr}
  uint32_t              uwTimclock = 0;
  uint32_t              uwPrescalerValue = 0;
  uint32_t              pFLatency;
  
  /*Configure the TIM1 IRQ priority */
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0); 
 80034fe:	4601      	mov	r1, r0
{
 8003500:	b088      	sub	sp, #32
  HAL_NVIC_SetPriority(TIM1_UP_TIM16_IRQn, TickPriority ,0); 
 8003502:	2200      	movs	r2, #0
 8003504:	2019      	movs	r0, #25
 8003506:	f7fc fea1 	bl	800024c <HAL_NVIC_SetPriority>
  
  /* Enable the TIM1 global Interrupt */
  HAL_NVIC_EnableIRQ(TIM1_UP_TIM16_IRQn); 
 800350a:	2019      	movs	r0, #25
 800350c:	f7fc fed2 	bl	80002b4 <HAL_NVIC_EnableIRQ>
  
  /* Enable TIM1 clock */
  __HAL_RCC_TIM1_CLK_ENABLE();
 8003510:	4b14      	ldr	r3, [pc, #80]	; (8003564 <HAL_InitTick+0x68>)
   
  /* Compute the prescaler value to have TIM1 counter clock equal to 1MHz */
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
  
  /* Initialize TIM1 */
  htim1.Instance = TIM1;
 8003512:	4c15      	ldr	r4, [pc, #84]	; (8003568 <HAL_InitTick+0x6c>)
  __HAL_RCC_TIM1_CLK_ENABLE();
 8003514:	699a      	ldr	r2, [r3, #24]
 8003516:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800351a:	619a      	str	r2, [r3, #24]
 800351c:	699b      	ldr	r3, [r3, #24]
 800351e:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003522:	9302      	str	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 8003524:	a901      	add	r1, sp, #4
 8003526:	a803      	add	r0, sp, #12
  __HAL_RCC_TIM1_CLK_ENABLE();
 8003528:	9b02      	ldr	r3, [sp, #8]
  HAL_RCC_GetClockConfig(&clkconfig, &pFLatency);
 800352a:	f7fe fa53 	bl	80019d4 <HAL_RCC_GetClockConfig>
  uwTimclock = HAL_RCC_GetPCLK2Freq();
 800352e:	f7fe fa39 	bl	80019a4 <HAL_RCC_GetPCLK2Freq>
  htim1.Instance = TIM1;
 8003532:	4b0e      	ldr	r3, [pc, #56]	; (800356c <HAL_InitTick+0x70>)
 8003534:	6023      	str	r3, [r4, #0]
  + Period = [(TIM1CLK/1000) - 1]. to have a (1/1000) s time base.
  + Prescaler = (uwTimclock/1000000 - 1) to have a 1MHz counter clock.
  + ClockDivision = 0
  + Counter direction = Up
  */
  htim1.Init.Period = (1000000 / 1000) - 1;
 8003536:	f240 33e7 	movw	r3, #999	; 0x3e7
 800353a:	60e3      	str	r3, [r4, #12]
  uwPrescalerValue = (uint32_t) ((uwTimclock / 1000000) - 1);
 800353c:	4b0c      	ldr	r3, [pc, #48]	; (8003570 <HAL_InitTick+0x74>)
 800353e:	fbb0 f0f3 	udiv	r0, r0, r3
 8003542:	3801      	subs	r0, #1
  htim1.Init.Prescaler = uwPrescalerValue;
  htim1.Init.ClockDivision = 0;
 8003544:	2300      	movs	r3, #0
  htim1.Init.Prescaler = uwPrescalerValue;
 8003546:	6060      	str	r0, [r4, #4]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 8003548:	4620      	mov	r0, r4
  htim1.Init.ClockDivision = 0;
 800354a:	6123      	str	r3, [r4, #16]
  htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
 800354c:	60a3      	str	r3, [r4, #8]
  if(HAL_TIM_Base_Init(&htim1) == HAL_OK)
 800354e:	f7fe fccd 	bl	8001eec <HAL_TIM_Base_Init>
 8003552:	b920      	cbnz	r0, 800355e <HAL_InitTick+0x62>
  {
    /* Start the TIM time Base generation in interrupt mode */
    return HAL_TIM_Base_Start_IT(&htim1);
 8003554:	4620      	mov	r0, r4
 8003556:	f7fe fba0 	bl	8001c9a <HAL_TIM_Base_Start_IT>
  }
  
  /* Return function status */
  return HAL_ERROR;
}
 800355a:	b008      	add	sp, #32
 800355c:	bd10      	pop	{r4, pc}
  return HAL_ERROR;
 800355e:	2001      	movs	r0, #1
 8003560:	e7fb      	b.n	800355a <HAL_InitTick+0x5e>
 8003562:	bf00      	nop
 8003564:	40021000 	.word	0x40021000
 8003568:	20002a50 	.word	0x20002a50
 800356c:	40012c00 	.word	0x40012c00
 8003570:	000f4240 	.word	0x000f4240

08003574 <NMI_Handler>:
 8003574:	4770      	bx	lr

08003576 <HardFault_Handler>:

/**
* @brief This function handles Hard fault interrupt.
*/
void HardFault_Handler(void)
{
 8003576:	e7fe      	b.n	8003576 <HardFault_Handler>

08003578 <MemManage_Handler>:

/**
* @brief This function handles Memory management fault.
*/
void MemManage_Handler(void)
{
 8003578:	e7fe      	b.n	8003578 <MemManage_Handler>

0800357a <BusFault_Handler>:

/**
* @brief This function handles Pre-fetch fault, memory access fault.
*/
void BusFault_Handler(void)
{
 800357a:	e7fe      	b.n	800357a <BusFault_Handler>

0800357c <UsageFault_Handler>:

/**
* @brief This function handles Undefined instruction or illegal state.
*/
void UsageFault_Handler(void)
{
 800357c:	e7fe      	b.n	800357c <UsageFault_Handler>

0800357e <DebugMon_Handler>:

/**
* @brief This function handles Debug monitor.
*/
void DebugMon_Handler(void)
{
 800357e:	4770      	bx	lr

08003580 <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  osSystickHandler();
 8003580:	f7ff b923 	b.w	80027ca <osSystickHandler>

08003584 <USB_LP_CAN_RX0_IRQHandler>:
void USB_LP_CAN_RX0_IRQHandler(void)
{
  /* USER CODE BEGIN USB_LP_CAN_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN_RX0_IRQn 0 */
  HAL_PCD_IRQHandler(&hpcd_USB_FS);
 8003584:	4801      	ldr	r0, [pc, #4]	; (800358c <USB_LP_CAN_RX0_IRQHandler+0x8>)
 8003586:	f7fd bb73 	b.w	8000c70 <HAL_PCD_IRQHandler>
 800358a:	bf00      	nop
 800358c:	20002cb4 	.word	0x20002cb4

08003590 <TIM1_UP_TIM16_IRQHandler>:
void TIM1_UP_TIM16_IRQHandler(void)
{
  /* USER CODE BEGIN TIM1_UP_TIM16_IRQn 0 */

  /* USER CODE END TIM1_UP_TIM16_IRQn 0 */
  HAL_TIM_IRQHandler(&htim1);
 8003590:	4801      	ldr	r0, [pc, #4]	; (8003598 <TIM1_UP_TIM16_IRQHandler+0x8>)
 8003592:	f7fe bb91 	b.w	8001cb8 <HAL_TIM_IRQHandler>
 8003596:	bf00      	nop
 8003598:	20002a50 	.word	0x20002a50

0800359c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800359c:	4915      	ldr	r1, [pc, #84]	; (80035f4 <SystemInit+0x58>)
 800359e:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 80035a2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 80035a6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;
 80035aa:	4b13      	ldr	r3, [pc, #76]	; (80035f8 <SystemInit+0x5c>)
 80035ac:	681a      	ldr	r2, [r3, #0]
 80035ae:	f042 0201 	orr.w	r2, r2, #1
 80035b2:	601a      	str	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR &= 0xF87FC00CU;
 80035b4:	6858      	ldr	r0, [r3, #4]
 80035b6:	4a11      	ldr	r2, [pc, #68]	; (80035fc <SystemInit+0x60>)
 80035b8:	4002      	ands	r2, r0
 80035ba:	605a      	str	r2, [r3, #4]

  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;
 80035bc:	681a      	ldr	r2, [r3, #0]
 80035be:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
 80035c2:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80035c6:	601a      	str	r2, [r3, #0]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 80035c8:	681a      	ldr	r2, [r3, #0]
 80035ca:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80035ce:	601a      	str	r2, [r3, #0]

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;
 80035d0:	685a      	ldr	r2, [r3, #4]
 80035d2:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
 80035d6:	605a      	str	r2, [r3, #4]

  /* Reset PREDIV1[3:0] bits */
  RCC->CFGR2 &= 0xFFFFFFF0U;
 80035d8:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80035da:	f022 020f 	bic.w	r2, r2, #15
 80035de:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Reset USARTSW[1:0], I2CSW and TIMs bits */
  RCC->CFGR3 &= 0xFF00FCCCU;
 80035e0:	6b18      	ldr	r0, [r3, #48]	; 0x30
 80035e2:	4a07      	ldr	r2, [pc, #28]	; (8003600 <SystemInit+0x64>)
 80035e4:	4002      	ands	r2, r0
 80035e6:	631a      	str	r2, [r3, #48]	; 0x30

  /* Disable all interrupts */
  RCC->CIR = 0x00000000U;
 80035e8:	2200      	movs	r2, #0
 80035ea:	609a      	str	r2, [r3, #8]

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 80035ec:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80035f0:	608b      	str	r3, [r1, #8]
 80035f2:	4770      	bx	lr
 80035f4:	e000ed00 	.word	0xe000ed00
 80035f8:	40021000 	.word	0x40021000
 80035fc:	f87fc00c 	.word	0xf87fc00c
 8003600:	ff00fccc 	.word	0xff00fccc

08003604 <MX_USB_DEVICE_Init>:
/**
  * Init USB device Library, add supported class and start the library
  * @retval None
  */
void MX_USB_DEVICE_Init(void)
{
 8003604:	b510      	push	{r4, lr}
  /* USER CODE BEGIN USB_DEVICE_Init_PreTreatment */
  
  /* USER CODE END USB_DEVICE_Init_PreTreatment */
  
  /* Init Device Library, add supported class and start the library. */
  USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS);
 8003606:	4c0c      	ldr	r4, [pc, #48]	; (8003638 <MX_USB_DEVICE_Init+0x34>)
 8003608:	490c      	ldr	r1, [pc, #48]	; (800363c <MX_USB_DEVICE_Init+0x38>)
 800360a:	2200      	movs	r2, #0
 800360c:	4620      	mov	r0, r4
 800360e:	f7fe fd9c 	bl	800214a <USBD_Init>

  USBD_RegisterClass(&hUsbDeviceFS, &USBD_AUDIO);
 8003612:	490b      	ldr	r1, [pc, #44]	; (8003640 <MX_USB_DEVICE_Init+0x3c>)
 8003614:	4620      	mov	r0, r4
 8003616:	f7fe fdad 	bl	8002174 <USBD_RegisterClass>

  USBD_AUDIO_RegisterInterface(&hUsbDeviceFS, &USBD_AUDIO_fops_FS);
 800361a:	490a      	ldr	r1, [pc, #40]	; (8003644 <MX_USB_DEVICE_Init+0x40>)
 800361c:	4620      	mov	r0, r4
 800361e:	f7fe fd8f 	bl	8002140 <USBD_AUDIO_RegisterInterface>

  USBD_Start(&hUsbDeviceFS);
 8003622:	4620      	mov	r0, r4
 8003624:	f7fe fdad 	bl	8002182 <USBD_Start>

  /* USER CODE BEGIN USB_DEVICE_Init_PostTreatment */
  // Enable USB
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
 8003628:	2201      	movs	r2, #1
 800362a:	2140      	movs	r1, #64	; 0x40
 800362c:	4806      	ldr	r0, [pc, #24]	; (8003648 <MX_USB_DEVICE_Init+0x44>)
  /* USER CODE END USB_DEVICE_Init_PostTreatment */
}
 800362e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  HAL_GPIO_WritePin(GPIOG, GPIO_PIN_6, GPIO_PIN_SET);
 8003632:	f7fc bf3d 	b.w	80004b0 <HAL_GPIO_WritePin>
 8003636:	bf00      	nop
 8003638:	20002a90 	.word	0x20002a90
 800363c:	200000dc 	.word	0x200000dc
 8003640:	20000004 	.word	0x20000004
 8003644:	200000c0 	.word	0x200000c0
 8003648:	48001800 	.word	0x48001800

0800364c <AUDIO_Init_FS>:
static int8_t AUDIO_Init_FS(uint32_t AudioFreq, uint32_t Volume, uint32_t options)
{
  /* USER CODE BEGIN 0 */
  return (USBD_OK);
  /* USER CODE END 0 */
}
 800364c:	2000      	movs	r0, #0
 800364e:	4770      	bx	lr

08003650 <AUDIO_DeInit_FS>:
static int8_t AUDIO_DeInit_FS(uint32_t options)
{
  /* USER CODE BEGIN 1 */
  return (USBD_OK);
  /* USER CODE END 1 */
}
 8003650:	2000      	movs	r0, #0
 8003652:	4770      	bx	lr

08003654 <AUDIO_AudioCmd_FS>:
    case AUDIO_CMD_PLAY:
    break;	
  }
  return (USBD_OK);
  /* USER CODE END 2 */
}
 8003654:	2000      	movs	r0, #0
 8003656:	4770      	bx	lr

08003658 <AUDIO_PeriodicTC_FS>:
static int8_t AUDIO_PeriodicTC_FS(uint8_t cmd)
{
  /* USER CODE BEGIN 5 */
  return (USBD_OK);
  /* USER CODE END 5 */
}
 8003658:	2000      	movs	r0, #0
 800365a:	4770      	bx	lr

0800365c <AUDIO_GetState_FS>:
static int8_t AUDIO_GetState_FS(void)
{
  /* USER CODE BEGIN 6 */
  return (USBD_OK);
  /* USER CODE END 6 */
}
 800365c:	2000      	movs	r0, #0
 800365e:	4770      	bx	lr

08003660 <AUDIO_MuteCtl_FS>:
 8003660:	2000      	movs	r0, #0
 8003662:	4770      	bx	lr

08003664 <AUDIO_VolumeCtl_FS>:
 8003664:	2000      	movs	r0, #0
 8003666:	4770      	bx	lr

08003668 <HAL_PCD_MspInit>:
                       LL Driver Callbacks (PCD -> USB Device Library)
*******************************************************************************/
/* MSP Init */

void HAL_PCD_MspInit(PCD_HandleTypeDef* pcdHandle)
{
 8003668:	b507      	push	{r0, r1, r2, lr}
  if(pcdHandle->Instance==USB)
 800366a:	4b0d      	ldr	r3, [pc, #52]	; (80036a0 <HAL_PCD_MspInit+0x38>)
 800366c:	6802      	ldr	r2, [r0, #0]
 800366e:	429a      	cmp	r2, r3
 8003670:	d112      	bne.n	8003698 <HAL_PCD_MspInit+0x30>
  {
  /* USER CODE BEGIN USB_MspInit 0 */

  /* USER CODE END USB_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USB_CLK_ENABLE();
 8003672:	f503 33da 	add.w	r3, r3, #111616	; 0x1b400

    /* Peripheral interrupt init */
    HAL_NVIC_SetPriority(USB_LP_CAN_RX0_IRQn, 5, 0);
 8003676:	2014      	movs	r0, #20
    __HAL_RCC_USB_CLK_ENABLE();
 8003678:	69da      	ldr	r2, [r3, #28]
 800367a:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800367e:	61da      	str	r2, [r3, #28]
 8003680:	69db      	ldr	r3, [r3, #28]
 8003682:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
 8003686:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_LP_CAN_RX0_IRQn, 5, 0);
 8003688:	2200      	movs	r2, #0
 800368a:	2105      	movs	r1, #5
    __HAL_RCC_USB_CLK_ENABLE();
 800368c:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(USB_LP_CAN_RX0_IRQn, 5, 0);
 800368e:	f7fc fddd 	bl	800024c <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN_RX0_IRQn);
 8003692:	2014      	movs	r0, #20
 8003694:	f7fc fe0e 	bl	80002b4 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN USB_MspInit 1 */

  /* USER CODE END USB_MspInit 1 */
  }
}
 8003698:	b003      	add	sp, #12
 800369a:	f85d fb04 	ldr.w	pc, [sp], #4
 800369e:	bf00      	nop
 80036a0:	40005c00 	.word	0x40005c00

080036a4 <HAL_PCD_SetupStageCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SetupStageCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SetupStage((USBD_HandleTypeDef*)hpcd->pData, (uint8_t *)hpcd->Setup);
 80036a4:	f500 715d 	add.w	r1, r0, #884	; 0x374
 80036a8:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036ac:	f7fe bd80 	b.w	80021b0 <USBD_LL_SetupStage>

080036b0 <HAL_PCD_DataOutStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataOutStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataOutStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->OUT_ep[epnum].xfer_buff);
 80036b0:	231c      	movs	r3, #28
 80036b2:	fb03 0301 	mla	r3, r3, r1, r0
 80036b6:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036ba:	f8d3 21dc 	ldr.w	r2, [r3, #476]	; 0x1dc
 80036be:	f7fe bda4 	b.w	800220a <USBD_LL_DataOutStage>

080036c2 <HAL_PCD_DataInStageCallback>:
  * @param  epnum: Endpoint number
  * @retval None
  */
void HAL_PCD_DataInStageCallback(PCD_HandleTypeDef *hpcd, uint8_t epnum)
{
  USBD_LL_DataInStage((USBD_HandleTypeDef*)hpcd->pData, epnum, hpcd->IN_ep[epnum].xfer_buff);
 80036c2:	231c      	movs	r3, #28
 80036c4:	fb03 0301 	mla	r3, r3, r1, r0
 80036c8:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036cc:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80036ce:	f7fe bdce 	b.w	800226e <USBD_LL_DataInStage>

080036d2 <HAL_PCD_SOFCallback>:
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SOFCallback(PCD_HandleTypeDef *hpcd)
{
  USBD_LL_SOF((USBD_HandleTypeDef*)hpcd->pData);
 80036d2:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036d6:	f7fe be4a 	b.w	800236e <USBD_LL_SOF>

080036da <HAL_PCD_ResetCallback>:
  * @brief  Reset callback.
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_ResetCallback(PCD_HandleTypeDef *hpcd)
{ 
 80036da:	b510      	push	{r4, lr}
 80036dc:	4604      	mov	r4, r0
	
  default:
    speed = USBD_SPEED_FULL;
    break;    
  }
  USBD_LL_SetSpeed((USBD_HandleTypeDef*)hpcd->pData, speed);
 80036de:	2101      	movs	r1, #1
 80036e0:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036e4:	f7fe fe31 	bl	800234a <USBD_LL_SetSpeed>
  
  /* Reset Device. */
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 80036e8:	f8d4 03a4 	ldr.w	r0, [r4, #932]	; 0x3a4
}
 80036ec:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  USBD_LL_Reset((USBD_HandleTypeDef*)hpcd->pData);
 80036f0:	f7fe be0c 	b.w	800230c <USBD_LL_Reset>

080036f4 <HAL_PCD_SuspendCallback>:
  * When Low power mode is enabled the debug cannot be used (IAR, Keil doesn't support it)
  * @param  hpcd: PCD handle
  * @retval None
  */
void HAL_PCD_SuspendCallback(PCD_HandleTypeDef *hpcd)
{
 80036f4:	b510      	push	{r4, lr}
 80036f6:	4604      	mov	r4, r0
  /* Inform USB library that core enters in suspend Mode. */
  USBD_LL_Suspend((USBD_HandleTypeDef*)hpcd->pData);
 80036f8:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 80036fc:	f7fe fe28 	bl	8002350 <USBD_LL_Suspend>
  /* Enter in STOP mode. */
  /* USER CODE BEGIN 2 */
  if (hpcd->Init.low_power_enable)
 8003700:	69a3      	ldr	r3, [r4, #24]
 8003702:	b123      	cbz	r3, 800370e <HAL_PCD_SuspendCallback+0x1a>
  {
    /* Set SLEEPDEEP bit and SleepOnExit of Cortex System Control Register. */
    SCB->SCR |= (uint32_t)((uint32_t)(SCB_SCR_SLEEPDEEP_Msk | SCB_SCR_SLEEPONEXIT_Msk));
 8003704:	4a02      	ldr	r2, [pc, #8]	; (8003710 <HAL_PCD_SuspendCallback+0x1c>)
 8003706:	6913      	ldr	r3, [r2, #16]
 8003708:	f043 0306 	orr.w	r3, r3, #6
 800370c:	6113      	str	r3, [r2, #16]
 800370e:	bd10      	pop	{r4, pc}
 8003710:	e000ed00 	.word	0xe000ed00

08003714 <HAL_PCD_ResumeCallback>:
void HAL_PCD_ResumeCallback(PCD_HandleTypeDef *hpcd)
{
  /* USER CODE BEGIN 3 */

  /* USER CODE END 3 */
  USBD_LL_Resume((USBD_HandleTypeDef*)hpcd->pData);
 8003714:	f8d0 03a4 	ldr.w	r0, [r0, #932]	; 0x3a4
 8003718:	f7fe be23 	b.w	8002362 <USBD_LL_Resume>

0800371c <USBD_LL_Init>:
  * @brief  Initializes the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Init(USBD_HandleTypeDef *pdev)
{
 800371c:	b510      	push	{r4, lr}
  /* Link the driver to the stack. */
  hpcd_USB_FS.pData = pdev;
  pdev->pData = &hpcd_USB_FS;

  hpcd_USB_FS.Instance = USB;
  hpcd_USB_FS.Init.dev_endpoints = 8;
 800371e:	4a15      	ldr	r2, [pc, #84]	; (8003774 <USBD_LL_Init+0x58>)
{
 8003720:	4604      	mov	r4, r0
  hpcd_USB_FS.pData = pdev;
 8003722:	4815      	ldr	r0, [pc, #84]	; (8003778 <USBD_LL_Init+0x5c>)
  hpcd_USB_FS.Init.dev_endpoints = 8;
 8003724:	2308      	movs	r3, #8
 8003726:	e880 000c 	stmia.w	r0, {r2, r3}
  hpcd_USB_FS.pData = pdev;
 800372a:	f8c0 43a4 	str.w	r4, [r0, #932]	; 0x3a4
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 800372e:	2300      	movs	r3, #0
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8003730:	2202      	movs	r2, #2
  pdev->pData = &hpcd_USB_FS;
 8003732:	f8c4 0220 	str.w	r0, [r4, #544]	; 0x220
  hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
 8003736:	6082      	str	r2, [r0, #8]
  hpcd_USB_FS.Init.ep0_mps = DEP0CTL_MPS_64;
 8003738:	60c3      	str	r3, [r0, #12]
  hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
 800373a:	6102      	str	r2, [r0, #16]
  hpcd_USB_FS.Init.low_power_enable = DISABLE;
 800373c:	6183      	str	r3, [r0, #24]
  hpcd_USB_FS.Init.lpm_enable = DISABLE;
 800373e:	61c3      	str	r3, [r0, #28]
  hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
 8003740:	6203      	str	r3, [r0, #32]
  if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
 8003742:	f7fc feba 	bl	80004ba <HAL_PCD_Init>
 8003746:	b120      	cbz	r0, 8003752 <USBD_LL_Init+0x36>
  {
    _Error_Handler(__FILE__, __LINE__);
 8003748:	f44f 7197 	mov.w	r1, #302	; 0x12e
 800374c:	480b      	ldr	r0, [pc, #44]	; (800377c <USBD_LL_Init+0x60>)
 800374e:	f7ff fe8d 	bl	800346c <_Error_Handler>
  }

  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x00 , PCD_SNG_BUF, 0x18);
 8003752:	2200      	movs	r2, #0
 8003754:	4611      	mov	r1, r2
 8003756:	2318      	movs	r3, #24
 8003758:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 800375c:	f7fd fd7d 	bl	800125a <HAL_PCDEx_PMAConfig>
  HAL_PCDEx_PMAConfig((PCD_HandleTypeDef*)pdev->pData , 0x80 , PCD_SNG_BUF, 0x58);
 8003760:	2358      	movs	r3, #88	; 0x58
 8003762:	2200      	movs	r2, #0
 8003764:	2180      	movs	r1, #128	; 0x80
 8003766:	f8d4 0220 	ldr.w	r0, [r4, #544]	; 0x220
 800376a:	f7fd fd76 	bl	800125a <HAL_PCDEx_PMAConfig>
  return USBD_OK;
}
 800376e:	2000      	movs	r0, #0
 8003770:	bd10      	pop	{r4, pc}
 8003772:	bf00      	nop
 8003774:	40005c00 	.word	0x40005c00
 8003778:	20002cb4 	.word	0x20002cb4
 800377c:	08003a61 	.word	0x08003a61

08003780 <USBD_LL_Start>:
  * @brief  Starts the low level portion of the device driver.
  * @param  pdev: Device handle
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
 8003780:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
 
  hal_status = HAL_PCD_Start(pdev->pData);
 8003782:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003786:	f7fc feec 	bl	8000562 <HAL_PCD_Start>
 800378a:	2803      	cmp	r0, #3
 800378c:	bf9a      	itte	ls
 800378e:	4b02      	ldrls	r3, [pc, #8]	; (8003798 <USBD_LL_Start+0x18>)
 8003790:	5c18      	ldrbls	r0, [r3, r0]
 8003792:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 8003794:	bd08      	pop	{r3, pc}
 8003796:	bf00      	nop
 8003798:	08003a5d 	.word	0x08003a5d

0800379c <USBD_LL_OpenEP>:
  * @param  ep_type: Endpoint type
  * @param  ep_mps: Endpoint max packet size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_OpenEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t ep_type, uint16_t ep_mps)
{
 800379c:	b510      	push	{r4, lr}
 800379e:	461c      	mov	r4, r3
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Open(pdev->pData, ep_addr, ep_mps, ep_type);
 80037a0:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80037a4:	4613      	mov	r3, r2
 80037a6:	4622      	mov	r2, r4
 80037a8:	f7fc fef8 	bl	800059c <HAL_PCD_EP_Open>
 80037ac:	2803      	cmp	r0, #3
 80037ae:	bf9a      	itte	ls
 80037b0:	4b01      	ldrls	r3, [pc, #4]	; (80037b8 <USBD_LL_OpenEP+0x1c>)
 80037b2:	5c18      	ldrbls	r0, [r3, r0]
 80037b4:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;
}
 80037b6:	bd10      	pop	{r4, pc}
 80037b8:	08003a5d 	.word	0x08003a5d

080037bc <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_CloseEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80037bc:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_Close(pdev->pData, ep_addr);
 80037be:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80037c2:	f7fd f87f 	bl	80008c4 <HAL_PCD_EP_Close>
 80037c6:	2803      	cmp	r0, #3
 80037c8:	bf9a      	itte	ls
 80037ca:	4b02      	ldrls	r3, [pc, #8]	; (80037d4 <USBD_LL_CloseEP+0x18>)
 80037cc:	5c18      	ldrbls	r0, [r3, r0]
 80037ce:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 80037d0:	bd08      	pop	{r3, pc}
 80037d2:	bf00      	nop
 80037d4:	08003a5d 	.word	0x08003a5d

080037d8 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_StallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80037d8:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_SetStall(pdev->pData, ep_addr);
 80037da:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80037de:	f7fd fc87 	bl	80010f0 <HAL_PCD_EP_SetStall>
 80037e2:	2803      	cmp	r0, #3
 80037e4:	bf9a      	itte	ls
 80037e6:	4b02      	ldrls	r3, [pc, #8]	; (80037f0 <USBD_LL_StallEP+0x18>)
 80037e8:	5c18      	ldrbls	r0, [r3, r0]
 80037ea:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 80037ec:	bd08      	pop	{r3, pc}
 80037ee:	bf00      	nop
 80037f0:	08003a5d 	.word	0x08003a5d

080037f4 <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint number
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_ClearStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
 80037f4:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_EP_ClrStall(pdev->pData, ep_addr);  
 80037f6:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 80037fa:	f7fd fcca 	bl	8001192 <HAL_PCD_EP_ClrStall>
 80037fe:	2803      	cmp	r0, #3
 8003800:	bf9a      	itte	ls
 8003802:	4b02      	ldrls	r3, [pc, #8]	; (800380c <USBD_LL_ClearStallEP+0x18>)
 8003804:	5c18      	ldrbls	r0, [r3, r0]
 8003806:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003808:	bd08      	pop	{r3, pc}
 800380a:	bf00      	nop
 800380c:	08003a5d 	.word	0x08003a5d

08003810 <USBD_LL_IsStallEP>:
  */
uint8_t USBD_LL_IsStallEP(USBD_HandleTypeDef *pdev, uint8_t ep_addr)
{
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
  
  if((ep_addr & 0x80) == 0x80)
 8003810:	f011 0f80 	tst.w	r1, #128	; 0x80
  PCD_HandleTypeDef *hpcd = (PCD_HandleTypeDef*) pdev->pData;
 8003814:	f8d0 3220 	ldr.w	r3, [r0, #544]	; 0x220
 8003818:	f04f 021c 	mov.w	r2, #28
  {
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800381c:	bf1b      	ittet	ne
 800381e:	f001 017f 	andne.w	r1, r1, #127	; 0x7f
 8003822:	fb02 3101 	mlane	r1, r2, r1, r3
  }
  else
  {
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 8003826:	fb02 3101 	mlaeq	r1, r2, r1, r3
    return hpcd->IN_ep[ep_addr & 0x7F].is_stall; 
 800382a:	f891 002a 	ldrbne.w	r0, [r1, #42]	; 0x2a
    return hpcd->OUT_ep[ep_addr & 0x7F].is_stall; 
 800382e:	bf08      	it	eq
 8003830:	f891 01ce 	ldrbeq.w	r0, [r1, #462]	; 0x1ce
  }
}
 8003834:	4770      	bx	lr
	...

08003838 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  dev_addr: Device address
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_SetUSBAddress(USBD_HandleTypeDef *pdev, uint8_t dev_addr)
{
 8003838:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;
  
  hal_status = HAL_PCD_SetAddress(pdev->pData, dev_addr);
 800383a:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800383e:	f7fc fe96 	bl	800056e <HAL_PCD_SetAddress>
 8003842:	2803      	cmp	r0, #3
 8003844:	bf9a      	itte	ls
 8003846:	4b02      	ldrls	r3, [pc, #8]	; (8003850 <USBD_LL_SetUSBAddress+0x18>)
 8003848:	5c18      	ldrbls	r0, [r3, r0]
 800384a:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;  
}
 800384c:	bd08      	pop	{r3, pc}
 800384e:	bf00      	nop
 8003850:	08003a5d 	.word	0x08003a5d

08003854 <USBD_LL_Transmit>:
  * @param  pbuf: Pointer to data to be sent
  * @param  size: Data size    
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_Transmit(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003854:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Transmit(pdev->pData, ep_addr, pbuf, size);
 8003856:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 800385a:	f7fd f98d 	bl	8000b78 <HAL_PCD_EP_Transmit>
 800385e:	2803      	cmp	r0, #3
 8003860:	bf9a      	itte	ls
 8003862:	4b02      	ldrls	r3, [pc, #8]	; (800386c <USBD_LL_Transmit+0x18>)
 8003864:	5c18      	ldrbls	r0, [r3, r0]
 8003866:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status;    
}
 8003868:	bd08      	pop	{r3, pc}
 800386a:	bf00      	nop
 800386c:	08003a5d 	.word	0x08003a5d

08003870 <USBD_LL_PrepareReceive>:
  * @param  pbuf: Pointer to data to be received
  * @param  size: Data size
  * @retval USBD status
  */
USBD_StatusTypeDef USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, uint8_t ep_addr, uint8_t *pbuf, uint16_t size)
{
 8003870:	b508      	push	{r3, lr}
  HAL_StatusTypeDef hal_status = HAL_OK;
  USBD_StatusTypeDef usb_status = USBD_OK;

  hal_status = HAL_PCD_EP_Receive(pdev->pData, ep_addr, pbuf, size);
 8003872:	f8d0 0220 	ldr.w	r0, [r0, #544]	; 0x220
 8003876:	f7fd f913 	bl	8000aa0 <HAL_PCD_EP_Receive>
 800387a:	2803      	cmp	r0, #3
 800387c:	bf9a      	itte	ls
 800387e:	4b02      	ldrls	r3, [pc, #8]	; (8003888 <USBD_LL_PrepareReceive+0x18>)
 8003880:	5c18      	ldrbls	r0, [r3, r0]
 8003882:	2002      	movhi	r0, #2
    default :
      usb_status = USBD_FAIL;
    break;
  }
  return usb_status; 
}
 8003884:	bd08      	pop	{r3, pc}
 8003886:	bf00      	nop
 8003888:	08003a5d 	.word	0x08003a5d

0800388c <USBD_static_malloc>:
  */
void *USBD_static_malloc(uint32_t size)
{
  static uint8_t mem[sizeof(USBD_AUDIO_HandleTypeDef)];
  return mem;
}
 800388c:	4800      	ldr	r0, [pc, #0]	; (8003890 <USBD_static_malloc+0x4>)
 800388e:	4770      	bx	lr
 8003890:	20000e78 	.word	0x20000e78

08003894 <USBD_static_free>:
  * @brief  Dummy memory free
  * @param  p: Pointer to allocated  memory address
  * @retval None
  */
void USBD_static_free(void *p)
{
 8003894:	4770      	bx	lr

08003896 <HAL_PCDEx_SetConnectionState>:
  * @param hpcd: PCD handle
  * @param state: Connection state (0: disconnected / 1: connected)
  * @retval None
  */
void HAL_PCDEx_SetConnectionState(PCD_HandleTypeDef *hpcd, uint8_t state)
{
 8003896:	4770      	bx	lr

08003898 <USBD_FS_DeviceDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_FS_DeviceDesc);
 8003898:	2312      	movs	r3, #18
 800389a:	800b      	strh	r3, [r1, #0]
  return USBD_FS_DeviceDesc;
}
 800389c:	4800      	ldr	r0, [pc, #0]	; (80038a0 <USBD_FS_DeviceDescriptor+0x8>)
 800389e:	4770      	bx	lr
 80038a0:	200000f8 	.word	0x200000f8

080038a4 <USBD_FS_LangIDStrDescriptor>:
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  *length = sizeof(USBD_LangIDDesc);
 80038a4:	2304      	movs	r3, #4
 80038a6:	800b      	strh	r3, [r1, #0]
  return USBD_LangIDDesc;
}
 80038a8:	4800      	ldr	r0, [pc, #0]	; (80038ac <USBD_FS_LangIDStrDescriptor+0x8>)
 80038aa:	4770      	bx	lr
 80038ac:	2000010c 	.word	0x2000010c

080038b0 <USBD_FS_ManufacturerStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80038b0:	b510      	push	{r4, lr}
  USBD_GetString((uint8_t *)USBD_MANUFACTURER_STRING, USBD_StrDesc, length);
 80038b2:	4c04      	ldr	r4, [pc, #16]	; (80038c4 <USBD_FS_ManufacturerStrDescriptor+0x14>)
 80038b4:	4804      	ldr	r0, [pc, #16]	; (80038c8 <USBD_FS_ManufacturerStrDescriptor+0x18>)
 80038b6:	460a      	mov	r2, r1
 80038b8:	4621      	mov	r1, r4
 80038ba:	f7fe ff03 	bl	80026c4 <USBD_GetString>
  return USBD_StrDesc;
}
 80038be:	4620      	mov	r0, r4
 80038c0:	bd10      	pop	{r4, pc}
 80038c2:	bf00      	nop
 80038c4:	2000305c 	.word	0x2000305c
 80038c8:	08003a91 	.word	0x08003a91

080038cc <USBD_FS_ProductStrDescriptor>:
{
 80038cc:	b510      	push	{r4, lr}
    USBD_GetString((uint8_t *)USBD_PRODUCT_STRING_FS, USBD_StrDesc, length);
 80038ce:	4c04      	ldr	r4, [pc, #16]	; (80038e0 <USBD_FS_ProductStrDescriptor+0x14>)
 80038d0:	4804      	ldr	r0, [pc, #16]	; (80038e4 <USBD_FS_ProductStrDescriptor+0x18>)
 80038d2:	460a      	mov	r2, r1
 80038d4:	4621      	mov	r1, r4
 80038d6:	f7fe fef5 	bl	80026c4 <USBD_GetString>
}
 80038da:	4620      	mov	r0, r4
 80038dc:	bd10      	pop	{r4, pc}
 80038de:	bf00      	nop
 80038e0:	2000305c 	.word	0x2000305c
 80038e4:	08003aa4 	.word	0x08003aa4

080038e8 <USBD_FS_SerialStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 80038e8:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
 80038ea:	4c04      	ldr	r4, [pc, #16]	; (80038fc <USBD_FS_SerialStrDescriptor+0x14>)
 80038ec:	4804      	ldr	r0, [pc, #16]	; (8003900 <USBD_FS_SerialStrDescriptor+0x18>)
 80038ee:	460a      	mov	r2, r1
 80038f0:	4621      	mov	r1, r4
 80038f2:	f7fe fee7 	bl	80026c4 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_SERIALNUMBER_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 80038f6:	4620      	mov	r0, r4
 80038f8:	bd10      	pop	{r4, pc}
 80038fa:	bf00      	nop
 80038fc:	2000305c 	.word	0x2000305c
 8003900:	08003ab6 	.word	0x08003ab6

08003904 <USBD_FS_ConfigStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8003904:	b510      	push	{r4, lr}
  if(speed == USBD_SPEED_HIGH)
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
 8003906:	4c04      	ldr	r4, [pc, #16]	; (8003918 <USBD_FS_ConfigStrDescriptor+0x14>)
 8003908:	4804      	ldr	r0, [pc, #16]	; (800391c <USBD_FS_ConfigStrDescriptor+0x18>)
 800390a:	460a      	mov	r2, r1
 800390c:	4621      	mov	r1, r4
 800390e:	f7fe fed9 	bl	80026c4 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_CONFIGURATION_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 8003912:	4620      	mov	r0, r4
 8003914:	bd10      	pop	{r4, pc}
 8003916:	bf00      	nop
 8003918:	2000305c 	.word	0x2000305c
 800391c:	08003a74 	.word	0x08003a74

08003920 <USBD_FS_InterfaceStrDescriptor>:
  * @param  speed : Current device speed
  * @param  length : Pointer to data length variable
  * @retval Pointer to descriptor buffer
  */
uint8_t * USBD_FS_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
 8003920:	b510      	push	{r4, lr}
  if(speed == 0)
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
 8003922:	4c04      	ldr	r4, [pc, #16]	; (8003934 <USBD_FS_InterfaceStrDescriptor+0x14>)
 8003924:	4804      	ldr	r0, [pc, #16]	; (8003938 <USBD_FS_InterfaceStrDescriptor+0x18>)
 8003926:	460a      	mov	r2, r1
 8003928:	4621      	mov	r1, r4
 800392a:	f7fe fecb 	bl	80026c4 <USBD_GetString>
  else
  {
    USBD_GetString((uint8_t *)USBD_INTERFACE_STRING_FS, USBD_StrDesc, length);
  }
  return USBD_StrDesc;
}
 800392e:	4620      	mov	r0, r4
 8003930:	bd10      	pop	{r4, pc}
 8003932:	bf00      	nop
 8003934:	2000305c 	.word	0x2000305c
 8003938:	08003a81 	.word	0x08003a81

0800393c <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800393c:	f8df d034 	ldr.w	sp, [pc, #52]	; 8003974 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 8003940:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 8003942:	e003      	b.n	800394c <LoopCopyDataInit>

08003944 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 8003944:	4b0c      	ldr	r3, [pc, #48]	; (8003978 <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 8003946:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 8003948:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800394a:	3104      	adds	r1, #4

0800394c <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800394c:	480b      	ldr	r0, [pc, #44]	; (800397c <LoopForever+0xa>)
	ldr	r3, =_edata
 800394e:	4b0c      	ldr	r3, [pc, #48]	; (8003980 <LoopForever+0xe>)
	adds	r2, r0, r1
 8003950:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 8003952:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 8003954:	d3f6      	bcc.n	8003944 <CopyDataInit>
	ldr	r2, =_sbss
 8003956:	4a0b      	ldr	r2, [pc, #44]	; (8003984 <LoopForever+0x12>)
	b	LoopFillZerobss
 8003958:	e002      	b.n	8003960 <LoopFillZerobss>

0800395a <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800395a:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800395c:	f842 3b04 	str.w	r3, [r2], #4

08003960 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 8003960:	4b09      	ldr	r3, [pc, #36]	; (8003988 <LoopForever+0x16>)
	cmp	r2, r3
 8003962:	429a      	cmp	r2, r3
	bcc	FillZerobss
 8003964:	d3f9      	bcc.n	800395a <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8003966:	f7ff fe19 	bl	800359c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800396a:	f000 f811 	bl	8003990 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800396e:	f7ff fd29 	bl	80033c4 <main>

08003972 <LoopForever>:

LoopForever:
    b LoopForever
 8003972:	e7fe      	b.n	8003972 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 8003974:	20010000 	.word	0x20010000
	ldr	r3, =_sidata
 8003978:	08003acc 	.word	0x08003acc
	ldr	r0, =_sdata
 800397c:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 8003980:	20000110 	.word	0x20000110
	ldr	r2, =_sbss
 8003984:	20000110 	.word	0x20000110
	ldr	r3, = _ebss
 8003988:	2000325c 	.word	0x2000325c

0800398c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800398c:	e7fe      	b.n	800398c <ADC1_2_IRQHandler>
	...

08003990 <__libc_init_array>:
 8003990:	b570      	push	{r4, r5, r6, lr}
 8003992:	4e0d      	ldr	r6, [pc, #52]	; (80039c8 <__libc_init_array+0x38>)
 8003994:	4c0d      	ldr	r4, [pc, #52]	; (80039cc <__libc_init_array+0x3c>)
 8003996:	1ba4      	subs	r4, r4, r6
 8003998:	10a4      	asrs	r4, r4, #2
 800399a:	2500      	movs	r5, #0
 800399c:	42a5      	cmp	r5, r4
 800399e:	d109      	bne.n	80039b4 <__libc_init_array+0x24>
 80039a0:	4e0b      	ldr	r6, [pc, #44]	; (80039d0 <__libc_init_array+0x40>)
 80039a2:	4c0c      	ldr	r4, [pc, #48]	; (80039d4 <__libc_init_array+0x44>)
 80039a4:	f000 f820 	bl	80039e8 <_init>
 80039a8:	1ba4      	subs	r4, r4, r6
 80039aa:	10a4      	asrs	r4, r4, #2
 80039ac:	2500      	movs	r5, #0
 80039ae:	42a5      	cmp	r5, r4
 80039b0:	d105      	bne.n	80039be <__libc_init_array+0x2e>
 80039b2:	bd70      	pop	{r4, r5, r6, pc}
 80039b4:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80039b8:	4798      	blx	r3
 80039ba:	3501      	adds	r5, #1
 80039bc:	e7ee      	b.n	800399c <__libc_init_array+0xc>
 80039be:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80039c2:	4798      	blx	r3
 80039c4:	3501      	adds	r5, #1
 80039c6:	e7f2      	b.n	80039ae <__libc_init_array+0x1e>
 80039c8:	08003ac4 	.word	0x08003ac4
 80039cc:	08003ac4 	.word	0x08003ac4
 80039d0:	08003ac4 	.word	0x08003ac4
 80039d4:	08003ac8 	.word	0x08003ac8

080039d8 <memset>:
 80039d8:	4402      	add	r2, r0
 80039da:	4603      	mov	r3, r0
 80039dc:	4293      	cmp	r3, r2
 80039de:	d100      	bne.n	80039e2 <memset+0xa>
 80039e0:	4770      	bx	lr
 80039e2:	f803 1b01 	strb.w	r1, [r3], #1
 80039e6:	e7f9      	b.n	80039dc <memset+0x4>

080039e8 <_init>:
 80039e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80039ea:	bf00      	nop
 80039ec:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80039ee:	bc08      	pop	{r3}
 80039f0:	469e      	mov	lr, r3
 80039f2:	4770      	bx	lr

080039f4 <_fini>:
 80039f4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80039f6:	bf00      	nop
 80039f8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80039fa:	bc08      	pop	{r3}
 80039fc:	469e      	mov	lr, r3
 80039fe:	4770      	bx	lr
